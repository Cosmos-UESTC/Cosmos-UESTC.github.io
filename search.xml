<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Icoding平台第三次作业解析-字符串</title>
      <link href="/2020/03/31/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/03/31/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>串比较<br>不调用库函数，自己实现字符串的比较操作：<code>该操作当比较的两个字符是都是字母，且两个字符互为大小写（如a和A、e和E）时认为两个字符相同，否则不同，其比较结果按这两个字符的原值确定。</code>函数的返回值规定如下：<br>返回值 &lt; 0：第一个不匹配的字符在 ptr1 中的值低于 ptr2 中的值<br>返回值 == 0：两个字符串的内容相等<br>返回值 &gt; 0：第一个不匹配的字符在 ptr1 中的值大于在 ptr2 中的值</li></ol><p>函数原型如下： </p><blockquote><p>int str_compare(const char* ptr1, const char* ptr2);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_compare(const char* ptr1, const char* ptr2)</span><br><span class="line">&#123;</span><br><span class="line">    char* p1 &#x3D; ptr1;</span><br><span class="line">    char* p2 &#x3D; ptr2;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    while (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">        if (*p1 &#x3D;&#x3D; *p2 || *p1 &#x3D;&#x3D; *p2 - 32 || *p2 &#x3D;&#x3D; *p1 - 32) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125; else if (*p1 &lt; *p2) &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (*p1 &gt; *p2) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else if (*p1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; -1;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>串替换<br>不调用库函数，自己实现字符串替换操作，函数原型为：<blockquote><p>int str_replace(const char *in, char *out, int outlen, const char *oldstr, const char *newstr);</p></blockquote></li></ol><p>参数说明:<br>    in， 原始字符串，保持不变<br>    out, 存放替换结果的字符串<br>    outlen，out空间的大小<br>    oldstr，要替换的旧字符串<br>    newstr，替换成的新字符串<br>函数返回成功替换的次数，即有多少个子串被成功替换</p><p>在替换过程中，任何情况下所得字符串（及结束符）不应该超过 outlen，如果某次替换所得字符串的长度超过 outlen，则不进行这次替换操作，整个替换操作结束。如：<br>原始串为 “aaabbbccc”，outlen 为14, oldstr 为 “c”，newstr 为 “333” 时，两次替换后得 “aaabbb333333c”，此时字符串占用空间为14字节。<br>如果再进行替换，则会超出 out 所占用的空间，所以停止替换操作。此时函数应该返回 2, out指向的串为 “aaabbb333333c”<br>再如：原始串为 “aaabbbccc”，outlen 为10, oldstr 为 “bb”，newstr 为 “123456”，进行替换后所得的串应该为 “aaa123456” （长度为9）与结束符一共占 10 个字节，此时函数应该返回 1。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-31, Tue, 21:49:50</span><br><span class="line"> * 最高分数：96</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_replace(const char* in, char* out, int outlen, const char* oldstr, const char* newstr)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;char a &#x3D; &quot;aaabbbccc&quot;;</span><br><span class="line">    &#x2F;&#x2F;char b &#x3D; &quot;c&quot;, c &#x3D; &quot;cc&quot;, d &#x3D; &quot;123&quot;, e &#x3D; &quot;123456&quot;, f &#x3D; &quot;12345678&quot;;</span><br><span class="line"></span><br><span class="line">    char *cur1 &#x3D; in, *cur2 &#x3D; out;</span><br><span class="line">    int len &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    while (*out !&#x3D; 0)</span><br><span class="line">        *out &#x3D; 0, out++;</span><br><span class="line">    while (len &lt; outlen &amp;&amp; *cur1) &#123;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        char *p1 &#x3D; cur1, *p2 &#x3D; oldstr;</span><br><span class="line">        while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 &#x3D;&#x3D; *p2)</span><br><span class="line">            p1++, p2++;</span><br><span class="line">        if (*p2 !&#x3D; 0)</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            char* p &#x3D; newstr;</span><br><span class="line">            int len1 &#x3D; len;</span><br><span class="line">            while (*p)</span><br><span class="line">                len1++, *p++;</span><br><span class="line">            if (len1 &gt; outlen) &#123;</span><br><span class="line">                while (*cur1 &amp;&amp; len &lt; outlen + 1)</span><br><span class="line">                    *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 &#x3D; p1;</span><br><span class="line">            ans++;</span><br><span class="line">            p &#x3D; newstr;</span><br><span class="line">            while (*p)</span><br><span class="line">                *cur2 &#x3D; *p, cur2++, p++, len++;</span><br><span class="line">        &#125; else</span><br><span class="line">            *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第二次作业解析-队列栈</title>
      <link href="/2020/03/26/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/03/26/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>队列 循环列表表示栈<br>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），请完成下列任务：<br>1: 队列初始化，成功返回真，否则返回假  <blockquote><p>bool init_queue(LinkQueue <em>LQ);<br>2: 入队列，成功返回真，否则返回假：<br>bool enter_queue(LinkQueue *LQ, ElemType x);<br>3: 出队列，成功返回真，且</em>x为出队的值，否则返回假<br>bool leave_queue(LinkQueue *LQ, ElemType *x);</p></blockquote></li></ol><p>相关定义如下：</p><blockquote><p>typedef struct _QueueNode {<br>    ElemType data;          /<em>数据域</em>/<br>    struct _QueueNode <em>next;      /*指针域</em>/<br>}LinkQueueNode, *LinkQueue;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-26, Thu, 10:34:14</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool init_queue(LinkQueue* LQ)</span><br><span class="line">&#123;</span><br><span class="line">    *LQ &#x3D; (LinkQueue)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    (*LQ)-&gt;next &#x3D; *LQ;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool enter_queue(LinkQueue* LQ, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueueNode* p &#x3D; (LinkQueueNode*)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        (*LQ)-&gt;next &#x3D; p;</span><br><span class="line">        *LQ &#x3D; p;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool leave_queue(LinkQueue* LQ, ElemType* x)</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue rear &#x3D; (*LQ);</span><br><span class="line">    if (rear-&gt;next &#x3D;&#x3D; rear)</span><br><span class="line">        return 0;</span><br><span class="line">    (*x) &#x3D; rear-&gt;next-&gt;next-&gt;data;</span><br><span class="line">    if (rear-&gt;next-&gt;next &#x3D;&#x3D; rear) &#123;</span><br><span class="line">        (*LQ) &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        free(rear);</span><br><span class="line">        (*LQ)-&gt;next &#x3D; (*LQ);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueue temp &#x3D; rear-&gt;next-&gt;next;</span><br><span class="line">    rear-&gt;next-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>栈 后缀表达式计算<br>请使用已定义好的栈完成后缀表达式计算：<br>(1)如果是操作数，直接入栈<br>(2)如果是操作符op，连续出栈两次，得到操作数x 和 y,计算 x op y，并将结果入栈。<br>后缀表达式示例如下：<br>9  3  1  -  3  *  +  10  2  /  +<br>13  445  +  51  /  6  -<br>操作数、操作符之间由空格隔开，操作符有 +，-，*, /, %共 5 种符号，所有操作数都为整型。<br>栈的定义如下：<blockquote><p>#define Stack_Size 50<br>typedef struct{</p><pre><code>ElemType elem[Stack_Size];int top;</code></pre><p>}Stack;</p><p>bool push(Stack* S, ElemType x);<br>bool pop(Stack* S, ElemType *x);<br>void init_stack(Stack *S);</p></blockquote></li></ol><p>其中，栈初始化的实现为：</p><blockquote><p>void init_stack(Stack *S){<br>    S-&gt;top = -1;<br>}</p></blockquote><p>需要完成的函数定义为：</p><blockquote><p>int compute_reverse_polish_notation(char *str);<br>函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-23, Mon, 19:19:11</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int compute_reverse_polish_notation(char* str)</span><br><span class="line">&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    int num &#x3D; 0;</span><br><span class="line">    while (*str !&#x3D; 0) &#123;</span><br><span class="line">        while (*str &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            str++;</span><br><span class="line">        if (*str &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (*str &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a + b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b - a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a * b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b &#x2F; a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;%&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b % a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int x &#x3D; 0;</span><br><span class="line">            do &#123;</span><br><span class="line">                x &#x3D; x * 10 + *str - &#39;0&#39;;</span><br><span class="line">                str++;</span><br><span class="line">            &#125; while (*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39; &amp;&amp; *str !&#x3D; 0);</span><br><span class="line">            push(&amp;s, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop(&amp;s, &amp;num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第一次作业解析-线性表</title>
      <link href="/2020/03/15/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/03/15/Icoding%E5%B9%B3%E5%8F%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li><p>顺序表 删除指定范围<br>设计一个高效的算法，从顺序表L中删除所有值介于x和y之间(包括x和y)的所有元素（假设y&gt;=x），要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_x2y(SeqList *L, ElemType x, ElemType y);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:46:50</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_x2y(SeqList* L, ElemType x, ElemType y)</span><br><span class="line">&#123;</span><br><span class="line">    int last &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; L-&gt;last; i++)</span><br><span class="line">        if (L-&gt;elem[i] &lt; x || L-&gt;elem[i] &gt; y)</span><br><span class="line">            L-&gt;elem[++last] &#x3D; L-&gt;elem[i];</span><br><span class="line">    L-&gt;last &#x3D; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li><p>顺序表 删除重复<br>编写算法，在一非递减的顺序表L中，删除所有值相等的多余元素。要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_dupnum(SeqList *L)<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:49:49</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_dupnum(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int flag &#x3D; 0, val &#x3D; L-&gt;elem[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; L-&gt;last; i++) &#123;</span><br><span class="line">        if (val !&#x3D; L-&gt;elem[i]) &#123;</span><br><span class="line">            val &#x3D; L-&gt;elem[i];</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            L-&gt;elem[flag] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last &#x3D; flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>顺序表 数据调整<br>已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n),空间复杂度为O（1）。<br>链表结点定义如下：<blockquote><p>void odd_even(SeqList *L);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li></ol><p>2.解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-03, Tue, 18:32:04</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void odd_even(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int j &#x3D; L-&gt;last;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (L-&gt;elem[i] % 2 !&#x3D; 0)</span><br><span class="line">            i++;</span><br><span class="line">        while (L-&gt;elem[j] % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            j--;</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int t &#x3D; L-&gt;elem[i];</span><br><span class="line">            L-&gt;elem[i] &#x3D; L-&gt;elem[j];</span><br><span class="line">            L-&gt;elem[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><ol><li><p>链表 删除范围内结点<br>已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有大于mink且小于maxk的元素（若表中存在这样的元素），分析你的算法的时间复杂度。<br>链表结点定义如下：</p><blockquote><p>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;<br>函数原型如下：<br>void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)<br>其中L指向链表的头结点。</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:35:51</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p, q, prev &#x3D; NULL;</span><br><span class="line">    if (mink &gt; maxk)</span><br><span class="line">        return;</span><br><span class="line">    p &#x3D; L;</span><br><span class="line">    prev &#x3D; p;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    while (p &amp;&amp; p-&gt;data &lt; maxk) &#123;</span><br><span class="line">        if (p-&gt;data &lt;&#x3D; mink) &#123;</span><br><span class="line">            prev &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h1><ol><li><p>链表 倒数查找<br>已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。<br>函数原型为：</p><blockquote><p>int lnk_search(LinkList L, int k, ElemType* p_ele)<br>若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:40:21</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int lnk_search(LinkList L, int k, ElemType* p_ele)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p &#x3D; L-&gt;next, q &#x3D; L-&gt;next;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        if (count &lt; k)</span><br><span class="line">            count++;</span><br><span class="line">        else</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt; k)</span><br><span class="line">        return 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        p_ele &#x3D; q-&gt;data;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h1><ol><li><p>链表 合并<br>设线性表A=(a1, a2,…,am)，B=(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：<br>C= (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；<br>或者<br>C= (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。<br>线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。<br>函数的原型如下：</p><blockquote><p>void lnk_merge(LinkList A, LinkList B, LinkList C)<br>即将A和B合并为C，其中 C 已经被初始化为空单链表<br>相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-21, Sat, 12:38:40</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_merge(LinkList A, LinkList B, LinkList C)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p, *q, *m, *temp;</span><br><span class="line">    p &#x3D; A-&gt;next;</span><br><span class="line">    q &#x3D; B-&gt;next;</span><br><span class="line">    m &#x3D; C;</span><br><span class="line">    while (p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">        temp &#x3D; p-&gt;next;</span><br><span class="line">        p-&gt;next &#x3D; q;</span><br><span class="line">        m &#x3D; q;</span><br><span class="line">        p &#x3D; temp;</span><br><span class="line">        q &#x3D; q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用githubPages架构简单的静态网页</title>
      <link href="/2020/02/10/Pages%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E2%91%A0%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91/"/>
      <url>/2020/02/10/Pages%E6%9E%B6%E6%9E%84%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E2%91%A0%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Github账号的注册"><a href="#Github账号的注册" class="headerlink" title="Github账号的注册"></a>Github账号的注册</h1><ol><li><p>首先在<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个GitHub账号，并在你的Github Repositories下新建一个名为YourName.github.io的仓库。</p></li><li><p>所有选项按照默认配置就行。</p><blockquote><p>值得注意的是，GitHub平台是全英文的，因此具备一定的英语水平还是必要的</p></blockquote></li><li><p>其次，下载<a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>并安装，所有选项按照默认配置即可</p><blockquote><p>Git的所有操作一般都在Gi bash控制台界面进行，因此学习掌握Git的使用是十分必要的</p></blockquote></li><li><p>打开Git Bash控制台，使用git config –global user.name指令生命本机用户名，之后使用git config –global user.email指令声明本机用户名对应的邮箱地址。再使用ssh-keygen -t rsa -C <a href="mailto:email@email.com">email@email.com</a>指令生成新的ssh公钥</p></li><li><p>使用cd指令选择一个合适的路径存放你的本地仓库，使用mkdir指令建立一个由你自由命名的文件夹。</p><blockquote><p>Linux指令： cd——用于切换所在目录<br>Linux指令: mkdir——用于新建文件/文件夹</p></blockquote></li><li><p>使用git init指令对本地仓库进行初始化。至此，你的一个本地仓库已经架构完成！</p><blockquote><p>Git指令： git init——用于在一个空的位置进行Git的初始化</p></blockquote></li></ol><hr><h1 id="本地仓库与Github-Repositories-建立连接"><a href="#本地仓库与Github-Repositories-建立连接" class="headerlink" title="本地仓库与Github Repositories 建立连接"></a>本地仓库与Github Repositories 建立连接</h1><ol><li>在GitHub的Settings中找到SSH and GPG keys并且选择New SSH key，找到你的电脑中.ssh文件夹中的公钥文件id_rsa.pub，并将其中的内容复制到网页相应位置，配置成功之后保存即可。</li><li>使用ssh -T <a href="mailto:git@github.com">git@github.com</a>测试连接是否成功<blockquote><p>Git指令： ssh -T <a href="mailto:git@github.com">git@github.com</a>——用于测试本地仓库与远程仓库之间是否成功连接</p></blockquote></li><li>连接测试成功之后找到网页上你的相应仓库，在Clone or Download中选择Clone with Https，复制URL。回到Git Bash控制台，使用git remote add origin [你刚刚复制的URL] 指令进行远程连接<blockquote><p>Git指令： git remote add origin [URL]——连接本地仓库到指定的远程库</p></blockquote></li><li>连接成功之后，你就可以将本地仓库的内容远程push到GitHub仓库中去了。<blockquote><p>Git指令： git push——将本地仓库的内容推送到远程库中</p><blockquote><p>Git push的一般步骤：</p><pre><code>1. git add .2. git status3. git commit -m &quot;备注内容&quot;4. git push</code></pre></blockquote></blockquote></li></ol><h1 id="启用Github-Pages功能"><a href="#启用Github-Pages功能" class="headerlink" title="启用Github Pages功能"></a>启用Github Pages功能</h1><ol><li>将你的仓库名称修改为YourName.github.io</li><li>在你的Repositories的Settings中找到GitHub Pages选项，将Source改为master branch后保存。</li></ol><h1 id="搭建一个静态网页"><a href="#搭建一个静态网页" class="headerlink" title="搭建一个静态网页"></a>搭建一个静态网页</h1><ol><li>一般的，我们从搭建静态网页开始。在本地仓库中建立index.html作为主界面文件。打开index.html</li><li>键入<p>Hello World!</p>并保存。</li><li>在你的本地仓库的文件夹内用鼠标右键单击Git Bash Here唤起Git Bash控制台，使用git add .指令将所有的文件提交到缓存区，使用git status命令查看文件状态，确认无误后，使用git commit -m “你想要留下的备注”提交更改，之后用git push命令将所有的更改上传到GitHub的远程仓库中。<blockquote><p>Git push的全套流程参见上文</p></blockquote></li><li>至此，一个最简单的静态网页就被成功搭建了。你可以通过YourName.github.io这个网址来访问你的个人网站。</li></ol><h1 id="将GitHub-Pages架构的网站解析到自己的域名"><a href="#将GitHub-Pages架构的网站解析到自己的域名" class="headerlink" title="将GitHub Pages架构的网站解析到自己的域名"></a>将GitHub Pages架构的网站解析到自己的域名</h1><ol><li>你需要购买一个域名的使用期限。本文以在腾讯云平台购买域名为例</li><li>在腾讯云官网上进行注册和实名认证，依靠后缀找到合适的域名，并且确认其是否可用。在付款之后即可使用。<blockquote><p>一个教训：选择域名后缀的时候不要贪图便宜或者过于追求新意。笔者的以.space为后缀的域名目前面临着无法进行公安备案的尴尬处境</p></blockquote></li><li>两种解析方式<ul><li>在腾讯域名管理界面选择解析，利用电脑自带的CMD或者PowerShell控制台，输入Ping YourName.github.io来确认IP地址，直接解析该IP地址，添加到解析记录中。</li><li>或者在解析时选择CNAME方式，在后面可以直接解析githubpages网址（就是YourName.github.io）</li></ul></li><li>解析记录添加成功之后即可直接从该域名访问个人网站。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github || 静态网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test01</title>
      <link href="/2020/02/10/test01/"/>
      <url>/2020/02/10/test01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="这是一个测试页面"><a href="#这是一个测试页面" class="headerlink" title="这是一个测试页面"></a>这是一个测试页面</h1><h2 id="测试开始于2020-02-10"><a href="#测试开始于2020-02-10" class="headerlink" title="测试开始于2020-02-10"></a>测试开始于2020-02-10</h2><h3 id="正在测试多级标题的完整性"><a href="#正在测试多级标题的完整性" class="headerlink" title="正在测试多级标题的完整性"></a>正在测试多级标题的完整性</h3><h4 id="这是第四级标题"><a href="#这是第四级标题" class="headerlink" title="这是第四级标题"></a>这是第四级标题</h4><h5 id="这是第五级标题"><a href="#这是第五级标题" class="headerlink" title="这是第五级标题"></a>这是第五级标题</h5><h6 id="这是第六级标题"><a href="#这是第六级标题" class="headerlink" title="这是第六级标题"></a>这是第六级标题</h6><pre><code>测试</code></pre><p>1234567890<br>    测试</p><ul><li>测试01</li><li>测试02</li><li>测试03</li></ul><ol start="4"><li>测试04</li><li>测试05</li><li>测试06</li></ol><p>【外链文本测试】（<a href="http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）" target="_blank" rel="noopener">http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）</a></p><p>【外链图片测试】<br>！【avatar】（<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）</a></p><p>#引用测试</p><blockquote><p>夕阳像一只狐狸悄悄穿过这片土地，转瞬间点燃荒草。——果戈里</p></blockquote><p><em>夕阳</em>像一只<strong>狐狸</strong>悄悄<em>穿过</em>这片<strong>土地</strong>，<code>转瞬间点燃荒草</code></p><p>#代码插入测试<br><code>printf(&quot;Hello,World!&quot;);</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;Sum &#x3D; %d&quot;,a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>#表格插入测试</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>#图片测试2</p><p>![][1]<br>[1]:<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg</a></p><p>#初次测试结束<br>###2020-02-10</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/02/10/hello-world/"/>
      <url>/2020/02/10/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
