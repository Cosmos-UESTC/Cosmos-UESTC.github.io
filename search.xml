<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bilibili_2020_1024程序员节Ctf</title>
      <link href="/post/6d0a3683.html"/>
      <url>/post/6d0a3683.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>1024，一年一度的程序员节。你好，世界！你好，程序员！<br>（但是 2 0 2 0 - 1 0 2 4 … hhh<br>就在10.24的0点，Bilibili为大家献上了一份大礼：Bilibili_CTF_2020<br>经过了艰苦卓绝（并不 的奋战，我终于拿到了70 of 100 的分数（平 均 水 平<br>接下来带来这7道题的解析，希望能够成为对Ctf新手的指引吧<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/bilisrc.jpg" class="lazyload"></a><br><code>守护世界上最好的睿叔！(笑</code></p><h1 id="Question-ID-1-页面的背后是什么？"><a href="#Question-ID-1-页面的背后是什么？" class="headerlink" title="Question_ID_1 页面的背后是什么？"></a>Question_ID_1 页面的背后是什么？</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>顾名思义，页面的背后就是源代码啦~<br>F12检查元素，得到第一题的源码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;admin&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            var input &#x3D; document.getElementById(&quot;flag1&quot;);</span><br><span class="line">            input.value &#x3D; String(data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag1&#39;).html(&quot;接口异常，请稍后再试～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>根据提示修改url为<code>http://45.113.201.36/api/admin</code>,页面返回<code>{&quot;code&quot;:200,&quot;data&quot;:&quot;9eaf84d8-0336b140-23185a95-13d5825f&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>在依据代码逻辑，我们确定Flag1为<code>9eaf84d8-0336b140-23185a95-13d5825f</code></p><h1 id="Question-ID-2-真正的秘密只有特殊的设备才能看到"><a href="#Question-ID-2-真正的秘密只有特殊的设备才能看到" class="headerlink" title="Question_ID_2 真正的秘密只有特殊的设备才能看到"></a>Question_ID_2 真正的秘密只有特殊的设备才能看到</h1><p>题目地址:<code>http://45.113.201.36/index.html</code></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>诶？特殊的设备？<br>还是老老实实检查元素吧~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/Bilibili_Ctf1.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &quot;api&#x2F;ctf&#x2F;2&quot;,</span><br><span class="line">    type: &quot;get&quot;,</span><br><span class="line">    success:function (data) &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(data);</span><br><span class="line">        if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;flag2: &quot; + data.data);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果没值</span><br><span class="line">            $(&#39;#flag2&#39;).html(&quot;需要使用bilibili Security Browser浏览器访问～&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>可是，<code>需要使用bilibili Security Browser浏览器访问～</code>又是什么意思呢？<br>对了！我们可以修改UA标识！！<br>F12检查元素，模拟设备<del>添加自定义设备！<br>我们加入一个名为bilibili Security Browser的新设备，刷新页面发现并没有得出Flag<br>索性把所有涉及设备的参数设置为bilibili Security Browser，F5刷新后，就得到了Flag</del><br>Flag2:<code>be74383e-0b87bbde-40c0c5c4-da62eec3</code></p><h1 id="Question-ID-3-密码是啥？"><a href="#Question-ID-3-密码是啥？" class="headerlink" title="Question_ID_3 密码是啥？"></a>Question_ID_3 密码是啥？</h1><p>题目地址:<code>http://45.113.201.36/login.html</code></p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>F12康康代码逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;falg 3</span><br><span class="line"></span><br><span class="line">$(&quot;#submit&quot;).click(function()&#123;</span><br><span class="line">    </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;3&quot;,</span><br><span class="line">        type: &quot;post&quot;,</span><br><span class="line">        contentType: &quot;application&#x2F;json&quot;,</span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line">        data: JSON.stringify(&#123;</span><br><span class="line">            username: $(&quot;#name&quot;).val(),</span><br><span class="line">            passwd: $(&quot;#subject&quot;).val(),</span><br><span class="line">        &#125;),</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                alert(&quot;flag is: &quot; + data.data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;用户名或密码错误～&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF2.jpg" class="lazyload"></a><br>密码是什么呢？首先考虑密码爆破！<br>跑完了字典，但是密码并没有试出来……<br>简单想想，用户名应该就是admin没得跑，那么密码是什么呢？<br>最终猜测得到bilibili = = （CTF× 猜 灯 谜√</p><p>Flag3:<code>3f06bf77-e57dad87-a669c72b-4d8b296b</code></p><h1 id="Question-ID-4-对不起，权限不足～"><a href="#Question-ID-4-对不起，权限不足～" class="headerlink" title="Question_ID_4 对不起，权限不足～"></a>Question_ID_4 对不起，权限不足～</h1><p>题目地址:<code>http://45.113.201.36/superadmin.html</code></p><p><a href="undefined" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src class="lazyload"></a></p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF3.jpg" class="lazyload"></a><br>F12!</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">     url: &quot;api&#x2F;ctf&#x2F;4&quot;,</span><br><span class="line">     type: &quot;get&quot;,</span><br><span class="line">     success:function (data) &#123;</span><br><span class="line">         console.log(data);</span><br><span class="line">         if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">             &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～答案是 : &#123;&#123; &quot; + data.data + &quot; &#125;&#125;&quot;.toLowerCase() )</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             &#x2F;&#x2F; 如果没值</span><br><span class="line">             $(&#39;#flag&#39;).html(&quot;有些秘密只有超级管理员才能看见哦~&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></div><p>好家伙，我直接懵逼.jpg<br>打开Fiddler抓个包~<br>查看返回包的Cookie时候，发现了有意思的东西:<br><code>Cookie: role=ee11cbb19052e40b07aac0ca060c23ee; session=eyJ1aWQiOiIzNzIwODMyMSJ9.X5Qnkw.1NWStBUpUlAWQhYOM9av9W_qEWA</code><br>这个role值就很耐人寻味呀~似乎是一个加密后的字符串？<br>尝试解码，初步确定是MD5加密后的结果，且解密为admin字符串<br>那么思路就应该是替换Cookie的字段值了。将superadmin采用md5加密，利用EditThisCookie插件修改role值，居然不对！<br>猜来猜去，administrator,Superadmin,SuperAdmin……<br>最终正确答案为Administrator【md5:7b7bc2512ee1fedcd76bdc68926d4f7b】 = = 万万没想到啊！<br>修改Cookie后刷新页面，就会返回正确的Flag啦！<br>Flag5:<code>126fb903-b39dfd0d-0bf68925-219cd931</code></p><h1 id="Question-ID-5-别人的秘密"><a href="#Question-ID-5-别人的秘密" class="headerlink" title="Question_ID_5 别人的秘密"></a>Question_ID_5 别人的秘密</h1><p>题目地址:<code>http://45.113.201.36/user.html</code></p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>并看不懂= =，管他的，F12！<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF5.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$(function () &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    (function ($) &#123;</span><br><span class="line">        $.getUrlParam &#x3D; function(name) &#123;</span><br><span class="line">            var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">            var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">            if (r !&#x3D; null) return unescape(r[2]); return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">    var uid &#x3D; $.getUrlParam(&#39;uid&#39;);</span><br><span class="line">    if (uid &#x3D;&#x3D; null) &#123;</span><br><span class="line">        uid &#x3D; 100336889;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;api&#x2F;ctf&#x2F;5?uid&#x3D;&quot; + uid,</span><br><span class="line">        type: &quot;get&quot;,</span><br><span class="line">        success:function (data) &#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">            if (data.code &#x3D;&#x3D; 200)&#123;</span><br><span class="line">                &#x2F;&#x2F; 如果有值：前端跳转</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;欢迎超级管理员登陆～flag : &quot; + data.data )</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果没值</span><br><span class="line">                $(&#39;#flag&#39;).html(&quot;这里没有你想要的答案～&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>原来如此！遍历！遍历！！<br>用Get方法，以<code>http://45.113.201.36/api/ctf/5?uid=100336889</code>为基准，uid++向上遍历！<br>遍历到<code>http://45.113.201.36/api/ctf/5?uid=100336913</code>的时候，服务端返回了code:200！<br><code>{&quot;code&quot;:200,&quot;data&quot;:&quot;314ebf97-6bc0234f-b906e013-52b47f23&quot;,&quot;msg&quot;:&quot;&quot;}</code><br>(果然是“别人的秘密”呀</p><p>那么，Flag5:<code>314ebf97-6bc0234f-b906e013-52b47f23</code></p><h1 id="Question-ID-6-结束亦是开始"><a href="#Question-ID-6-结束亦是开始" class="headerlink" title="Question_ID_6 结束亦是开始"></a>Question_ID_6 结束亦是开始</h1><p>题目地址:<code>http://45.113.201.36/blog/single.php?id=1</code></p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>终于我们进入了动态页面的世界~<br><a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" data-fancybox="group" data-caption="Alt text" class="fancybox"><img alt="Alt text" title="Alt text" data-src="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BILIBILICTF6.jpg" class="lazyload"></a><br>扫描！扫描！<br>我们得到了两个页面:end.php和test.php<br>end.php就和他的名字一样，空白的页面，和一句<strong>你想要的不在这儿～</strong><br>而test.php就有趣的多了:页面返回内容如下</p><h3 id="内容（建议跳过"><a href="#内容（建议跳过" class="headerlink" title="内容（建议跳过"></a>内容（建议跳过</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!</span><br><span class="line"></span><br><span class="line">………（太长啦~</span><br><span class="line"></span><br><span class="line">+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+[]))+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+(+!![][]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[]))</span><br></pre></td></tr></table></figure></div><p>很明显的jsfuck加密方法，最初被黑客用于网页注入~<br>在Chrome浏览器粘贴运行可以直接解码<br>结果为： </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;var str1 &#x3D; &quot;\u7a0b\u5e8f\u5458\u6700\u591a\u7684\u5730\u65b9&quot;;</span><br><span class="line">var str2 &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line">console.log()&quot;</span><br></pre></td></tr></table></figure></div><p>str1的内容很容易看出是Unicode字符，经转化得到<strong>程序员最多的地方</strong><br>果断打开最大的同性交友网站（划掉 Github！搜索bilibili1024havefun找到对应的Repository<br>拿到真·end.php的源码:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;filename end.php</span><br><span class="line"></span><br><span class="line">$bilibili &#x3D; &quot;bilibili1024havefun&quot;;</span><br><span class="line"></span><br><span class="line">$str &#x3D; intval($_GET[&#39;id&#39;]);</span><br><span class="line">$reg &#x3D; preg_match(&#39;&#x2F;\d&#x2F;is&#39;, $_GET[&#39;id&#39;]);</span><br><span class="line"></span><br><span class="line">if(!is_numeric($_GET[&#39;id&#39;]) and $reg !&#x3D;&#x3D; 1 and $str &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">$content &#x3D; file_get_contents($_GET[&#39;url&#39;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件路径猜解</span><br><span class="line">if (false)&#123;</span><br><span class="line">echo &quot;还差一点点啦～&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo $flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;你想要的不在这儿～&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div><p>传参id[]=1满足第一个条件，按照前面题目的格式api/ctf/x，不难猜出有api/ctf/6/flag.txt<br>考虑到这玩意也不是个flag，又想到图片隐写~于是另存为图片，打开就是flag啦<br>于是得到了Flag10:<code>2ebd3b08-47ffc478-b49a5f9d-f6099d65</code>（？？《关于我做第六题却得到了第十题Flag的事》</p><h1 id="Question-ID-7-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-7-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_7 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_7 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-8-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-8-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_8 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_8 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>在NodeJS框架下解<br>需要库：redis<br>阶梯代码如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var redis &#x3D; require(&#39;redis&#39;),</span><br><span class="line">  RDS_PORT &#x3D; 6379,</span><br><span class="line">  RDS_HOST &#x3D; &#39;120.92.151.189&#39;,</span><br><span class="line">  RDS_OPTS &#x3D; &#123;&#125;,</span><br><span class="line">  client &#x3D; redis.createClient(RDS_PORT, RDS_HOST, RDS_OPTS);</span><br><span class="line"></span><br><span class="line">client.on(&#39;connect&#39;, function () &#123;</span><br><span class="line">  client.hgetall(&quot;flag8&quot;, (e, r) &#x3D;&gt; &#123;</span><br><span class="line">    console.dir(r);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><p>喜闻乐见的是，全国的带佬们都在用扫描，不排除还有爆破从而达成人肉DDOS的hhh<br>总而言之，服务器在挂的边缘疯狂试探，我愿称之为服务器的挂&amp;不挂二象性<br>多试几次~</p><p>返回结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag1&quot;</span><br><span class="line">&quot;3b96173a-b3df4cdd-22d4c15f-261e7309&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag2&quot;</span><br><span class="line">&quot;bd871042-1e09a130-3ddd4faa-cebdb048&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag3&quot;</span><br><span class="line">&quot;c7f7a7c2-28b7f895-5432152b-6410e042&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag4&quot;</span><br><span class="line">&quot;d338e3c8-93215105-258d79ba-b364e59c&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag5&quot;</span><br><span class="line">&quot;612d1886-044898af-6c1e9dba-b58ad075&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag6&quot;</span><br><span class="line">&quot;8aa6f15d-65e37c9b-78c2bc37-00ed5aee&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag7&quot;</span><br><span class="line">&quot;b78ce2aa-10d03327-f2035f4e-55c17689&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag8&quot;</span><br><span class="line">&quot;d436b982-2b81aa54-49a8d2db-87ab951a&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag9&quot;</span><br><span class="line">&quot;b3238659-b81512e6-3a307c74-9877ecc5&quot;</span><br><span class="line">[root@demo ~]# redis-cli -h 120.92.151.189 -p 6379 -r 1 get &quot;flag10&quot;</span><br><span class="line">&quot;e5653416-595b3d0c-4c2a57ee-c026350e&quot;</span><br></pre></td></tr></table></figure></div><p>我们得到了Flag8:<code>d436b982-2b81aa54-49a8d2db-87ab951a</code></p><h1 id="Question-ID-9-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-9-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_9 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_9 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="Question-ID-10-接下来的旅程，需要少年自己去探索啦～"><a href="#Question-ID-10-接下来的旅程，需要少年自己去探索啦～" class="headerlink" title="Question_ID_10 接下来的旅程，需要少年自己去探索啦～"></a>Question_ID_10 接下来的旅程，需要少年自己去探索啦～</h1><p>题目地址:<code>NULL</code></p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>404</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>6、7、9题截止目前还没有解出来<br>（史称679事件 （（我还是太菜了啊TAT<br>总之Bilibili_2020_10_24_CTF的题目就做到这里了，虽然都是Web方向的题，但是还是存在着很多运气的成分（Administrator /笑<br>对新手还是蛮友好的，前5题还是可以学到很多东西，特别是Web题里面的一些基础知识~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Bilibili </tag>
            
            <tag> PHP </tag>
            
            <tag> ctf </tag>
            
            <tag> Web </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNSS2020_招新解析</title>
      <link href="/post/b5f19194.html"/>
      <url>/post/b5f19194.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>施工中！！！Coming Soon！！！</strong></p><h1 id="Web方向"><a href="#Web方向" class="headerlink" title="Web方向"></a>Web方向</h1><h2 id="Web-01-baby-Web-方向做题须知"><a href="#Web-01-baby-Web-方向做题须知" class="headerlink" title="Web_01_(baby)Web 方向做题须知"></a>Web_01_(baby)Web 方向做题须知</h2><h3 id="Web-方向做题须知"><a href="#Web-方向做题须知" class="headerlink" title="Web 方向做题须知"></a>Web 方向做题须知</h3><p>1.Web题目为每道题目描述里给出的链接地址所指向的web应用(所以不要在平台题目描述界面寻找flag了<br>2.flag格式统一为cnss{} 花括号中间为有意义的字符串，通常会以_区分单个单词<br>3.hint意为提示 是出题人给出的解题提示 并不要求你在flag提交处作答(x<br>4.当你成功得到flag时 flag一定是以cnss{}的形式显示的 所以不需要自己手动添加cnss{}(如果有那你找到的一定不是flag</p><h4 id="做题要求"><a href="#做题要求" class="headerlink" title="做题要求"></a>做题要求</h4><blockquote><p>要会看HTML源码<br>能读懂简单的PHP代码<br>懂一点点HTTP报文<br>学会使用burpsuite的repeater模块</p></blockquote><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><blockquote><p>burpsuite<br>metasploit<br>AntSword<br>f12开发者工具 插件如hackbar等<br>ps:浏览器请使用 firefox/chrome</p></blockquote><h4 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h4><blockquote><p>学会使用搜索引擎搜索关键字以找到自己需要的学习资料<br>从别人的博客文章/官方文档中学习<br>书籍和视频中学到的大多是系统全面的知识，但是相应的效率便低了<br>针对性学习和系统性学习，需要每个人结合自身情况进行均衡</p></blockquote><p><code>cnss{flag_is_just_like_this}</code></p><h2 id="Web-02-baby-卖菜刀"><a href="#Web-02-baby-卖菜刀" class="headerlink" title="Web_02_(baby)卖菜刀"></a>Web_02_(baby)卖菜刀</h2><blockquote><p>卖菜刀，卖菜刀，3 元 1 把，10 元 3 把。<br>快让 X5tar 看看你的菜刀锋利不锋利！</p></blockquote><p><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></p><p><strong>PS：被某些杀软报毒属于正常现象，可以放心做题，本题不会对你的电脑产生任何不利影响</strong></p><p><em>hint1：PHP 一句话木马</em><br><em>hint2：也许黑色蒙蔽了你的双眼（</em></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>F12审查元素之后，发现网页源码中有这样一句<br><code>?php @eval($_POST[&#39;x5tar&#39;]);</code><br>显然是一个标准格式的一句话木马，而且出题人已经将连接的密码给出来了，即‘’中的内容x5tar<br>于是直接用菜刀连接，笔者采用的是2011版本的中国菜刀<br>链接填写<em><a href="http://recruit.x5tar.com:60003/" target="_blank" rel="noopener">http://recruit.x5tar.com:60003/</a></em>,脚本类型选择PHP，编码标准不做改动，单击“连接”<br>成功连接之后，即可取得控制权限，在网页源码文件夹下找到一名为flag的文件，打开<br>发现 <code>cnss{The_fl4g_1n_/_is_fak3}</code> 出题人居然留了一手，好气！<br>依据提示，我们返回根目录下，发现真正的flag文件，打开为 <code>cnss{y0ur_ca1da0_1s_aw3s0m3}</code><br>Binggo！我们终于得到了正确的flag!</p><h2 id="Web-03-baby-更简单的计算题"><a href="#Web-03-baby-更简单的计算题" class="headerlink" title="Web_03_(baby)更简单的计算题"></a>Web_03_(baby)更简单的计算题</h2><p>有人说夏令营的计算题太难，怎么可能在一秒内算出🌶么大的数<br>所以招新出了一个更加简单的计算题<br>但是让你算出答案又能怎样<br><strong>你真的可以提交吗？</strong></p><p><a href="http://recruit.x5tar.com:60002/" target="_blank" rel="noopener">http://recruit.x5tar.com:60002/</a></p><p><em>hint1：HTML 属性</em><br><em>hint2：试试 F12？</em></p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>惯例，先观察页面。发现是一个8位数的加法，但是输入框只能填写5位数字！<br>F12检察元素，发现这样一行<br><code>input type=&quot;text&quot; name=&quot;re&quot; maxlength=&quot;5&quot;</code><br>显然，它限制了我们提交答案的位数，直接更改之<br>但是发现，我们更改完成之后，“提交”的选项卡直接灰了，我们再回去看审查元素<br><code>input type=&quot;submit&quot; value=&quot;提交&quot; disabled=&quot;&quot;</code><br>这样一行禁止了我们使用提交按钮。于是将其状态改为abled即可<br>提交正确的计算结果后我们直接在页面上得到返回的flag<br><code>恭喜你，计算正确🎉cnss{no_one_kno3s_htm1_b3tt3r_than_u}</code></p><h2 id="Web-04-easy-最好的语言？"><a href="#Web-04-easy-最好的语言？" class="headerlink" title="Web_04_(easy)最好的语言？"></a>Web_04_(easy)最好的语言？</h2><p>你知道最好的语言是什么吗？<br>没错！当然就是超有趣的 PHP 辣！</p><p><a href="http://recruit.x5tar.com:60004/" target="_blank" rel="noopener">http://recruit.x5tar.com:60004/</a></p><p><em>hint1：PHP 反序列化</em><br><em>hint2：CVE-2016-7124</em><br><em>hint3：protected 和 private 属性的序列化</em></p><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><h2 id="施工中！！！Coming-Soon！！！"><a href="#施工中！！！Coming-Soon！！！" class="headerlink" title="施工中！！！Coming Soon！！！"></a><strong>施工中！！！Coming Soon！！！</strong></h2><h1 id="Reverse方向"><a href="#Reverse方向" class="headerlink" title="Reverse方向"></a>Reverse方向</h1><h2 id="Reverse-01-Baby-C-Code"><a href="#Reverse-01-Baby-C-Code" class="headerlink" title="Reverse_01_Baby C Code"></a>Reverse_01_Baby C Code</h2><p>题目要求<br>请运行并分析以下C++语言代码，找到满足条件的 flag</p><p>前置知识<br>1.流程控制<br>2.位运算</p><blockquote><p>#include <cstdio><br>#include <cstring><br>char flag[31];<br>char code[]={x8<br>0x9c,0x91,0x8c,0x8c,0x84,0x88,0xcc,0x93,0x9c,0xcf,<br>0x92,0x9a,0xa0,0xc8,0x90,0xa0,0x8d,0xcc,0x89,0xcc,<br>0x8d,0xca,0x9a,0xa0,0x88,0xcf,0x8d,0xce,0x9b,0x82};<br>int main()<br>{<br>    scanf(“%30s”,flag);<br>    if (strlen(flag)!=30) return 0;<br>    for (int i=0;i&lt;30;i++) if (~flag[i]!=code[i]) return 0;<br>    printf(“Congratulation.”);<br>    return 0;<br>}</cstring></cstdio></p></blockquote><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>简单的查看一下代码，发现验证逻辑非常简单<br>总体而言就是一种很常见的凯撒密码的变体，其中位移量i的取值范围从0到30<br>结合CNSS做题须知里面的flag格式，再观察到code数组之中第3,4位相同，我们不难推出：<br>0x8c对应的时flag中的‘s’ 由于0x8c对应DEC的140，而‘s’的ASCII码值为115，满足i取值范围<br>因此我们编写解码程序，确定偏移量为-25，之后以字符形式输出即可<br>得到flag——<code>cnss{w3lc0me_7o_r3v3r5e_w0r1d}</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> CNSS </tag>
            
            <tag> CTF </tag>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第七次作业解析-查找</title>
      <link href="/post/420a3e9e.html"/>
      <url>/post/420a3e9e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>哈希表创建<br>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>    HASH_OK,<br>    HASH_ERROR,<br>    HASH_ADDED,<br>    HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>    HASH_DELETED,<br>    HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 创建大小为hash_size的哈希表，创建成功后返回HashTable类型的指针，否则返回NULL。<br>HashTable *create_hash(int hash_size);</p><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 create_hash 函数，创建指定大小的哈希表。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:08:46</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">HashTable* create_hash(int size)</span><br><span class="line">&#123;</span><br><span class="line">    HashTable* H &#x3D; (HashTable*)malloc(sizeof(HashTable));</span><br><span class="line">    H-&gt;bucket &#x3D; (HashEntry**)malloc(sizeof(HashEntry**) * size);</span><br><span class="line">    if (!H-&gt;bucket) &#123;</span><br><span class="line">        free(H);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(H, 0, sizeof(HashTable));</span><br><span class="line">    H-&gt;size &#x3D; size;</span><br><span class="line">    return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>哈希表添加</p><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。哈希表相关定义如下：</p><blockquote><p>typedef enum{<br>   HASH_OK,<br>   HASH_ERROR,<br>   HASH_ADDED,<br>   HASH_REPLACED_VALUE,<br>   HASH_ALREADY_ADDED,<br>   HASH_DELETED,<br>   HASH_NOT_FOUND,<br>} HASH_RESULT;</p><p>typedef struct __HashEntry HashEntry;<br>struct __HashEntry{<br>    union{<br>        char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>    } key;<br>    union{<br>       char  *str_value;<br>        double dbl_value;<br>        int       int_value;<br>        long   long_value;<br>        void  *ptr_value;<br>    } value;<br>    HashEntry *next;<br>};</p><p>struct __HashTable{<br>    HashEntry **bucket;<br>    int size;<br>    HASH_RESULT last_error;<br>};<br>typedef struct __HashTable HashTable;</p><p>// 向哈希表中添加元素，其中键类型为char*， 元素类型为int。<br>HASH_RESULT hash_add_int(HashTable * table, const char * key, int value);</p></blockquote><p>哈希表相关说明：</p><blockquote><p>HASH_RESULT 类型为相关函数的返回类型<br>HashEntry 为哈希表所保存元素（即键值对 《key, value》）类型<br>HashTable 为哈希表，其中 bucket 指向大小为size的、元素类型为 HashEntry*的指针数组<br>哈希表采用链地址法处理冲突</p></blockquote><p>请实现 hash_add_int 函数，向哈希表中添加元素，其中键类型为char*， 元素类型为int。在添加过程中，如果要添加的键值key已在哈希表中，且对应的值value也已存在，则函数返回 HASH_ALREADY_ADDED；如果要添加的键值key已在哈希表中，但对应的值value不同，则函数将value值更新到哈希表中，之后返回 HASH_REPLACED_VALUE；如果要添加的键值key不在哈希表中，则函数创建 HashEntry 类型，并将其加入到哈希表中，且函数返回 HASH_ADDED。本题所用的哈希函数如下：</p><blockquote><p>long hash_string(const char <em>str)<br>{<br>    long hash = 5381;<br>    int c;<br>    while (c = *str++)<br>        hash = ((hash &lt;&lt; 5) + hash) + c; /</em> hash * 33 + c */<br>    if(hash &lt; 0)<br>        hash *= -1;<br>    return hash;<br>}</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:10:56</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;hash.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int Find(HashTable* table, const char* key, int value, long keyhash)</span><br><span class="line">&#123;</span><br><span class="line">    HashEntry* Head &#x3D; table-&gt;bucket[keyhash];</span><br><span class="line"></span><br><span class="line">    while (Head &amp;&amp; strcmp(Head-&gt;key.str_value, key)) &#123;</span><br><span class="line">        Head &#x3D; Head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!Head)</span><br><span class="line">        return -1;</span><br><span class="line">    else if (Head-&gt;value.int_value &#x3D;&#x3D; value)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        Head-&gt;value.int_value &#x3D; value;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HASH_RESULT hash_add_int(HashTable* table, const char* key, int value)</span><br><span class="line">&#123;</span><br><span class="line">    int p;</span><br><span class="line">    long keyhash &#x3D; hash_string(key) % table-&gt;size;</span><br><span class="line">    p &#x3D; Find(table, key, value, keyhash);</span><br><span class="line"></span><br><span class="line">    if (p &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        HashEntry* Node &#x3D; (HashEntry*)malloc(sizeof(HashEntry));</span><br><span class="line">        if (!Node)</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)malloc(100);</span><br><span class="line">        if (Node-&gt;key.str_value &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return HASH_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;key.str_value &#x3D; (char*)key;</span><br><span class="line">        Node-&gt;value.int_value &#x3D; value;</span><br><span class="line">        &#x2F;&#x2F;Node-&gt;next &#x3D; table-&gt;bucket[keyhash]; &#x2F;&#x2F;？</span><br><span class="line">        table-&gt;bucket[keyhash] &#x3D; Node;</span><br><span class="line">        return HASH_ADDED;</span><br><span class="line">    &#125; else if (p &#x3D;&#x3D; 0)</span><br><span class="line">        return HASH_REPLACED_VALUE;</span><br><span class="line">    else</span><br><span class="line">        return HASH_ALREADY_ADDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>AVL添加</p><p>平衡二叉树，是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。现二叉平衡树结点定义如下：</p><blockquote><p>typedef struct node<br>{<br>    int val;<br>    struct node *left;<br>    struct node *right;<br>    struct node *parent;<br>    int height;<br>} node_t;</p></blockquote><p>请实现平衡二叉树的插入算法：</p><blockquote><p>//向根为 root 的平衡二叉树插入新元素 val，成功后返回新平衡二叉树根结点<br>node_t *avl_insert(node_t *root, int val);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-22, Mon, 02:12:15</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;avl.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">node_t* Insert(node_t* T, int X);</span><br><span class="line">int GetHeight(node_t* T);</span><br><span class="line">int Max(int a, int b);</span><br><span class="line">node_t* SingleLeftRotation(node_t* A);</span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A);</span><br><span class="line">node_t* SingleRightRotation(node_t* A);</span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A);</span><br><span class="line"></span><br><span class="line">int Max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetHeight(node_t* T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T)</span><br><span class="line">        return T-&gt;height;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;left;</span><br><span class="line">    A-&gt;left &#x3D; B-&gt;right;</span><br><span class="line">    B-&gt;right &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleLeftRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;left &#x3D; SingleRightRotation(A-&gt;left);</span><br><span class="line">    return SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* SingleRightRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* B;</span><br><span class="line">    B &#x3D; A-&gt;right;</span><br><span class="line">    A-&gt;right &#x3D; B-&gt;left;</span><br><span class="line">    B-&gt;left &#x3D; A;</span><br><span class="line">    A-&gt;height &#x3D; Max(GetHeight(A-&gt;left), GetHeight(A-&gt;right)) + 1;</span><br><span class="line">    B-&gt;height &#x3D; Max(GetHeight(B-&gt;left), GetHeight(B-&gt;right)) + 1;</span><br><span class="line">    return B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* DoubleRightLeftRotation(node_t* A)</span><br><span class="line">&#123;</span><br><span class="line">    A-&gt;right &#x3D; SingleLeftRotation(A-&gt;right);</span><br><span class="line">    return SingleRightRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node_t* avl_insert(node_t* root, int val)</span><br><span class="line">&#123;</span><br><span class="line">    node_t* parentNode &#x3D; NULL;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        root &#x3D; (node_t*)malloc(sizeof(node_t));</span><br><span class="line">        root-&gt;left &#x3D; root-&gt;right &#x3D; root-&gt;parent &#x3D; NULL;</span><br><span class="line">        root-&gt;val &#x3D; val;</span><br><span class="line">        root-&gt;height &#x3D; 1;</span><br><span class="line">    &#125; else if (val &lt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;left &#x3D; avl_insert(root-&gt;left, val);</span><br><span class="line">        if (GetHeight(root-&gt;left) - GetHeight(root-&gt;right) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &lt; root-&gt;left-&gt;val)</span><br><span class="line">                root &#x3D; SingleLeftRotation(root);</span><br><span class="line">            else &#123;</span><br><span class="line">                root &#x3D; DoubleLeftRightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (val &gt; root-&gt;val) &#123;</span><br><span class="line">        parentNode &#x3D; root-&gt;left;</span><br><span class="line">        root-&gt;right &#x3D; avl_insert(root-&gt;right, val);</span><br><span class="line">        if (GetHeight(root-&gt;right) - GetHeight(root-&gt;left) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (val &gt; root-&gt;right-&gt;val)</span><br><span class="line">                root &#x3D; SingleRightRotation(root);</span><br><span class="line">            else</span><br><span class="line">                root &#x3D; DoubleRightLeftRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;parent &#x3D; parentNode;</span><br><span class="line">    root-&gt;height &#x3D; Max(GetHeight(root-&gt;left), GetHeight(root-&gt;right)) + 1;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 查找 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第六次作业解析-图的储存</title>
      <link href="/post/2a6df9f7.html"/>
      <url>/post/2a6df9f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>邻接矩阵<br>试在邻接矩阵存储结构上实现图的基本操作 matrix_insert_vertex 和matrix_insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct{<br>    VertexType vertex[MAX_VERTEX_NUM]; //顶点向量<br>    int arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; //邻接矩阵<br>    int vexnum, arcnum;   //图的当前顶点数和弧数<br>    GraphType type;     //图的种类标志<br>}MatrixGraph;</p><p>int matrix_locate_vertex(MatrixGraph MG, VertexType vex); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool matrix_insert_vertex(MatrixGraph G, VertexType v);<br>bool matrix_insert_arc(MatrixGraph *G, VertexType v, VertexType w);</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-10, Wed, 13:06:59</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_vertex(MatrixGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix_locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum] &#x3D; v;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">        G-&gt;arcs[i][G-&gt;vexnum - 1] &#x3D; G-&gt;arcs[G-&gt;vexnum - 1][i] &#x3D; 0;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool matrix_insert_arc(MatrixGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; matrix_locate_vertex(G, v), j &#x3D; matrix_locate_vertex(G, w);</span><br><span class="line">    if (i &#x3D;&#x3D; -1 || j &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    else if (G-&gt;arcs[i][j] &#x3D;&#x3D; 1)</span><br><span class="line">        return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        G-&gt;arcs[i][j] &#x3D; 1;</span><br><span class="line">        G-&gt;arcs[j][i] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;arcnum +&#x3D; 1;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>邻接表1<br>试在邻接表存储结构上实现图的基本操作 insert_vertex 和 insert_arc，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode<br>{<br>    int adjvex;<br>    InfoPtr *info;<br>    struct ArcNode *nextarc;</p><p>}ArcNode;</p><p>typedef struct VNode<br>{<br>    VertexType data;<br>    ArcNode *firstarc;<br>}VNode;<br>typedef struct<br>{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph* G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool insert_vertex(ListGraph <em>G, VertexType v);<br>bool insert_arc(ListGraph *G, VertexType v, VertexType w);<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>当成功插入顶点或边时，函数返回true，否则（如顶点或边已存在、插入边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-12, Thu, 16:07:33</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool insert_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) !&#x3D; -1 || G-&gt;vexnum + 1 &gt;&#x3D; MAX_VERTEX_NUM)</span><br><span class="line">        return false;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].data &#x3D; v;</span><br><span class="line">    G-&gt;vertex[G-&gt;vexnum].firstarc &#x3D; NULL;</span><br><span class="line">    G-&gt;vexnum++;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool insert_arc(ListGraph* G, VertexType v, VertexType w)</span><br><span class="line">&#123;</span><br><span class="line">    if (locate_vertex(G, v) &#x3D;&#x3D; -1 || locate_vertex(G, w) &#x3D;&#x3D; -1)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>邻接表2<br>试在邻接表存储结构上实现图的基本操作 del_vertex，相关定义如下：</p><blockquote><p>typedef int VertexType;</p><p>typedef enum{<br>    DG, UDG<br>}GraphType;</p><p>typedef struct ArcNode{<br>    int adjvex;<br>    InfoPtr info;<br>    struct ArcNode nextarc;<br>}ArcNode;</p><p>typedef struct VNode{<br>    VertexType data;<br>    ArcNode firstarc;<br>}VNode;<br>typedef struct{<br>    VNode vertex[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;<br>    GraphType type;<br>}ListGraph;</p><p>int locate_vertex(ListGraph *G, VertexType v); //返回顶点 v 在vertex数组中的下标，如果v不存在，返回-1<br>bool del_vertex(ListGraph *G, VertexType v); //删除顶点 v</p></blockquote><p>当成功删除顶点或边时，函数返回true，否则（如顶点或边不存在、删除边时顶点v或w不存在）返回false。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-06-13, Sat, 11:09:26</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;graph.h&quot; &#x2F;&#x2F;请勿删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">bool del_vertex(ListGraph* G, VertexType v)</span><br><span class="line">&#123;</span><br><span class="line">    int t &#x3D; locate_vertex(G, v), i;</span><br><span class="line">    if (t &lt; 0)</span><br><span class="line">        return false;</span><br><span class="line">    ArcNode *q, *p;</span><br><span class="line">    p &#x3D; G-&gt;vertex[t].firstarc;</span><br><span class="line">    while (p) &#123;</span><br><span class="line">        q &#x3D; p;</span><br><span class="line">        p &#x3D; p-&gt;nextarc;</span><br><span class="line">        free(q);</span><br><span class="line">        G-&gt;arcnum--;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vertex[t].firstarc &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        p &#x3D; G-&gt;vertex[i].firstarc;</span><br><span class="line">        while (p &amp;&amp; p-&gt;adjvex !&#x3D; t) &#123;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">        if (p &amp;&amp; p-&gt;adjvex &#x3D;&#x3D; t) &#123;</span><br><span class="line">            if (p &#x3D;&#x3D; G-&gt;vertex[i].firstarc) &#123;</span><br><span class="line">                G-&gt;vertex[i].firstarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                q-&gt;nextarc &#x3D; p-&gt;nextarc;</span><br><span class="line">                free(p);</span><br><span class="line">            &#125;</span><br><span class="line">            G-&gt;arcnum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; t + 1; i &lt; G-&gt;vexnum; i++) &#123;</span><br><span class="line">        G-&gt;vertex[i - 1] &#x3D; G-&gt;vertex[i];</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;vexnum--;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 图 </tag>
            
            <tag> 储存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第五次作业解析-树二叉树</title>
      <link href="/post/baa44d8a.html"/>
      <url>/post/baa44d8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>先序遍历<br>已知二叉树按照二叉链表方式存储，利用栈的基本操作写出先序遍历非递归形式的算法：</p><blockquote><p>void pre_order(BiTree root);</p></blockquote><p>在遍历过程中，pre_order函数需要调用 visit_node 函数来实现对结点的访问，该函数声明如下：</p><blockquote><p>void visit_node(BiTNode *node);</p></blockquote><p>二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>遍历所使用栈的相关操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:50:25</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void pre_order(BiTree root)</span><br><span class="line">&#123;</span><br><span class="line">    BiTNode* p;</span><br><span class="line">    Stack s;</span><br><span class="line">    p &#x3D; root;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    while (p || !is_empty(&amp;s)) &#123;</span><br><span class="line">        if (p !&#x3D; NULL) &#123;</span><br><span class="line">            visit_node(p);</span><br><span class="line">            push(&amp;s, p);</span><br><span class="line">            p &#x3D; p-&gt;left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pop(&amp;s, &amp;p);</span><br><span class="line">            p &#x3D; p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>路径<br>假设二叉树采用二叉链表方式存储， root指向根结点，node 指向二叉树中的一个结点，编写函数 path，计算root到 node 之间的路径，（该路径包括root结点和 node 结点）。path 函数声明如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p></blockquote><p>其中，root指向二叉树的根结点，node指向二叉树中的另一结点，s 为已经初始化好的栈，该栈用来保存函数所计算的路径，如正确找出路径，则函数返回 true，此时root在栈底，node在栈顶；如未找到，则函数返回 false, 二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>栈的相关定义及操作如下：</p><blockquote><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><p>在提示中，树用缩进的形式展示，如二叉树【pic】，其缩进形式为：【pic】</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 18:00:41</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool path(BiTNode* root, BiTNode* node, Stack* s)</span><br><span class="line">&#123;</span><br><span class="line">    BiTree Tr &#x3D; root, p &#x3D; NULL;</span><br><span class="line">    if (Tr &#x3D;&#x3D; NULL || node &#x3D;&#x3D; NULL || !is_empty(s))</span><br><span class="line">        return false;</span><br><span class="line">    while (Tr || !is_empty(s)) &#123;</span><br><span class="line">        while (Tr) &#123;</span><br><span class="line">            push(s, Tr);</span><br><span class="line">            if (Tr &#x3D;&#x3D; node)</span><br><span class="line">                return true;</span><br><span class="line">            Tr &#x3D; Tr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        top(s, &amp;Tr);</span><br><span class="line">        if (!Tr-&gt;right || Tr-&gt;right &#x3D;&#x3D; p) &#123;</span><br><span class="line">            p &#x3D; Tr;</span><br><span class="line">            pop(s, &amp;Tr);</span><br><span class="line">            Tr &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            Tr &#x3D; Tr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>共同祖先<br>假设二叉树采用二叉链表方式存储， root指向根结点，p所指结点和q所指结点为二叉树中的两个结点，编写一个计算它们的最近的共同祖先，函数定义如下：</p><blockquote><p>BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q);</p></blockquote><p>其中 root 指向二叉树的根结点，p 和 q 分别指向二叉树中的两个结点。<br>提示：在完成本题时，可利用 path 函数获取p和q两个结点到根结点之间的路径，之后再计算两条公共路径得出最近的共同祖先。path函数及栈相关定义如下：</p><blockquote><p>bool path(BiTNode* root, BiTNode* node, Stack* s);</p><p>#define Stack_Size 50<br>typedef BiTNode* ElemType;<br>typedef struct{<br>    ElemType elem[Stack_Size];<br>    int top;<br>}Stack;</p><p>void init_stack(Stack <em>S); // 初始化栈<br>bool push(Stack</em> S, ElemType x); //x 入栈<br>bool pop(Stack* S, ElemType <em>px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 false<br>bool top(Stack</em> S, ElemType <em>px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 false<br>bool is_empty(Stack</em> S);  // 栈为空时返回 true，否则返回 false</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:54:08</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* nearest_ancestor(BiTree root, BiTNode* p, BiTNode* q)</span><br><span class="line">&#123;</span><br><span class="line">    Stack *pl, *ql;</span><br><span class="line">    pl &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    ql &#x3D; malloc(sizeof(Stack));</span><br><span class="line">    init_stack(pl);</span><br><span class="line">    init_stack(ql);</span><br><span class="line">    if (path(root, p, pl) &#x3D;&#x3D; false || path(root, q, ql) &#x3D;&#x3D; false)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    ElemType temp;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; pl-&gt;top &amp;&amp; i &lt; ql-&gt;top; i++) &#123;</span><br><span class="line">        if (pl-&gt;elem[i] !&#x3D; ql-&gt;elem[i])</span><br><span class="line">            break;</span><br><span class="line">        else</span><br><span class="line">            temp &#x3D; pl-&gt;elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>树转二叉树<br>使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下：</p><blockquote><p>typedef int DataType;</p><p>typedef struct Node{<br>    DataType data;<br>    struct Node* left;<br>    struct Node* right;<br>}BiTNode, *BiTree;</p></blockquote><p>普通树节点的定义如下：</p><blockquote><p>#define MAX_CHILDREN_NUM 5<br>struct _CSNode<br>{<br>    DataType data;<br>    struct _CSNode *children[MAX_CHILDREN_NUM];<br>};<br>typedef struct _CSNode CSNode;</p></blockquote><p>其中，子树的根节点的指针存放在children数组的前k个元素中，即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，子树根结点分别保存在children[0]至children[i-1]中。<br>队列相关定义及操作如下：</p><blockquote><p>struct __Queue<br>{<br>    int i, j; //指向数组内元素的游标<br>    void **array;<br>};<br>typedef struct __Queue Queue;</p><p>Queue* create_queue(); //创建队列<br>bool is_empty_queue(Queue <em>tree); //队为空返回true,不为空时返回false<br>void</em> del_queue(Queue *tree); //结点指针出队<br>void add_queue(Queue *tree, void *node); //结点指针入队<br>void free_queue(Queue *tree); //释放队列</p></blockquote><p>transform函数定义如下：</p><blockquote><p>BiTNode* transform(CSNode *root);</p></blockquote><p>其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-05-10, Sun, 17:57:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;bitree.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">BiTNode* transform(CSNode* root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    BiTree broot &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">    broot-&gt;data &#x3D; root-&gt;data;</span><br><span class="line">    broot-&gt;left &#x3D; broot-&gt;right &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    Queue* queue &#x3D; create_queue();</span><br><span class="line">    Queue* bqueue &#x3D; create_queue();</span><br><span class="line">    add_queue(queue, root);</span><br><span class="line">    add_queue(bqueue, broot);</span><br><span class="line">    while (!is_empty_queue(queue)) &#123;</span><br><span class="line">        CSNode* node &#x3D; del_queue(queue);</span><br><span class="line">        BiTree bTreeNode &#x3D; del_queue(bqueue);</span><br><span class="line">        int i;</span><br><span class="line">        BiTree former &#x3D; NULL;</span><br><span class="line">        for (i &#x3D; 0; i &lt; MAX_CHILDREN_NUM; i++) &#123;</span><br><span class="line">            if (node-&gt;children[i]) &#123;</span><br><span class="line">                BiTree bnode &#x3D; (BiTree)malloc(sizeof(struct Node));</span><br><span class="line">                bnode-&gt;left &#x3D; bnode-&gt;right &#x3D; NULL;</span><br><span class="line">                bnode-&gt;data &#x3D; node-&gt;children[i]-&gt;data;</span><br><span class="line">                if (i &#x3D;&#x3D; 0)</span><br><span class="line">                    bTreeNode-&gt;left &#x3D; bnode;</span><br><span class="line">                else</span><br><span class="line">                    former-&gt;right &#x3D; bnode;</span><br><span class="line">                former &#x3D; bnode;</span><br><span class="line"></span><br><span class="line">                add_queue(queue, node-&gt;children[i]);</span><br><span class="line">                add_queue(bqueue, bnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(queue-&gt;array);</span><br><span class="line">    free(queue);</span><br><span class="line">    free(bqueue-&gt;array);</span><br><span class="line">    free(bqueue);</span><br><span class="line">    return broot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第四次作业解析-块链串/数组</title>
      <link href="/post/716e4956.html"/>
      <url>/post/716e4956.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>块链串</li></ol><p>块链串定义如下：</p><blockquote><p>#define BLOCK_SIZE 4    // 可由用户定义的块大小<br>#define BLS_BLANK ‘#’   // 用于空白处的补齐字符</p><p>typedef struct _block {<br>    char ch[BLOCK_SIZE];    //块的数据域<br>    struct _block *next;    //块的指针域<br>} Block;</p><p>typedef struct {<br>    Block *head;        // 串的头指针<br>    Block *tail;        // 串的尾指针<br>    int len;            // 串的当前长度<br>} BLString;</p><p>//字符串初始化函数：<br>void blstr_init(BLString *T) {<br>    T-&gt;len = 0;<br>    T-&gt;head = NULL;<br>    T-&gt;tail = NULL;<br>}</p></blockquote><p>这些定义已包含在头文件 dsstring.h 中，请实现块链串的子串查找操作：</p><blockquote><p>bool blstr_substr(BLString src, int pos, int len, BLString *sub);<br>src为要查找的字符串<br>pos为子串开始的下标<br>len为子串的长度<br>sub在函数调用运行前指向一个已经初始化好的空串，在函数返回时，sub指向串src从第pos个字符起长度为len的子串<br>函数查找成功返回true，参数不正确返回 false </p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:05:30</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool blstr_substr(BLString src, int pos, int len, BLString* sub)</span><br><span class="line">&#123;</span><br><span class="line">    if (pos &lt; 0 || pos &gt;&#x3D; src.len || len &lt; 1)</span><br><span class="line">        return false;</span><br><span class="line">    Block *p &#x3D; (sub-&gt;head &#x3D; (Block*)malloc(sizeof(Block))), *q &#x3D; src.head;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    p-&gt;next &#x3D; NULL;</span><br><span class="line">    while (k &lt;&#x3D; pos + len - 1 &amp;&amp; q &amp;&amp; q-&gt;ch[i] !&#x3D; BLS_BLANK) &#123;</span><br><span class="line">        if (k &lt; pos) &#123;</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p-&gt;ch[j] &#x3D; q-&gt;ch[i];</span><br><span class="line">            if (i &lt; BLOCK_SIZE - 1)</span><br><span class="line">                i++;</span><br><span class="line">            else &#123;</span><br><span class="line">                q &#x3D; q-&gt;next;</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j &lt; BLOCK_SIZE - 1)</span><br><span class="line">                j++;</span><br><span class="line">            else &#123;</span><br><span class="line">                p-&gt;next &#x3D; (Block*)malloc(sizeof(Block));</span><br><span class="line">                p &#x3D; p-&gt;next;</span><br><span class="line">                p-&gt;next &#x3D; NULL;</span><br><span class="line">                j &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">            sub-&gt;len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j) &#123;</span><br><span class="line">        sub-&gt;tail &#x3D; p;</span><br><span class="line">        while (j &lt; BLOCK_SIZE)</span><br><span class="line">            p-&gt;ch[j++] &#x3D; BLS_BLANK;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (sub-&gt;tail &#x3D; sub-&gt;head; sub-&gt;tail-&gt;next !&#x3D; p; sub-&gt;tail &#x3D; sub-&gt;tail-&gt;next)</span><br><span class="line">            ;</span><br><span class="line">        sub-&gt;tail-&gt;next &#x3D; NULL;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>矩阵加法<br>实现三元组表示的两个稀疏矩阵的加法。相关定义如下：<blockquote><p>#define MAXSIZE 100       //假设非零元个数的最大值为100<br>typedef struct {</p><pre><code>int i,j;   //非零元的行下标和列下标，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致ElemType e;    //非零元的值</code></pre><p>}Triple;</p><p>typedef struct {</p><pre><code>Triple data[MAXSIZE];     // 非零元三元组表int    m, n, len;     // 矩阵的行数、列数和非零元个数</code></pre><p>}TSMatrix;</p></blockquote></li></ol><p>在三元组中，i 和 j 从 1 开始计数，与数学中矩阵元素的编号一致<br>矩阵加法函数的原型为：</p><blockquote><p>bool add_matrix(const TSMatrix *pM, const TSMatrix *pN, TSMatrix *pQ);</p></blockquote><p>pM, pN, pQ 分别指向三个矩阵，当 pM 和 pN 两个矩阵不可加时，函数返回 false，否则函数返回 true，且 pQ 指向两个矩阵的和。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:10:16</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;tsmatrix.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool add_matrix(const TSMatrix* pM, const TSMatrix* pN, TSMatrix* pQ)</span><br><span class="line">&#123;</span><br><span class="line">    TSMatrix *M &#x3D; pM, *N &#x3D; pN, *Q &#x3D; pQ;</span><br><span class="line">    if (M-&gt;m !&#x3D; N-&gt;m || M-&gt;n !&#x3D; N-&gt;n) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    Q-&gt;m &#x3D; M-&gt;m, Q-&gt;n &#x3D; M-&gt;n, Q-&gt;len &#x3D; 0;</span><br><span class="line">    while (i &lt; M-&gt;len &amp;&amp; j &lt; N-&gt;len) &#123;</span><br><span class="line">        if (M-&gt;data[i].i &lt; N-&gt;data[j].i || (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &lt; N-&gt;data[j].j)) &#123;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k].e &#x3D; M-&gt;data[i].e;</span><br><span class="line">            Q-&gt;len++, k++, i++;</span><br><span class="line">        &#125; else if (M-&gt;data[i].i &#x3D;&#x3D; N-&gt;data[j].i &amp;&amp; M-&gt;data[i].j &#x3D;&#x3D; N-&gt;data[j].j) &#123;</span><br><span class="line">            if (M-&gt;data[i].e + N-&gt;data[j].e) &#123;</span><br><span class="line">                Q-&gt;data[k].i &#x3D; M-&gt;data[i].i;</span><br><span class="line">                Q-&gt;data[k].j &#x3D; M-&gt;data[i].j;</span><br><span class="line">                Q-&gt;data[k].e &#x3D; M-&gt;data[i].e + N-&gt;data[j].e;</span><br><span class="line">                k++, Q-&gt;len++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Q-&gt;len++;</span><br><span class="line">            Q-&gt;data[k].i &#x3D; N-&gt;data[i].i;</span><br><span class="line">            Q-&gt;data[k].j &#x3D; N-&gt;data[i].j;</span><br><span class="line">            Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">            k++, j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt; M-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; M-&gt;data[i];</span><br><span class="line">        k++, i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt; N-&gt;len) &#123;</span><br><span class="line">        Q-&gt;len++;</span><br><span class="line">        Q-&gt;data[k] &#x3D; N-&gt;data[j];</span><br><span class="line">        k++, j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>十字链表<br>十字链表相关定义如下：<blockquote><p>typedef int ElemType;</p><p>// 非零元素结点结构<br>typedef struct OLNode<br>{</p><pre><code>int row,col;ElemType value;struct OLNode *right,*down;</code></pre><p>}OLNode,*OLink;</p><p>// 十字链表结构<br>typedef struct<br>{</p><pre><code>OLink *rowhead,*colhead;int rows,cols,nums;</code></pre><p>}CrossList, *PCrossList;</p></blockquote></li></ol><p>1）实现十字链表的初始化操作：</p><blockquote><p>int init_cross_list(PCrossList L, const ElemType *A, int m, int n);</p></blockquote><p>其中 L 指向 CrossList 结构，且各成员已被初始化为0；<br>A 为 ElemType 类型数组中第一个元素的地址，元素的个数为 m×n 个，按行优先存储（即A[0] 为十字链表第1行第1列的元素；<br>A[1] 为第1行第2列的元素，A[n] 为第2行第1列的元素，A[n+1] 为第2行第2个元素）；<br>m 表示十字链表的行数，n 表示十字链表的列数。<br>init_cross_list 函数将 ElemType 数组中非0元素保存到十字链表中，函数返回非 0 元素的个数。</p><p>2）实现十字链表的删除操作：</p><blockquote><p>int del_cross_list(PCrossList L, ElemType k);</p></blockquote><p>其中 L 指向 要处理的 CrossList 结构，k 为要删除的元素；<br>del_cross_list 函数删除十字链表中所有值为 k 的结点，并返回删除结点的个数。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-19, Sun, 16:15:09</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;crosslist.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int init_cross_list(PCrossList L, const ElemType* A, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    OLNode *p, *q;</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">    L-&gt;rows &#x3D; m;</span><br><span class="line">    L-&gt;cols &#x3D; n;</span><br><span class="line">    L-&gt;nums &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    L-&gt;rowhead &#x3D; (OLink*)malloc((m + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">        L-&gt;rowhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;colhead &#x3D; (OLink*)malloc((n + 1) * sizeof(OLNode));</span><br><span class="line">    for (j &#x3D; 0; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">        L-&gt;colhead[j] &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for (k &#x3D; 1; k &lt;&#x3D; m * n; ++k) &#123;</span><br><span class="line">        if (A[k - 1] !&#x3D; 0) &#123;</span><br><span class="line">            p &#x3D; (OLink)malloc(sizeof(OLNode));</span><br><span class="line">            p-&gt;row &#x3D; ((k - 1) &#x2F; n);</span><br><span class="line">            p-&gt;col &#x3D; k - (p-&gt;row * n) - 1;</span><br><span class="line">            p-&gt;value &#x3D; A[k - 1];</span><br><span class="line">            p-&gt;right &#x3D; NULL;</span><br><span class="line">            p-&gt;down &#x3D; NULL;</span><br><span class="line">            L-&gt;nums++;</span><br><span class="line">            i &#x3D; p-&gt;row;</span><br><span class="line">            if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;rowhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;rowhead[i]; q-&gt;right &amp;&amp; q-&gt;right-&gt;col &lt; p-&gt;col; q &#x3D; q-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;right &#x3D; q-&gt;right;</span><br><span class="line">                q-&gt;right &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            i &#x3D; p-&gt;col;</span><br><span class="line">            if (L-&gt;colhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                L-&gt;colhead[i] &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (q &#x3D; L-&gt;colhead[i]; q-&gt;down &amp;&amp; q-&gt;down-&gt;row &lt; p-&gt;row; q &#x3D; q-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                p-&gt;down &#x3D; q-&gt;down;</span><br><span class="line">                q-&gt;down &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return L-&gt;nums;</span><br><span class="line">&#125;</span><br><span class="line">int del_cross_list(PCrossList L, ElemType k)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0, t &#x3D; 0;</span><br><span class="line">    OLink temp;</span><br><span class="line">    OLink p &#x3D; NULL;</span><br><span class="line">    OLink templeft &#x3D; NULL;</span><br><span class="line">    OLink tempup &#x3D; NULL;</span><br><span class="line">    for (i &#x3D; 0; i &lt; L-&gt;rows; i++) &#123;</span><br><span class="line">        if (L-&gt;rowhead[i] &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (p &#x3D; L-&gt;rowhead[i], temp &#x3D; p-&gt;right; p !&#x3D; NULL; p &#x3D; temp) &#123;</span><br><span class="line">            temp &#x3D; p-&gt;right;</span><br><span class="line">            if (p-&gt;value &#x3D;&#x3D; k) &#123;</span><br><span class="line">                for (templeft &#x3D; L-&gt;rowhead[i]; templeft-&gt;right &amp;&amp; templeft-&gt;right-&gt;col &lt; p-&gt;col; templeft &#x3D; templeft-&gt;right)</span><br><span class="line">                    ;</span><br><span class="line">                for (tempup &#x3D; L-&gt;colhead[p-&gt;col]; tempup-&gt;down !&#x3D; NULL &amp;&amp; tempup-&gt;down-&gt;row &lt; p-&gt;row; tempup &#x3D; tempup-&gt;down)</span><br><span class="line">                    ;</span><br><span class="line">                if (templeft &#x3D;&#x3D; p) &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        L-&gt;rowhead[i] &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (tempup &#x3D;&#x3D; p) &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        L-&gt;colhead[p-&gt;col] &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        templeft-&gt;right &#x3D; p-&gt;right;</span><br><span class="line">                        tempup-&gt;down &#x3D; p-&gt;down;</span><br><span class="line">                        free(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t++;</span><br><span class="line">                L-&gt;nums--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 块链串 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第三次作业解析-字符串</title>
      <link href="/post/46728.html"/>
      <url>/post/46728.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>串比较<br>不调用库函数，自己实现字符串的比较操作：<code>该操作当比较的两个字符是都是字母，且两个字符互为大小写（如a和A、e和E）时认为两个字符相同，否则不同，其比较结果按这两个字符的原值确定。</code>函数的返回值规定如下：<br>返回值 &lt; 0：第一个不匹配的字符在 ptr1 中的值低于 ptr2 中的值<br>返回值 == 0：两个字符串的内容相等<br>返回值 &gt; 0：第一个不匹配的字符在 ptr1 中的值大于在 ptr2 中的值</li></ol><p>函数原型如下： </p><blockquote><p>int str_compare(const char* ptr1, const char* ptr2);</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-31, Tue, 22:26:53</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot; &#x2F;&#x2F;请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_compare(const char* ptr1, const char* ptr2)</span><br><span class="line">&#123;</span><br><span class="line">    char* p1 &#x3D; ptr1;</span><br><span class="line">    char* p2 &#x3D; ptr2;</span><br><span class="line">    int flag &#x3D; 0;</span><br><span class="line">    while (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">        if (*p1 &#x3D;&#x3D; *p2 || *p1 &#x3D;&#x3D; *p2 - 32 || *p2 &#x3D;&#x3D; *p1 - 32) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        &#125; else if (*p1 &lt; *p2) &#123;</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (*p1 &gt; *p2) &#123;</span><br><span class="line">            flag &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p1 !&#x3D; &#39;\0&#39; &amp;&amp; *p2 &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; 1;</span><br><span class="line">    else if (*p1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *p2 !&#x3D; &#39;\0&#39;)</span><br><span class="line">        flag &#x3D; -1;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>串替换<br>不调用库函数，自己实现字符串替换操作，函数原型为：<blockquote><p>int str_replace(const char *in, char *out, int outlen, const char *oldstr, const char *newstr);</p></blockquote></li></ol><p>参数说明:<br>    in， 原始字符串，保持不变<br>    out, 存放替换结果的字符串<br>    outlen，out空间的大小<br>    oldstr，要替换的旧字符串<br>    newstr，替换成的新字符串<br>函数返回成功替换的次数，即有多少个子串被成功替换</p><p>在替换过程中，任何情况下所得字符串（及结束符）不应该超过 outlen，如果某次替换所得字符串的长度超过 outlen，则不进行这次替换操作，整个替换操作结束。如：<br>原始串为 “aaabbbccc”，outlen 为14, oldstr 为 “c”，newstr 为 “333” 时，两次替换后得 “aaabbb333333c”，此时字符串占用空间为14字节。<br>如果再进行替换，则会超出 out 所占用的空间，所以停止替换操作。此时函数应该返回 2, out指向的串为 “aaabbb333333c”<br>再如：原始串为 “aaabbbccc”，outlen 为10, oldstr 为 “bb”，newstr 为 “123456”，进行替换后所得的串应该为 “aaa123456” （长度为9）与结束符一共占 10 个字节，此时函数应该返回 1。</p><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-04-07, Tue, 19:43:54</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;dsstring.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int str_replace(const char* in, char* out, int outlen, const char* oldstr, const char* newstr)</span><br><span class="line">&#123;</span><br><span class="line">    char a &#x3D; &quot;aaabbbccc&quot;;</span><br><span class="line">    char b &#x3D; &quot;c&quot;, c &#x3D; &quot;cc&quot;, d &#x3D; &quot;123&quot;, e &#x3D; &quot;123456&quot;, f &#x3D; &quot;12345678&quot;;</span><br><span class="line"></span><br><span class="line">    char *cur1 &#x3D; in, *cur2 &#x3D; out;</span><br><span class="line">    int len &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    while (*out !&#x3D; 0)</span><br><span class="line">        *out &#x3D; 0, out++;</span><br><span class="line">    while (len &lt; outlen &amp;&amp; *cur1) &#123;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        char *p1 &#x3D; cur1, *p2 &#x3D; oldstr;</span><br><span class="line">        while (*p1 &amp;&amp; *p2 &amp;&amp; *p1 &#x3D;&#x3D; *p2)</span><br><span class="line">            p1++, p2++;</span><br><span class="line">        if (*p2 !&#x3D; 0)</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            char* p &#x3D; newstr;</span><br><span class="line">            int len1 &#x3D; len;</span><br><span class="line">            while (*p)</span><br><span class="line">                len1++, *p++;</span><br><span class="line">            if (len1 &gt; outlen) &#123;</span><br><span class="line">                while (*cur1 &amp;&amp; len &lt; outlen + 1)</span><br><span class="line">                    *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">                return ans;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 &#x3D; p1;</span><br><span class="line">            ans++;</span><br><span class="line">            p &#x3D; newstr;</span><br><span class="line">            while (*p)</span><br><span class="line">                *cur2 &#x3D; *p, cur2++, p++, len++;</span><br><span class="line">        &#125; else</span><br><span class="line">            *cur2 &#x3D; *cur1, len++, cur1++, cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>警告！本代码可能无法完成所有情况的操作<br>当然你如果也是欧皇的话可以无视（因为judge平台测试数据的随机性）<br>正在开发一段满足所有条件的代码<br>Hints：自己实现几个关键的string操作函数即可，比如strlen等等</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第二次作业解析-队列栈</title>
      <link href="/post/4641.html"/>
      <url>/post/4641.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li>队列 循环列表表示栈<br>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），请完成下列任务：<br>1: 队列初始化，成功返回真，否则返回假  <blockquote><p>bool init_queue(LinkQueue <em>LQ);<br>2: 入队列，成功返回真，否则返回假：<br>bool enter_queue(LinkQueue *LQ, ElemType x);<br>3: 出队列，成功返回真，且</em>x为出队的值，否则返回假<br>bool leave_queue(LinkQueue *LQ, ElemType *x);</p></blockquote></li></ol><p>相关定义如下：</p><blockquote><p>typedef struct _QueueNode {<br>    ElemType data;          /<em>数据域</em>/<br>    struct _QueueNode <em>next;      /*指针域</em>/<br>}LinkQueueNode, *LinkQueue;</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-26, Thu, 10:34:14</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">bool init_queue(LinkQueue* LQ)</span><br><span class="line">&#123;</span><br><span class="line">    *LQ &#x3D; (LinkQueue)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    (*LQ)-&gt;next &#x3D; *LQ;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool enter_queue(LinkQueue* LQ, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if (*LQ &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueueNode* p &#x3D; (LinkQueueNode*)malloc(sizeof(LinkQueueNode));</span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p-&gt;data &#x3D; x;</span><br><span class="line">        p-&gt;next &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        (*LQ)-&gt;next &#x3D; p;</span><br><span class="line">        *LQ &#x3D; p;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool leave_queue(LinkQueue* LQ, ElemType* x)</span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue rear &#x3D; (*LQ);</span><br><span class="line">    if (rear-&gt;next &#x3D;&#x3D; rear)</span><br><span class="line">        return 0;</span><br><span class="line">    (*x) &#x3D; rear-&gt;next-&gt;next-&gt;data;</span><br><span class="line">    if (rear-&gt;next-&gt;next &#x3D;&#x3D; rear) &#123;</span><br><span class="line">        (*LQ) &#x3D; (*LQ)-&gt;next;</span><br><span class="line">        free(rear);</span><br><span class="line">        (*LQ)-&gt;next &#x3D; (*LQ);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueue temp &#x3D; rear-&gt;next-&gt;next;</span><br><span class="line">    rear-&gt;next-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li>栈 后缀表达式计算<br>请使用已定义好的栈完成后缀表达式计算：<br>(1)如果是操作数，直接入栈<br>(2)如果是操作符op，连续出栈两次，得到操作数x 和 y,计算 x op y，并将结果入栈。<br>后缀表达式示例如下：<br>9  3  1  -  3  *  +  10  2  /  +<br>13  445  +  51  /  6  -<br>操作数、操作符之间由空格隔开，操作符有 +，-，*, /, %共 5 种符号，所有操作数都为整型。<br>栈的定义如下：<blockquote><p>#define Stack_Size 50<br>typedef struct{</p><pre><code>ElemType elem[Stack_Size];int top;</code></pre><p>}Stack;</p><p>bool push(Stack* S, ElemType x);<br>bool pop(Stack* S, ElemType *x);<br>void init_stack(Stack *S);</p></blockquote></li></ol><p>其中，栈初始化的实现为：</p><blockquote><p>void init_stack(Stack *S){<br>    S-&gt;top = -1;<br>}</p></blockquote><p>需要完成的函数定义为：</p><blockquote><p>int compute_reverse_polish_notation(char *str);<br>函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。</p></blockquote><ol start="2"><li>解析<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-23, Mon, 19:19:11</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int compute_reverse_polish_notation(char* str)</span><br><span class="line">&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    int num &#x3D; 0;</span><br><span class="line">    while (*str !&#x3D; 0) &#123;</span><br><span class="line">        while (*str &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            str++;</span><br><span class="line">        if (*str &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (*str &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a + b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b - a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, a * b);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b &#x2F; a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else if (*str &#x3D;&#x3D; &#39;%&#39;) &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            pop(&amp;s, &amp;a);</span><br><span class="line">            pop(&amp;s, &amp;b);</span><br><span class="line">            push(&amp;s, b % a);</span><br><span class="line">            str++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int x &#x3D; 0;</span><br><span class="line">            do &#123;</span><br><span class="line">                x &#x3D; x * 10 + *str - &#39;0&#39;;</span><br><span class="line">                str++;</span><br><span class="line">            &#125; while (*str &gt;&#x3D; &#39;0&#39; &amp;&amp; *str &lt;&#x3D; &#39;9&#39; &amp;&amp; *str !&#x3D; 0);</span><br><span class="line">            push(&amp;s, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pop(&amp;s, &amp;num);</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Icoding平台第一次作业解析-线性表</title>
      <link href="/post/3472.html"/>
      <url>/post/3472.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><ol><li><p>顺序表 删除指定范围<br>设计一个高效的算法，从顺序表L中删除所有值介于x和y之间(包括x和y)的所有元素（假设y&gt;=x），要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_x2y(SeqList *L, ElemType x, ElemType y);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:46:50</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_x2y(SeqList* L, ElemType x, ElemType y)</span><br><span class="line">&#123;</span><br><span class="line">    int last &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; L-&gt;last; i++)</span><br><span class="line">        if (L-&gt;elem[i] &lt; x || L-&gt;elem[i] &gt; y)</span><br><span class="line">            L-&gt;elem[++last] &#x3D; L-&gt;elem[i];</span><br><span class="line">    L-&gt;last &#x3D; last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><ol><li><p>顺序表 删除重复<br>编写算法，在一非递减的顺序表L中，删除所有值相等的多余元素。要求时间复杂度为O(n)，空间复杂度为O(1)。<br>函数原型如下：</p><blockquote><p>void del_dupnum(SeqList *L)<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-02, Mon, 11:49:49</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void del_dupnum(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int flag &#x3D; 0, val &#x3D; L-&gt;elem[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; L-&gt;last; i++) &#123;</span><br><span class="line">        if (val !&#x3D; L-&gt;elem[i]) &#123;</span><br><span class="line">            val &#x3D; L-&gt;elem[i];</span><br><span class="line">            flag +&#x3D; 1;</span><br><span class="line">            L-&gt;elem[flag] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;last &#x3D; flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><ol><li>顺序表 数据调整<br>已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n),空间复杂度为O（1）。<br>链表结点定义如下：<blockquote><p>void odd_even(SeqList *L);<br>相关定义如下：<br>struct _seqlist{</p><pre><code>ElemType elem[MAXSIZE];int last;</code></pre><p>};<br>typedef struct _seqlist SeqList;</p></blockquote></li></ol><p>2.解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-03, Tue, 18:32:04</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void odd_even(SeqList* L)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int j &#x3D; L-&gt;last;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        while (L-&gt;elem[i] % 2 !&#x3D; 0)</span><br><span class="line">            i++;</span><br><span class="line">        while (L-&gt;elem[j] % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            j--;</span><br><span class="line">        if (i &lt; j) &#123;</span><br><span class="line">            int t &#x3D; L-&gt;elem[i];</span><br><span class="line">            L-&gt;elem[i] &#x3D; L-&gt;elem[j];</span><br><span class="line">            L-&gt;elem[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><ol><li><p>链表 删除范围内结点<br>已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有大于mink且小于maxk的元素（若表中存在这样的元素），分析你的算法的时间复杂度。<br>链表结点定义如下：</p><blockquote><p>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;<br>函数原型如下：<br>void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)<br>其中L指向链表的头结点。</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:35:51</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p, q, prev &#x3D; NULL;</span><br><span class="line">    if (mink &gt; maxk)</span><br><span class="line">        return;</span><br><span class="line">    p &#x3D; L;</span><br><span class="line">    prev &#x3D; p;</span><br><span class="line">    p &#x3D; p-&gt;next;</span><br><span class="line">    while (p &amp;&amp; p-&gt;data &lt; maxk) &#123;</span><br><span class="line">        if (p-&gt;data &lt;&#x3D; mink) &#123;</span><br><span class="line">            prev &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; p;</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            free(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h1><ol><li><p>链表 倒数查找<br>已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。<br>函数原型为：</p><blockquote><p>int lnk_search(LinkList L, int k, ElemType* p_ele)<br>若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-13, Fri, 18:40:21</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int lnk_search(LinkList L, int k, ElemType* p_ele)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p &#x3D; L-&gt;next, q &#x3D; L-&gt;next;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        if (count &lt; k)</span><br><span class="line">            count++;</span><br><span class="line">        else</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt; k)</span><br><span class="line">        return 0;</span><br><span class="line">    else &#123;</span><br><span class="line">        p_ele &#x3D; q-&gt;data;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr><h1 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h1><ol><li><p>链表 合并<br>设线性表A=(a1, a2,…,am)，B=(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：<br>C= (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；<br>或者<br>C= (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。<br>线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。<br>函数的原型如下：</p><blockquote><p>void lnk_merge(LinkList A, LinkList B, LinkList C)<br>即将A和B合并为C，其中 C 已经被初始化为空单链表<br>相关定义如下：<br>struct _lnklist{</p><pre><code>ElemType data;struct _lnklist *next;</code></pre><p>};<br>typedef struct _lnklist Node;<br>typedef struct _lnklist *LinkList;</p></blockquote></li><li><p>解析</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 完成人　：冯新越(2019091602014)</span><br><span class="line"> * 完成时间：2020-03-21, Sat, 12:38:40</span><br><span class="line"> * 最高分数：100</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;list.h&quot; &#x2F;&#x2F; 请不要删除，否则检查不通过</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void lnk_merge(LinkList A, LinkList B, LinkList C)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p, *q, *m, *temp;</span><br><span class="line">    p &#x3D; A-&gt;next;</span><br><span class="line">    q &#x3D; B-&gt;next;</span><br><span class="line">    m &#x3D; C;</span><br><span class="line">    while (p !&#x3D; NULL &amp;&amp; q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">        temp &#x3D; p-&gt;next;</span><br><span class="line">        p-&gt;next &#x3D; q;</span><br><span class="line">        m &#x3D; q;</span><br><span class="line">        p &#x3D; temp;</span><br><span class="line">        q &#x3D; q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (q !&#x3D; NULL) &#123;</span><br><span class="line">        m-&gt;next &#x3D; q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Icoding </tag>
            
            <tag> 作业 </tag>
            
            <tag> 线性表 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 顺序表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用githubPages架构简单的静态网页</title>
      <link href="/post/34560.html"/>
      <url>/post/34560.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Github账号的注册"><a href="#Github账号的注册" class="headerlink" title="Github账号的注册"></a>Github账号的注册</h1><ol><li><p>首先在<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个GitHub账号，并在你的Github Repositories下新建一个名为YourName.github.io的仓库。</p></li><li><p>所有选项按照默认配置就行。</p><blockquote><p>值得注意的是，GitHub平台是全英文的，因此具备一定的英语水平还是必要的</p></blockquote></li><li><p>其次，下载<a href="https://git-scm.com" target="_blank" rel="noopener">Git</a>并安装，所有选项按照默认配置即可</p><blockquote><p>Git的所有操作一般都在Gi bash控制台界面进行，因此学习掌握Git的使用是十分必要的</p></blockquote></li><li><p>打开Git Bash控制台，使用git config –global user.name指令生命本机用户名，之后使用git config –global user.email指令声明本机用户名对应的邮箱地址。再使用ssh-keygen -t rsa -C <a href="mailto:email@email.com">email@email.com</a>指令生成新的ssh公钥</p></li><li><p>使用cd指令选择一个合适的路径存放你的本地仓库，使用mkdir指令建立一个由你自由命名的文件夹。</p><blockquote><p>Linux指令： cd——用于切换所在目录<br>Linux指令: mkdir——用于新建文件/文件夹</p></blockquote></li><li><p>使用git init指令对本地仓库进行初始化。至此，你的一个本地仓库已经架构完成！</p><blockquote><p>Git指令： git init——用于在一个空的位置进行Git的初始化</p></blockquote></li></ol><hr><h1 id="本地仓库与Github-Repositories-建立连接"><a href="#本地仓库与Github-Repositories-建立连接" class="headerlink" title="本地仓库与Github Repositories 建立连接"></a>本地仓库与Github Repositories 建立连接</h1><ol><li>在GitHub的Settings中找到SSH and GPG keys并且选择New SSH key，找到你的电脑中.ssh文件夹中的公钥文件id_rsa.pub，并将其中的内容复制到网页相应位置，配置成功之后保存即可。</li><li>使用ssh -T <a href="mailto:git@github.com">git@github.com</a>测试连接是否成功<blockquote><p>Git指令： ssh -T <a href="mailto:git@github.com">git@github.com</a>——用于测试本地仓库与远程仓库之间是否成功连接</p></blockquote></li><li>连接测试成功之后找到网页上你的相应仓库，在Clone or Download中选择Clone with Https，复制URL。回到Git Bash控制台，使用git remote add origin [你刚刚复制的URL] 指令进行远程连接<blockquote><p>Git指令： git remote add origin [URL]——连接本地仓库到指定的远程库</p></blockquote></li><li>连接成功之后，你就可以将本地仓库的内容远程push到GitHub仓库中去了。<blockquote><p>Git指令： git push——将本地仓库的内容推送到远程库中</p><blockquote><p>Git push的一般步骤：</p><pre><code>1. git add .2. git status3. git commit -m &quot;备注内容&quot;4. git push</code></pre></blockquote></blockquote></li></ol><h1 id="启用Github-Pages功能"><a href="#启用Github-Pages功能" class="headerlink" title="启用Github Pages功能"></a>启用Github Pages功能</h1><ol><li>将你的仓库名称修改为YourName.github.io</li><li>在你的Repositories的Settings中找到GitHub Pages选项，将Source改为master branch后保存。</li></ol><h1 id="搭建一个静态网页"><a href="#搭建一个静态网页" class="headerlink" title="搭建一个静态网页"></a>搭建一个静态网页</h1><ol><li>一般的，我们从搭建静态网页开始。在本地仓库中建立index.html作为主界面文件。打开index.html</li><li>键入<p>Hello World!</p>并保存。</li><li>在你的本地仓库的文件夹内用鼠标右键单击Git Bash Here唤起Git Bash控制台，使用git add .指令将所有的文件提交到缓存区，使用git status命令查看文件状态，确认无误后，使用git commit -m “你想要留下的备注”提交更改，之后用git push命令将所有的更改上传到GitHub的远程仓库中。<blockquote><p>Git push的全套流程参见上文</p></blockquote></li><li>至此，一个最简单的静态网页就被成功搭建了。你可以通过YourName.github.io这个网址来访问你的个人网站。</li></ol><h1 id="将GitHub-Pages架构的网站解析到自己的域名"><a href="#将GitHub-Pages架构的网站解析到自己的域名" class="headerlink" title="将GitHub Pages架构的网站解析到自己的域名"></a>将GitHub Pages架构的网站解析到自己的域名</h1><ol><li>你需要购买一个域名的使用期限。本文以在腾讯云平台购买域名为例</li><li>在腾讯云官网上进行注册和实名认证，依靠后缀找到合适的域名，并且确认其是否可用。在付款之后即可使用。<blockquote><p>一个教训：选择域名后缀的时候不要贪图便宜或者过于追求新意。笔者的以.space为后缀的域名目前面临着无法进行公安备案的尴尬处境</p></blockquote></li><li>两种解析方式<ul><li>在腾讯域名管理界面选择解析，利用电脑自带的CMD或者PowerShell控制台，输入Ping YourName.github.io来确认IP地址，直接解析该IP地址，添加到解析记录中。</li><li>或者在解析时选择CNAME方式，在后面可以直接解析githubpages网址（就是YourName.github.io）</li></ul></li><li>解析记录添加成功之后即可直接从该域名访问个人网站。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 静态网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test01</title>
      <link href="/post/63177.html"/>
      <url>/post/63177.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="这是一个测试页面"><a href="#这是一个测试页面" class="headerlink" title="这是一个测试页面"></a>这是一个测试页面</h1><h2 id="测试开始于2020-02-10"><a href="#测试开始于2020-02-10" class="headerlink" title="测试开始于2020-02-10"></a>测试开始于2020-02-10</h2><h3 id="正在测试多级标题的完整性"><a href="#正在测试多级标题的完整性" class="headerlink" title="正在测试多级标题的完整性"></a>正在测试多级标题的完整性</h3><h4 id="这是第四级标题"><a href="#这是第四级标题" class="headerlink" title="这是第四级标题"></a>这是第四级标题</h4><h5 id="这是第五级标题"><a href="#这是第五级标题" class="headerlink" title="这是第五级标题"></a>这是第五级标题</h5><h6 id="这是第六级标题"><a href="#这是第六级标题" class="headerlink" title="这是第六级标题"></a>这是第六级标题</h6><pre><code>测试</code></pre><p>1234567890<br>    测试</p><ul><li>测试01</li><li>测试02</li><li>测试03</li></ul><ol start="4"><li>测试04</li><li>测试05</li><li>测试06</li></ol><p>【外链文本测试】（<a href="http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）" target="_blank" rel="noopener">http://www.xinhuanet.com//politics/2020-02/10/c_1125555826.htm）</a></p><p>【外链图片测试】<br>！【avatar】（<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/avatar.png）</a></p><p>#引用测试</p><blockquote><p>夕阳像一只狐狸悄悄穿过这片土地，转瞬间点燃荒草。——果戈里</p></blockquote><p><em>夕阳</em>像一只<strong>狐狸</strong>悄悄<em>穿过</em>这片<strong>土地</strong>，<code>转瞬间点燃荒草</code></p><p>#代码插入测试<br><code>printf(&quot;Hello,World!&quot;);</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">include&lt;stdlib.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;Sum &#x3D; %d&quot;,a+b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>#表格插入测试</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><p>#图片测试2</p><p>![][1]<br>[1]:<a href="https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg" target="_blank" rel="noopener">https://cosmos-1301148362.cos.ap-chengdu.myqcloud.com/Images/BlueChip_ZH-CN7376022522_1920x1080.jpg</a></p><p>#初次测试结束<br>###2020-02-10</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/16107.html"/>
      <url>/post/16107.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>lab</title>
      <link href="/Lab/index.html"/>
      <url>/Lab/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本页面用于实验各种未发布&#x2F;正式部署的插件&#x2F;应用程序&#x2F;架构等，不保证其鲁棒性！</span><br><span class="line">进入此页面请谨慎使用各项功能，以免造成包括但不限于死机，卡退等后果</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于自己</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>他是一个曾经高唱着“青霄有路终须到，金榜无名誓不归”的少年</li><li>他热爱生活，热爱周遭的一切，想要亲自去探索他所存在的的世界</li><li>他热爱计算机，热爱编程。与代码相处让他感到由衷的快乐</li><li>“须知少时凌云志，曾许人间第一流”</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name: Cosmos</span><br><span class="line">Age: 18</span><br><span class="line">Gender: male</span><br><span class="line">Address: ChengDu</span><br><span class="line">Github: https:&#x2F;&#x2F;github.com&#x2F;cosmos-UESTC</span><br><span class="line">Blog: https:&#x2F;&#x2F;fengxinyue.cn&#x2F;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“疏影横斜水清浅，暗香浮动月黄昏”</span><br><span class="line"></span><br><span class="line">于2020-02-10 夜</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>live2d</title>
      <link href="/live2d/index.html"/>
      <url>/live2d/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本版面用于测试开发中的Live2d模组在Butterfly主题中的应用，目前没有具体的实验方法以及具体步骤</span><br><span class="line">故无法保证实验的有效性和系统的鲁棒性！</span><br></pre></td></tr></table></figure></div>]]></content>
      
    </entry>
    
    
  
</search>
